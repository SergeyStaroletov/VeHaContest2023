
 ACL2 Version 8.3 built January 2, 2021  04:05:03.
 Copyright (C) 2020, Regents of the University of Texas
 ACL2 comes with ABSOLUTELY NO WARRANTY.  This is free software and you
 are welcome to redistribute it under certain conditions.  For details,
 see the LICENSE file distributed with ACL2.

 Initialized with (INITIALIZE-ACL2 'INCLUDE-BOOK *ACL2-PASS-2-FILES*).
 See the documentation topic note-8-3 for recent changes.
 Note: We have modified the prompt in some underlying Lisps to further
 distinguish it from the ACL2 prompt.

ACL2 Version 8.3.  Level 1.  Cbd "C:/Users/whitebot/Desktop/C-lightVer2/".
System books directory "C:/Users/whitebot/Desktop/C-lightVer2/ACL2/books/".
Type :help for help.
Type (good-bye) to quit completely out of ACL2.

ACL2 !>
Proof tree output is now enabled.  Note that :START-PROOF-TREE works
by removing 'proof-tree from the inhibit-output-lst; see :DOC set-
inhibit-output-lst.
ACL2 !><state>
ACL2 !>Use :a! to exit break-rewrite.
See :DOC set-brr-evisc-tuple and :DOC iprint to control suppression
of details when printing.

The monitored runes are:
NIL
 T
ACL2 !>
Summary
Form:  ( INCLUDE-BOOK "centaur/fty/top" ...)
Rules: NIL
Time:  0.86 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.86)
 "C:/Users/whitebot/Desktop/C-lightVer2/ACL2/books/centaur/fty/top.lisp"
ACL2 !>
Note: Writing .port file, C:/Users/whitebot/Desktop/C-lightVer2/element-
eq.port.

CERTIFICATION ATTEMPT FOR 
"C:/Users/whitebot/Desktop/C-lightVer2/element-eq.lisp"
ACL2 Version 8.3

* Step 1:  Read "C:/Users/whitebot/Desktop/C-lightVer2/element-eq.lisp"
and compute its book-hash.

* Step 2:  There were eight forms in the file.  We now attempt to establish
that each form, whether local or non-local, is indeed an admissible
embedded event form in the context of the previously admitted ones.


ACL2 !>>(INCLUDE-BOOK "std/util/defrule"
                      :DIR :SYSTEM)

Summary
Form:  ( INCLUDE-BOOK "std/util/defrule" ...)
Rules: NIL
Time:  0.02 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.02)
"C:/Users/whitebot/Desktop/C-lightVer2/ACL2/books/std/util/defrule.lisp"


ACL2 !>>(INCLUDE-BOOK "centaur/fty/top"
                      :DIR :SYSTEM)

The event ( INCLUDE-BOOK "centaur/fty/top" ...) is redundant.  See
:DOC redundant-events.

Summary
Form:  ( INCLUDE-BOOK "centaur/fty/top" ...)
Rules: NIL
Time:  0.00 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.00)
:REDUNDANT


ACL2 !>>(INCLUDE-BOOK "std/util/bstar"
                      :DIR :SYSTEM)

The event ( INCLUDE-BOOK "std/util/bstar" ...) is redundant.  See :DOC
redundant-events.

Summary
Form:  ( INCLUDE-BOOK "std/util/bstar" ...)
Rules: NIL
Time:  0.00 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.00)
:REDUNDANT


ACL2 !>>(INCLUDE-BOOK "std/typed-lists/top"
                      :DIR :SYSTEM)

Summary
Form:  ( INCLUDE-BOOK "std/typed-lists/top" ...)
Rules: NIL
Time:  0.38 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.38)
"C:/Users/whitebot/Desktop/C-lightVer2/ACL2/books/std/typed-lists/top.lisp"


ACL2 !>>(INCLUDE-BOOK "std/lists/top"
                      :DIR :SYSTEM)
Note (from clause-processors/equality): disabling DISJOIN, DISJOIN2,
CONJOIN and CONJOIN2.


Summary
Form:  ( INCLUDE-BOOK "std/lists/top" ...)
Rules: NIL
Time:  0.33 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.33)
"C:/Users/whitebot/Desktop/C-lightVer2/ACL2/books/std/lists/top.lisp"


ACL2 !>>(INCLUDE-BOOK "std/basic/inductions"
                      :DIR :SYSTEM)

Summary
Form:  ( INCLUDE-BOOK "std/basic/inductions" ...)
Rules: NIL
Time:  0.02 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.02)
"C:/Users/whitebot/Desktop/C-lightVer2/ACL2/books/std/basic/inductions.lisp"


ACL2 !>>(DEFUN ELEMENT-EQ (I J A)
               (IF (OR (NOT (NATP I)) (NOT (NATP J)))
                   0
                   (IF (> I J)
                       0
                       (IF (= I J)
                           1
                           (IF (NOT (EQUAL (NTH (- J 1) A) (NTH J A)))
                               0 (ELEMENT-EQ I (- J 1) A))))))

For the admission of ELEMENT-EQ we will use the relation O< (which
is known to be well-founded on the domain recognized by O-P) and the
measure (ACL2-COUNT J).  The non-trivial part of the measure conjecture
is

Goal
(IMPLIES (AND (NOT (OR (NOT (NATP I)) (NOT (NATP J))))
              (<= I J)
              (NOT (= I J))
              (EQUAL (NTH (+ -1 J) A) (NTH J A)))
         (O< (ACL2-COUNT (+ -1 J))
             (ACL2-COUNT J))).

<< Starting proof tree logging >>
#<\<0( DEFUN ELEMENT-EQ ...)
   1 Goal preprocess
     |  <1 subgoal>
#>\>
By the simple :definition = we reduce the conjecture to

Goal'
(IMPLIES (AND (NOT (OR (NOT (NATP I)) (NOT (NATP J))))
              (<= I J)
              (NOT (EQUAL I J))
              (EQUAL (NTH (+ -1 J) A) (NTH J A)))
         (O< (ACL2-COUNT (+ -1 J))
             (ACL2-COUNT J))).
#<\<0( DEFUN ELEMENT-EQ ...)
   1 Goal preprocess
   2 |  Goal' simp
     |  |  <2 subgoals>
#>\>
This simplifies, using the :definitions ACL2-COUNT (if-intro), INTEGER-ABS
(if-intro), NATP (if-intro), NOT (if-intro), O-FINP and O< (if-intro),
the :executable-counterparts of BINARY-+, NOT and UNARY--, primitive
type reasoning and the :rewrite rule DISTRIBUTIVITY-OF-MINUS-OVER-+,
to the following two conjectures.

Subgoal 2
(IMPLIES (AND (INTEGERP I)
              (<= 0 I)
              (INTEGERP J)
              (<= 0 J)
              (<= I J)
              (NOT (EQUAL I J))
              (EQUAL (NTH (+ -1 J) A) (NTH J A))
              (< (+ -1 J) 0))
         (< 1 J)).
#<\<0( DEFUN ELEMENT-EQ ...)
   1 Goal preprocess
   2 |  Goal' simp
     |  |  <1 more subgoal>
#>\>
But we reduce the conjecture to T, by the :executable-counterpart of
TAU-SYSTEM.

Subgoal 1
(IMPLIES (AND (INTEGERP I)
              (<= 0 I)
              (INTEGERP J)
              (<= 0 J)
              (<= I J)
              (NOT (EQUAL I J))
              (EQUAL (NTH (+ -1 J) A) (NTH J A))
              (<= 0 (+ -1 J)))
         (< (+ -1 J) J)).
#<\<0( DEFUN ELEMENT-EQ ...)
Q.E.D.#>\>
But we reduce the conjecture to T, by the :executable-counterpart of
TAU-SYSTEM.

Q.E.D.

That completes the proof of the measure theorem for ELEMENT-EQ.  Thus,
we admit this function under the principle of definition.  We observe
that the type of ELEMENT-EQ is described by the theorem 
(OR (EQUAL (ELEMENT-EQ I J A) 0) (EQUAL (ELEMENT-EQ I J A) 1)).  We
used the :compound-recognizer rule NATP-COMPOUND-RECOGNIZER.

Summary
Form:  ( DEFUN ELEMENT-EQ ...)
Rules: ((:COMPOUND-RECOGNIZER NATP-COMPOUND-RECOGNIZER)
        (:DEFINITION =)
        (:DEFINITION ACL2-COUNT)
        (:DEFINITION INTEGER-ABS)
        (:DEFINITION NATP)
        (:DEFINITION NOT)
        (:DEFINITION O-FINP)
        (:DEFINITION O<)
        (:EXECUTABLE-COUNTERPART BINARY-+)
        (:EXECUTABLE-COUNTERPART NOT)
        (:EXECUTABLE-COUNTERPART TAU-SYSTEM)
        (:EXECUTABLE-COUNTERPART UNARY--)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:REWRITE DISTRIBUTIVITY-OF-MINUS-OVER-+))
Splitter rules (see :DOC splitter):
  if-intro: ((:DEFINITION ACL2-COUNT)
             (:DEFINITION INTEGER-ABS)
             (:DEFINITION NATP)
             (:DEFINITION NOT)
             (:DEFINITION O<))
Time:  0.00 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.00)
Prover steps counted:  547
ELEMENT-EQ

* Step 3:  That completes the admissibility check.  Each form read
was an embedded event form and was admissible.  No LOCAL forms make
it necessary to check for local incompatibilities, so we skip that
check.

ACL2 Warning [Guards] in (CERTIFY-BOOK "element-eq" ...):  The book
"C:/Users/whitebot/Desktop/C-lightVer2/element-eq.lisp" defines the
function ELEMENT-EQ, which has not had its guards verified.  Moreover,
this book's included sub-books and/or its certification world define
functions CDR-CDR-INDUCT, CDR-DEC-INDUCT, CDR-INDUCT, DEC-DEC-INDUCT,
DEC-INDUCT, DEFSORT-FUNCTIONAL-INST-SUBST, FLAG::DO-BOTH, ELEMENT-EQUIV,
ELEMENT-LIST-EQUIV, ELEMENT-LIST-FIX, ELEMENT-LIST-NONEMPTY-P, 
ELEMENT-LIST-P, ELEMENTLIST-MAPAPPEND, ELEMENTLIST-PROJECTION, 
FIX-COMPARABLEP, FLAG-IS, IFF-LIST, INTERSECTP-WITNESS, KEYVAL-ALIST-P,
STD::MAKE-DEFINE-CONFIG-FN, XDOC::MAKE-XDOC-FRAGMENTS, NATS-EQUIV,
OUTELEMENT-LIST-P, RULETABLE-DELETE-TAGS, RULETABLE-KEEP-TAGS, 
SAVED-OBLIGS-HINTS-TO-COMPUTED, SAVED-OBLIGS-PROOFLST-COLLECT-HINTS,
SET-UNEQUAL-WITNESS, SUBSETP-WITNESS, UNIVERSAL-EQUIV-EQUIVTERMS, 
UNIVERSAL-EQUIV-MULTI-QVAR-BINDINGS and UNIVERSAL-EQUIV-QVAR-BINDINGS,
which have not had their guards verified.  See :DOC guards.


* Step 4:  Write the certificate for 
"C:/Users/whitebot/Desktop/C-lightVer2/element-eq.lisp" in 
"C:/Users/whitebot/Desktop/C-lightVer2/element-eq.cert".

* Step 5:  Compile the functions defined in 
"C:/Users/whitebot/Desktop/C-lightVer2/element-eq.lisp".

Writing book expansion file, C:/Users/whitebot/Desktop/C-lightVer2/element-
eq@expansion.lsp.


Note: Deleting expansion file for the book,
C:/Users/whitebot/Desktop/C-lightVer2/element-eq.lisp.

Summary
Form:  (CERTIFY-BOOK "element-eq" ...)
Rules: NIL
Warnings:  Guards
Time:  0.77 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.77)
Prover steps counted:  547
 "C:/Users/whitebot/Desktop/C-lightVer2/element-eq.lisp"
ACL2 !>   d       1:x(INCLUDE-BOOK "centaur/fty/top"
                            :DIR ...)
ACL2 !>
Note: Writing .port file, C:/Users/whitebot/Desktop/C-lightVer2/element_-
equality-verification-condition-theory.port.

CERTIFICATION ATTEMPT FOR 
"C:/Users/whitebot/Desktop/C-lightVer2/element_equality-verification-condition-theory.lisp"

ACL2 Version 8.3

* Step 1:  Read 
"C:/Users/whitebot/Desktop/C-lightVer2/element_equality-verification-condition-theory.lisp"
and compute its book-hash.

* Step 2:  There were 16 forms in the file.  We now attempt to establish
that each form, whether local or non-local, is indeed an admissible
embedded event form in the context of the previously admitted ones.


ACL2 !>>(INCLUDE-BOOK "std/util/defrule"
                      :DIR :SYSTEM)

Summary
Form:  ( INCLUDE-BOOK "std/util/defrule" ...)
Rules: NIL
Time:  0.02 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.02)
"C:/Users/whitebot/Desktop/C-lightVer2/ACL2/books/std/util/defrule.lisp"


ACL2 !>>(INCLUDE-BOOK "centaur/fty/top"
                      :DIR :SYSTEM)

The event ( INCLUDE-BOOK "centaur/fty/top" ...) is redundant.  See
:DOC redundant-events.

Summary
Form:  ( INCLUDE-BOOK "centaur/fty/top" ...)
Rules: NIL
Time:  0.00 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.00)
:REDUNDANT


ACL2 !>>(INCLUDE-BOOK "std/util/bstar"
                      :DIR :SYSTEM)

The event ( INCLUDE-BOOK "std/util/bstar" ...) is redundant.  See :DOC
redundant-events.

Summary
Form:  ( INCLUDE-BOOK "std/util/bstar" ...)
Rules: NIL
Time:  0.00 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.00)
:REDUNDANT


ACL2 !>>(INCLUDE-BOOK "std/typed-lists/top"
                      :DIR :SYSTEM)

Summary
Form:  ( INCLUDE-BOOK "std/typed-lists/top" ...)
Rules: NIL
Time:  0.38 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.38)
"C:/Users/whitebot/Desktop/C-lightVer2/ACL2/books/std/typed-lists/top.lisp"


ACL2 !>>(INCLUDE-BOOK "std/lists/top"
                      :DIR :SYSTEM)
Note (from clause-processors/equality): disabling DISJOIN, DISJOIN2,
CONJOIN and CONJOIN2.


Summary
Form:  ( INCLUDE-BOOK "std/lists/top" ...)
Rules: NIL
Time:  0.33 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.33)
"C:/Users/whitebot/Desktop/C-lightVer2/ACL2/books/std/lists/top.lisp"


ACL2 !>>(INCLUDE-BOOK "std/basic/inductions"
                      :DIR :SYSTEM)

Summary
Form:  ( INCLUDE-BOOK "std/basic/inductions" ...)
Rules: NIL
Time:  0.00 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.00)
"C:/Users/whitebot/Desktop/C-lightVer2/ACL2/books/std/basic/inductions.lisp"


ACL2 !>>(INCLUDE-BOOK "element-eq")

Summary
Form:  ( INCLUDE-BOOK "element-eq" ...)
Rules: NIL
Time:  0.02 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.02)
"C:/Users/whitebot/Desktop/C-lightVer2/element-eq.lisp"


ACL2 !>>(DEFRULE INTEGER-SUM-REWRITE
                 (IMPLIES (AND (INTEGERP X) (INTEGERP Y))
                          (EQUAL (IFIX (+ X Y)) (+ X Y)))
                 :RULE-CLASSES :REWRITE)

ACL2 Warning [Non-rec] in ( DEFTHM INTEGER-SUM-REWRITE ...):  A :REWRITE
rule generated from INTEGER-SUM-REWRITE will be triggered only by terms
containing the function symbol IFIX, which has a non-recursive definition.
Unless this definition is disabled, this rule is unlikely ever to be
used.


<< Starting proof tree logging >>
#<\<0( DEFTHM INTEGER-SUM-REWRITE ...)
   1 Goal preprocess
     |  <1 subgoal>
#>\>#<\<0( DEFTHM INTEGER-SUM-REWRITE ...)
Q.E.D.#>\>
But simplification reduces this to T, using the :definition IFIX and
primitive type reasoning.

Q.E.D.

Summary
Form:  ( DEFTHM INTEGER-SUM-REWRITE ...)
Rules: ((:DEFINITION IFIX)
        (:FAKE-RUNE-FOR-TYPE-SET NIL))
Warnings:  Non-rec
Time:  0.00 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.00)
Prover steps counted:  63
INTEGER-SUM-REWRITE


ACL2 !>>(DEFRULE INTEGER-SUM-MINUS-FIRST-ARG-REWRITE
                 (IMPLIES (AND (INTEGERP X) (INTEGERP Y))
                          (EQUAL (IFIX (+ (- X) Y)) (+ (- X) Y)))
                 :RULE-CLASSES :REWRITE)

ACL2 Warning [Non-rec] in ( DEFTHM INTEGER-SUM-MINUS-FIRST-ARG-REWRITE
...):  A :REWRITE rule generated from INTEGER-SUM-MINUS-FIRST-ARG-REWRITE
will be triggered only by terms containing the function symbol IFIX,
which has a non-recursive definition.  Unless this definition is disabled,
this rule is unlikely ever to be used.


<< Starting proof tree logging >>
#<\<0( DEFTHM INTEGER-SUM-MINUS-FIRST-ARG-REWRITE ...)
   1 Goal preprocess
     |  <1 subgoal>
#>\>#<\<0( DEFTHM INTEGER-SUM-MINUS-FIRST-ARG-REWRITE ...)
Q.E.D.#>\>
But simplification reduces this to T, using primitive type reasoning
and the :rewrite rule INTEGER-SUM-REWRITE.

Q.E.D.

Summary
Form:  ( DEFTHM INTEGER-SUM-MINUS-FIRST-ARG-REWRITE ...)
Rules: ((:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:REWRITE INTEGER-SUM-REWRITE))
Warnings:  Non-rec
Time:  0.00 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.00)
Prover steps counted:  68
INTEGER-SUM-MINUS-FIRST-ARG-REWRITE


ACL2 !>>(DEFRULE INTEGER-SUM-MINUS-SECOND-ARG-REWRITE
                 (IMPLIES (AND (INTEGERP X) (INTEGERP Y))
                          (EQUAL (IFIX (+ X (- Y))) (+ X (- Y))))
                 :RULE-CLASSES :REWRITE)

ACL2 Warning [Non-rec] in ( DEFTHM INTEGER-SUM-MINUS-SECOND-ARG-REWRITE
...):  A :REWRITE rule generated from INTEGER-SUM-MINUS-SECOND-ARG-REWRITE
will be triggered only by terms containing the function symbol IFIX,
which has a non-recursive definition.  Unless this definition is disabled,
this rule is unlikely ever to be used.


<< Starting proof tree logging >>
#<\<0( DEFTHM INTEGER-SUM-MINUS-SECOND-ARG-REWRITE ...)
   1 Goal preprocess
     |  <1 subgoal>
#>\>#<\<0( DEFTHM INTEGER-SUM-MINUS-SECOND-ARG-REWRITE ...)
Q.E.D.#>\>
But simplification reduces this to T, using primitive type reasoning
and the :rewrite rule INTEGER-SUM-REWRITE.

Q.E.D.

Summary
Form:  ( DEFTHM INTEGER-SUM-MINUS-SECOND-ARG-REWRITE ...)
Rules: ((:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:REWRITE INTEGER-SUM-REWRITE))
Warnings:  Non-rec
Time:  0.00 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.00)
Prover steps counted:  68
INTEGER-SUM-MINUS-SECOND-ARG-REWRITE


ACL2 !>>(FTY::DEFPROD FRAME-1
                      ((I INTEGERP)
                       (RESULT INTEGERP)
                       (LOOP-BREAK BOOLEANP)))
Form:  ( TABLE XDOC ...)
Time:  0.00 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.00)
Form:  ( TABLE STD::DEFAULT-HINTS-TABLE ...)
Time:  0.00 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.00)
Form:  ( TABLE STD::DEFAULT-HINTS-TABLE ...)
Time:  0.00 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.00)
Form:  ( TABLE STD::DEFAULT-HINTS-TABLE ...)
Time:  0.00 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.00)
Form:  ( TABLE STD::DEFAULT-HINTS-TABLE ...)
Time:  0.00 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.00)
Form:  ( DEFTHEORY FTY::DEFTYPES-ORIG-THEORY ...)
Time:  0.00 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.00)
Form:  ( DEFTHEORY FTY::DEFTYPES-TYPE-THEORY ...)
Time:  0.00 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.00)
Form:  ( MAKE-EVENT (CONS ...))
Time:  0.00 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.00)
Form:  ( DEFLABEL FTY::DEFTYPES-BEFORE-TEMP-THMS ...)
Time:  0.00 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.00)
#<\<0( DEFTHM TMP-DEFTYPES-INTEGERP-OF-IFIX ...)
Q.E.D.#>\>Form:  ( DEFTHM TMP-DEFTYPES-INTEGERP-OF-IFIX ...)
Time:  0.00 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.00)
Form:  ( MAKE-EVENT (QUOTE ...))
Time:  0.00 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.00)
#<\<0( DEFTHM TMP-DEFTYPES-IFIX-WHEN-INTEGERP ...)
   1 Goal preprocess
     |  <1 subgoal>
#>\>#<\<0( DEFTHM TMP-DEFTYPES-IFIX-WHEN-INTEGERP ...)
Q.E.D.#>\>Form:  ( DEFTHM TMP-DEFTYPES-IFIX-WHEN-INTEGERP ...)
Time:  0.02 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.02)
Form:  ( MAKE-EVENT (QUOTE ...))
Time:  0.02 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.02)
#<\<0( DEFTHM TMP-DEFTYPES-BOOLEANP-OF-BOOL-FIX$INLINE ...)
Q.E.D.#>\>Form:  ( DEFTHM TMP-DEFTYPES-BOOLEANP-OF-BOOL-FIX$INLINE ...)
Time:  0.00 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.00)
Form:  ( MAKE-EVENT (QUOTE ...))
Time:  0.00 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.00)
Form:  ( PROGN (LOCAL ...) ...)
Time:  0.02 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.02)
Form:  ( DEFTHEORY FTY::DEFTYPES-TEMP-THMS ...)
Time:  0.00 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.00)

ACL2 Warning [Theory] in ( IN-THEORY (DISABLE ...)):  The :DEFINITION
rules for the built-in functions DOUBLE-REWRITE, THE-CHECK, CONS-WITH-HINT,
IFF, WORMHOLE-EVAL, MV-LIST, MINUSP, PLUSP, ZEROP, LISTP, SYNP, CASE-SPLIT,
FORCE, /=, =, RETURN-LAST, NULL, ENDP, ATOM, EQL, NOT, IMPLIES and
EQ are disabled by the theory expression (DISABLE FTY::DEFTYPES-ORIG-THEORY),
but some expansions of their calls may still occur.  See :DOC theories-
and-primitives.


ACL2 Warning [Theory] in ( IN-THEORY (DISABLE ...)):  The :EXECUTABLE-
COUNTERPART rules for the built-in functions NOT, SYMBOLP, 
SYMBOL-PACKAGE-NAME, SYMBOL-NAME, STRINGP, REALPART, RATIONALP, PKG-WITNESS,
PKG-IMPORTS, NUMERATOR, INTERN-IN-PACKAGE-OF-SYMBOL, INTEGERP, IMAGPART,
IF, EQUAL, DENOMINATOR, CONSP, CONS, COERCE, COMPLEX-RATIONALP, COMPLEX,
CODE-CHAR, CHARACTERP, CHAR-CODE, CDR, CAR, <, UNARY-/, UNARY--, BINARY-+,
BINARY-* and ACL2-NUMBERP are disabled by the theory expression 
(DISABLE FTY::DEFTYPES-ORIG-THEORY), but some evaluations of their
calls may still occur.  See :DOC theories-and-primitives.

Form:  ( IN-THEORY (DISABLE ...))
Time:  0.00 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.00)
Form:  ( IN-THEORY (ENABLE ...))
Time:  0.00 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.00)
Form:  ( IN-THEORY (ENABLE* ...))
Time:  0.00 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.00)
Form:  ( TABLE DEFINE ...)
Time:  0.00 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.00)
#<\<0( DEFUN FRAME-1-P ...)
   3 Goal preprocess
     |  <3 subgoals>
#>\>#<\<0( DEFUN FRAME-1-P ...)
   3 Goal preprocess
     |  <2 more subgoals>
#>\>#<\<0( DEFUN FRAME-1-P ...)
   3 Goal preprocess
     |  <1 more subgoal>
#>\>#<\<0( DEFUN FRAME-1-P ...)
Q.E.D.#>\>Form:  ( DEFUN FRAME-1-P ...)
Time:  0.00 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.00)
#<\<0( DEFTHM CONSP-WHEN-FRAME-1-P ...)
   1 Goal preprocess
     |  <1 subgoal>
#>\>#<\<0( DEFTHM CONSP-WHEN-FRAME-1-P ...)
Q.E.D.#>\>Form:  ( DEFTHM CONSP-WHEN-FRAME-1-P ...)
Time:  0.00 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.00)
Form:  ( MAKE-EVENT (QUOTE ...))
Time:  0.00 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.00)
Form:  ( PROGN (MAKE-EVENT ...) ...)
Time:  0.00 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.00)
Form:  ( IN-THEORY (DISABLE ...))
Time:  0.00 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.00)
Form:  ( DEFMACRO FRAME-1-FIX ...)
Time:  0.00 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.00)
Form:  ( DEFUN FRAME-1-FIX$INLINE ...)
Time:  0.00 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.00)
#<\<0( DEFTHM FRAME-1-P-OF-FRAME-1-FIX ...)
   1 Goal preprocess
     |  <1 subgoal>
#>\>#<\<0( DEFTHM FRAME-1-P-OF-FRAME-1-FIX ...)
   1 Goal preprocess
   1 |  Goal' simp
     |  |  <1 subgoal>
#>\>#<\<0( DEFTHM FRAME-1-P-OF-FRAME-1-FIX ...)
   1 Goal preprocess
   1 |  Goal' simp
   1 |  |  Goal'' simp
     |  |  |  <1 subgoal>
#>\>#<\<0( DEFTHM FRAME-1-P-OF-FRAME-1-FIX ...)
Q.E.D.#>\>Form:  ( DEFTHM FRAME-1-P-OF-FRAME-1-FIX ...)
Time:  0.02 seconds (prove: 0.02, print: 0.00, proof tree: 0.00, other: 0.00)
Form:  ( PROGN (DEFTHM FRAME-1-P-OF-FRAME-1-FIX ...) ...)
Time:  0.02 seconds (prove: 0.02, print: 0.00, proof tree: 0.00, other: 0.00)
Form:  ( IN-THEORY (DISABLE ...))
Time:  0.00 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.00)
#<\<0( DEFTHM FRAME-1-FIX-WHEN-FRAME-1-P ...)
   1 Goal preprocess
     |  <1 subgoal>
#>\>#<\<0( DEFTHM FRAME-1-FIX-WHEN-FRAME-1-P ...)
   1 Goal simp
     |  <1 subgoal>
#>\>#<\<0( DEFTHM FRAME-1-FIX-WHEN-FRAME-1-P ...)
   1 Goal simp
   1 |  Goal' preprocess
     |  |  <1 subgoal>
#>\>#<\<0( DEFTHM FRAME-1-FIX-WHEN-FRAME-1-P ...)
Q.E.D.#>\>Form:  ( DEFTHM FRAME-1-FIX-WHEN-FRAME-1-P ...)
Time:  0.00 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.00)
#<\<0( VERIFY-GUARDS FRAME-1-FIX$INLINE ...)
   1 Goal preprocess
     |  <1 subgoal>
#>\>#<\<0( VERIFY-GUARDS FRAME-1-FIX$INLINE ...)
   1 Goal preprocess
   1 |  Goal' simp
     |  |  <1 subgoal>
#>\>#<\<0( VERIFY-GUARDS FRAME-1-FIX$INLINE ...)
   1 Goal preprocess
   1 |  Goal' simp
   1 |  |  Goal'' preprocess
     |  |  |  <1 subgoal>
#>\>#<\<0( VERIFY-GUARDS FRAME-1-FIX$INLINE ...)
Q.E.D.#>\>Form:  ( VERIFY-GUARDS FRAME-1-FIX$INLINE ...)
Time:  0.00 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.00)
Form:  ( MAKE-EVENT (LET* ...) ...)
Time:  0.00 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.00)
#<\<0( DEFTHM FTY::TMP-DEFFIXTYPE-IDEMPOTENT ...)
Q.E.D.#>\>Form:  ( DEFTHM FTY::TMP-DEFFIXTYPE-IDEMPOTENT ...)
Time:  0.00 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.00)
Form:  ( ENCAPSULATE NIL (FTY::DEFFIXTYPE ... T) ...)
Time:  0.02 seconds (prove: 0.02, print: 0.00, proof tree: 0.00, other: 0.00)
Form:  ( IN-THEORY (ENABLE ...))
Time:  0.00 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.00)
Form:  ( PROGN (LOCAL ...) ...)
Time:  0.02 seconds (prove: 0.02, print: 0.00, proof tree: 0.00, other: 0.00)
Form:  ( IN-THEORY (ENABLE ...))
Time:  0.00 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.00)
Form:  ( IN-THEORY (DISABLE ...))
Time:  0.00 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.00)
Form:  ( DEFMACRO FRAME-1->I ...)
Time:  0.00 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.00)
#<\<0( DEFUN FRAME-1->I$INLINE ...)
   1 Goal preprocess
     |  <1 subgoal>
#>\>#<\<0( DEFUN FRAME-1->I$INLINE ...)
Q.E.D.#>\>Form:  ( DEFUN FRAME-1->I$INLINE ...)
Time:  0.00 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.00)
#<\<0( DEFTHM INTEGERP-OF-FRAME-1->I ...)
Q.E.D.#>\>Form:  ( DEFTHM INTEGERP-OF-FRAME-1->I ...)
Time:  0.00 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.00)
Form:  ( PROGN (DEFTHM INTEGERP-OF-FRAME-1->I ...) ...)
Time:  0.00 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.00)
#<\<0( DEFTHM FRAME-1->I$INLINE-OF-FRAME-1-FIX-X ...)
   1 Goal preprocess
     |  <1 subgoal>
#>\>#<\<0( DEFTHM FRAME-1->I$INLINE-OF-FRAME-1-FIX-X ...)
Q.E.D.#>\>Form:  ( DEFTHM FRAME-1->I$INLINE-OF-FRAME-1-FIX-X ...)
Time:  0.02 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.02)
Form:  ( PROGN (FTY::DEFFIXEQUIV FRAME-1->I ...) ...)
Time:  0.02 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.02)
Form:  ( IN-THEORY (ENABLE ...))
Time:  0.00 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.00)
Form:  ( DEFMACRO FRAME-1->RESULT ...)
Time:  0.00 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.00)
#<\<0( DEFUN FRAME-1->RESULT$INLINE ...)
   1 Goal preprocess
     |  <1 subgoal>
#>\>#<\<0( DEFUN FRAME-1->RESULT$INLINE ...)
Q.E.D.#>\>Form:  ( DEFUN FRAME-1->RESULT$INLINE ...)
Time:  0.00 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.00)
#<\<0( DEFTHM INTEGERP-OF-FRAME-1->RESULT ...)
Q.E.D.#>\>Form:  ( DEFTHM INTEGERP-OF-FRAME-1->RESULT ...)
Time:  0.00 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.00)
Form:  ( PROGN (DEFTHM INTEGERP-OF-FRAME-1->RESULT ...) ...)
Time:  0.00 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.00)
#<\<0( DEFTHM FRAME-1->RESULT$INLINE-OF-FRAME-1-FIX-X ...)
   1 Goal preprocess
     |  <1 subgoal>
#>\>#<\<0( DEFTHM FRAME-1->RESULT$INLINE-OF-FRAME-1-FIX-X ...)
Q.E.D.#>\>Form:  ( DEFTHM FRAME-1->RESULT$INLINE-OF-FRAME-1-FIX-X ...)
Time:  0.00 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.00)
Form:  ( PROGN (FTY::DEFFIXEQUIV FRAME-1->RESULT ...) ...)
Time:  0.02 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.02)
Form:  ( IN-THEORY (ENABLE ...))
Time:  0.00 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.00)
Form:  ( DEFMACRO FRAME-1->LOOP-BREAK ...)
Time:  0.00 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.00)
#<\<0( DEFUN FRAME-1->LOOP-BREAK$INLINE ...)
   1 Goal preprocess
     |  <1 subgoal>
#>\>#<\<0( DEFUN FRAME-1->LOOP-BREAK$INLINE ...)
Q.E.D.#>\>Form:  ( DEFUN FRAME-1->LOOP-BREAK$INLINE ...)
Time:  0.00 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.00)
#<\<0( DEFTHM BOOLEANP-OF-FRAME-1->LOOP-BREAK ...)
Q.E.D.#>\>Form:  ( DEFTHM BOOLEANP-OF-FRAME-1->LOOP-BREAK ...)
Time:  0.00 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.00)
Form:  ( PROGN (DEFTHM BOOLEANP-OF-FRAME-1->LOOP-BREAK ...) ...)
Time:  0.00 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.00)
#<\<0( DEFTHM FRAME-1->LOOP-BREAK$INLINE-OF-FRAME-1-FIX-X ...)
   1 Goal preprocess
     |  <1 subgoal>
#>\>#<\<0( DEFTHM FRAME-1->LOOP-BREAK$INLINE-OF-FRAME-1-FIX-X ...)
Q.E.D.#>\>Form:  ( DEFTHM FRAME-1->LOOP-BREAK$INLINE-OF-FRAME-1-FIX-X ...)
Time:  0.00 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.00)
Form:  ( PROGN (FTY::DEFFIXEQUIV FRAME-1->LOOP-BREAK ...) ...)
Time:  0.00 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.00)
Form:  ( IN-THEORY (ENABLE ...))
Time:  0.00 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.00)
#<\<0( DEFUN FRAME-1 ...)
   1 Goal preprocess
     |  <1 subgoal>
#>\>#<\<0( DEFUN FRAME-1 ...)
Q.E.D.#>\>Form:  ( DEFUN FRAME-1 ...)
Time:  0.02 seconds (prove: 0.02, print: 0.00, proof tree: 0.00, other: 0.00)
#<\<0( DEFTHM FRAME-1-P-OF-FRAME-1 ...)
   3 Goal preprocess
     |  <3 subgoals>
#>\>#<\<0( DEFTHM FRAME-1-P-OF-FRAME-1 ...)
   3 Goal preprocess
     |  <2 more subgoals>
#>\>#<\<0( DEFTHM FRAME-1-P-OF-FRAME-1 ...)
   3 Goal preprocess
     |  <1 more subgoal>
#>\>#<\<0( DEFTHM FRAME-1-P-OF-FRAME-1 ...)
Q.E.D.#>\>Form:  ( DEFTHM FRAME-1-P-OF-FRAME-1 ...)
Time:  0.02 seconds (prove: 0.02, print: 0.00, proof tree: 0.00, other: 0.00)
Form:  ( PROGN (DEFTHM FRAME-1-P-OF-FRAME-1 ...) ...)
Time:  0.02 seconds (prove: 0.02, print: 0.00, proof tree: 0.00, other: 0.00)
#<\<0( DEFTHM FRAME-1->I-OF-FRAME-1 ...)
   1 Goal preprocess
     |  <1 subgoal>
#>\>#<\<0( DEFTHM FRAME-1->I-OF-FRAME-1 ...)
   1 Goal preprocess
   1 |  Goal' preprocess
     |  |  <1 subgoal>
#>\>#<\<0( DEFTHM FRAME-1->I-OF-FRAME-1 ...)
Q.E.D.#>\>Form:  ( DEFTHM FRAME-1->I-OF-FRAME-1 ...)
Time:  0.00 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.00)
#<\<0( DEFTHM FRAME-1->RESULT-OF-FRAME-1 ...)
   1 Goal preprocess
     |  <1 subgoal>
#>\>#<\<0( DEFTHM FRAME-1->RESULT-OF-FRAME-1 ...)
   1 Goal preprocess
   1 |  Goal' preprocess
     |  |  <1 subgoal>
#>\>#<\<0( DEFTHM FRAME-1->RESULT-OF-FRAME-1 ...)
Q.E.D.#>\>Form:  ( DEFTHM FRAME-1->RESULT-OF-FRAME-1 ...)
Time:  0.00 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.00)
#<\<0( DEFTHM FRAME-1->LOOP-BREAK-OF-FRAME-1 ...)
   1 Goal preprocess
     |  <1 subgoal>
#>\>#<\<0( DEFTHM FRAME-1->LOOP-BREAK-OF-FRAME-1 ...)
   1 Goal preprocess
   1 |  Goal' preprocess
     |  |  <1 subgoal>
#>\>#<\<0( DEFTHM FRAME-1->LOOP-BREAK-OF-FRAME-1 ...)
Q.E.D.#>\>Form:  ( DEFTHM FRAME-1->LOOP-BREAK-OF-FRAME-1 ...)
Time:  0.00 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.00)
#<\<0( DEFTHM FRAME-1-OF-FIELDS ...)
   1 Goal preprocess
     |  <1 subgoal>
#>\>#<\<0( DEFTHM FRAME-1-OF-FIELDS ...)
Q.E.D.#>\>Form:  ( DEFTHM FRAME-1-OF-FIELDS ...)
Time:  0.00 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.00)
#<\<0( DEFTHM FRAME-1-FIX-WHEN-FRAME-1 ...)
   1 Goal preprocess
     |  <1 subgoal>
#>\>#<\<0( DEFTHM FRAME-1-FIX-WHEN-FRAME-1 ...)
Q.E.D.#>\>Form:  ( DEFTHM FRAME-1-FIX-WHEN-FRAME-1 ...)
Time:  0.00 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.00)
#<\<0( DEFTHM EQUAL-OF-FRAME-1 ...)
   1 Goal top-level-hints
     |  <1 subgoal>
#>\>#<\<0( DEFTHM EQUAL-OF-FRAME-1 ...)
   1 Goal top-level-hints
   5 |  Goal' simp
     |  |  <5 subgoals>
#>\>#<\<0( DEFTHM EQUAL-OF-FRAME-1 ...)
   1 Goal top-level-hints
   5 |  Goal' simp
   1 |  |  Subgoal 5 simp
     |  |  |  <1 subgoal>
     |  |  <4 more subgoals>
#>\>#<\<0( DEFTHM EQUAL-OF-FRAME-1 ...)
   1 Goal top-level-hints
   5 |  Goal' simp
   1 |  |  Subgoal 5 simp
   1 |  |  |  Subgoal 5' preprocess
     |  |  |  |  <1 subgoal>
     |  |  <4 more subgoals>
#>\>#<\<0( DEFTHM EQUAL-OF-FRAME-1 ...)
   1 Goal top-level-hints
   5 |  Goal' simp
   1 |  |  Subgoal 5 simp
   1 |  |  |  Subgoal 5' preprocess
   1 |  |  |  |  Subgoal 5'' simp
     |  |  |  |  |  <1 subgoal>
     |  |  <4 more subgoals>
#>\>#<\<0( DEFTHM EQUAL-OF-FRAME-1 ...)
   1 Goal top-level-hints
   5 |  Goal' simp
     |  |  <4 more subgoals>
#>\>#<\<0( DEFTHM EQUAL-OF-FRAME-1 ...)
   1 Goal top-level-hints
   5 |  Goal' simp
     |  |  <3 more subgoals>
#>\>#<\<0( DEFTHM EQUAL-OF-FRAME-1 ...)
   1 Goal top-level-hints
   5 |  Goal' simp
     |  |  <2 more subgoals>
#>\>#<\<0( DEFTHM EQUAL-OF-FRAME-1 ...)
   1 Goal top-level-hints
   5 |  Goal' simp
     |  |  <1 more subgoal>
#>\>#<\<0( DEFTHM EQUAL-OF-FRAME-1 ...)
Q.E.D.#>\>Form:  ( DEFTHM EQUAL-OF-FRAME-1 ...)
Time:  0.02 seconds (prove: 0.02, print: 0.00, proof tree: 0.00, other: 0.00)
#<\<0( DEFTHM FRAME-1-OF-IFIX-I ...)
   1 Goal preprocess
     |  <1 subgoal>
#>\>#<\<0( DEFTHM FRAME-1-OF-IFIX-I ...)
Q.E.D.#>\>Form:  ( DEFTHM FRAME-1-OF-IFIX-I ...)
Time:  0.00 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.00)
#<\<0( DEFTHM FRAME-1-OF-IFIX-RESULT ...)
   1 Goal preprocess
     |  <1 subgoal>
#>\>#<\<0( DEFTHM FRAME-1-OF-IFIX-RESULT ...)
Q.E.D.#>\>Form:  ( DEFTHM FRAME-1-OF-IFIX-RESULT ...)
Time:  0.00 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.00)
#<\<0( DEFTHM FRAME-1-OF-BOOL-FIX-LOOP-BREAK ...)
   1 Goal preprocess
     |  <1 subgoal>
#>\>#<\<0( DEFTHM FRAME-1-OF-BOOL-FIX-LOOP-BREAK ...)
Q.E.D.#>\>Form:  ( DEFTHM FRAME-1-OF-BOOL-FIX-LOOP-BREAK ...)
Time:  0.00 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.00)
Form:  ( DEFMACRO PATBIND-FRAME-1 ...)
Time:  0.00 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.00)
Form:  ( TABLE B*-BINDER-TABLE ...)
Time:  0.00 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.00)
Form:  ( PROGN (DEFXDOC PATBIND-FRAME-1 ...) ...)
Time:  0.00 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.00)
Form:  ( DEFMACRO MAKE-FRAME-1 ...)
Time:  0.00 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.00)
Form:  ( DEFMACRO CHANGE-FRAME-1 ...)
Time:  0.00 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.00)
Form:  ( PROGN (DEFTHM FRAME-1->I-OF-FRAME-1 ...) ...)
Time:  0.05 seconds (prove: 0.03, print: 0.00, proof tree: 0.00, other: 0.02)
Form:  ( IN-THEORY (ENABLE ...))
Time:  0.00 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.00)
#<\<0( DEFTHM FRAME-1-FIX-REDEF ...)
Q.E.D.#>\>Form:  ( DEFTHM FRAME-1-FIX-REDEF ...)
Time:  0.00 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.00)
Form:  ( IN-THEORY (DISABLE ...))
Time:  0.00 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.00)
Form:  ( IN-THEORY (ENABLE ...))
Time:  0.02 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.02)
Form:  ( TABLE FTY::FLEXTYPES-TABLE ...)
Time:  0.00 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.00)
Form:  ( TABLE XDOC ...)
Time:  0.00 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.00)
Form:  ( PROGN (DEFXDOC FRAME-1 ...) ...)
Time:  0.00 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.00)
Form:  ( MAKE-EVENT (B* ...))
Time:  0.00 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.00)
Form:  ( TABLE XDOC ...)
Time:  0.00 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.00)
Form:  ( TABLE XDOC ...)
Time:  0.00 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.00)
Form:  ( PROGN (DEFXDOC FRAME-1 ...) ...)
Time:  0.00 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.00)
Form:  ( MAKE-EVENT (B* ...))
Time:  0.00 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.00)
Form:  ( PROGN (TABLE XDOC ...) ...)
Time:  0.00 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.00)
Form:  ( MAKE-EVENT (FTY::FLEXTYPES-FINAL-XDOC-FN ...))
Time:  0.00 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.00)
Form:  ( PROGN (LOCAL ...) ...)
Time:  0.19 seconds (prove: 0.09, print: 0.00, proof tree: 0.00, other: 0.09)
Form:  ( ENCAPSULATE NIL (WITH-OUTPUT :SUMMARY ...) ...)
Time:  0.20 seconds (prove: 0.09, print: 0.00, proof tree: 0.00, other: 0.11)

Summary
Form:  ( MAKE-EVENT (FTY::DEFPROD-FN ...))
Rules: NIL
Warnings:  Theory
Time:  0.20 seconds (prove: 0.09, print: 0.00, proof tree: 0.00, other: 0.11)
Prover steps counted:  8348
T


ACL2 !>>(DEFINE FRAME-1-INIT
                ((I INTEGERP) (RESULT INTEGERP))
                :RETURNS (FR FRAME-1-P)
                (MAKE-FRAME-1 :I I
                              :RESULT RESULT
                              :LOOP-BREAK NIL)
                /// (FTY::DEFFIXEQUIV FRAME-1-INIT))

Since FRAME-1-INIT is non-recursive, its admission is trivial.  We
observe that the type of FRAME-1-INIT is described by the theorem 
(AND (CONSP (FRAME-1-INIT I RESULT)) (TRUE-LISTP (FRAME-1-INIT I RESULT))).
We used the :type-prescription rule FRAME-1.

Computing the guard conjecture for FRAME-1-INIT....

The guard conjecture for FRAME-1-INIT is trivial to prove, given the
:compound-recognizer rule BOOLEANP-COMPOUND-RECOGNIZER.  FRAME-1-INIT
is compliant with Common Lisp.

Summary
Form:  ( DEFUN FRAME-1-INIT ...)
Rules: ((:COMPOUND-RECOGNIZER BOOLEANP-COMPOUND-RECOGNIZER)
        (:TYPE-PRESCRIPTION FRAME-1))
Time:  0.00 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.00)


ACL2 !>>(DEFTHM FRAME-1-P-OF-FRAME-1-INIT
                (B* ((FR (FRAME-1-INIT I RESULT)))
                    (FRAME-1-P FR))
                :HINTS ((STD::RETURNSPEC-DEFAULT-DEFAULT-HINT 'FRAME-1-INIT
                                                              ID WORLD))
                :RULE-CLASSES :REWRITE)

ACL2 Warning [Non-rec] in ( DEFTHM FRAME-1-P-OF-FRAME-1-INIT ...):
A :REWRITE rule generated from FRAME-1-P-OF-FRAME-1-INIT will be triggered
only by terms containing the function symbol FRAME-1-INIT, which has
a non-recursive definition.  Unless this definition is disabled, this
rule is unlikely ever to be used.


<< Starting proof tree logging >>
#<\<0( DEFTHM FRAME-1-P-OF-FRAME-1-INIT ...)
Q.E.D.#>\>
But we reduce the conjecture to T, by the simple :definition FRAME-1-INIT
and the simple :rewrite rule FRAME-1-P-OF-FRAME-1.

Q.E.D.

The storage of FRAME-1-P-OF-FRAME-1-INIT depends upon the :compound-
recognizer rule CONSP-WHEN-FRAME-1-P and the :type-prescription rule
FRAME-1-P.

Summary
Form:  ( DEFTHM FRAME-1-P-OF-FRAME-1-INIT ...)
Rules: ((:COMPOUND-RECOGNIZER CONSP-WHEN-FRAME-1-P)
        (:DEFINITION FRAME-1-INIT)
        (:REWRITE FRAME-1-P-OF-FRAME-1)
        (:TYPE-PRESCRIPTION FRAME-1-P))
Warnings:  Non-rec
Time:  0.00 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.00)
Prover steps counted:  15
FRAME-1-P-OF-FRAME-1-INIT

Summary
Form:  ( PROGN (DEFTHM FRAME-1-P-OF-FRAME-1-INIT ...) ...)
Rules: NIL
Warnings:  Non-rec
Time:  0.00 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.00)
Prover steps counted:  15


ACL2 !>>(FTY::DEFFIXEQUIV FRAME-1-INIT)

ACL2 Warning [Non-rec] in ( DEFTHM FRAME-1-INIT-OF-IFIX-I ...):  A
:REWRITE rule generated from FRAME-1-INIT-OF-IFIX-I will be triggered
only by terms containing the function symbols FRAME-1-INIT and IFIX,
which have non-recursive definitions.  Unless these definitions are
disabled, this rule is unlikely ever to be used.


ACL2 Warning [Subsume] in ( DEFTHM FRAME-1-INIT-OF-IFIX-I ...):  The
previously added rule FRAME-1-INIT subsumes a newly proposed :REWRITE
rule generated from FRAME-1-INIT-OF-IFIX-I, in the sense that the old
rule rewrites a more general target.  Because the new rule will be
tried first, it may nonetheless find application.


<< Starting proof tree logging >>
#<\<0( DEFTHM FRAME-1-INIT-OF-IFIX-I ...)
Q.E.D.#>\>
But we reduce the conjecture to T, by the simple :definition FRAME-1-INIT
and the simple :rewrite rule FRAME-1-OF-IFIX-I.

Q.E.D.

Summary
Form:  ( DEFTHM FRAME-1-INIT-OF-IFIX-I ...)
Rules: ((:DEFINITION FRAME-1-INIT)
        (:REWRITE FRAME-1-OF-IFIX-I))
Warnings:  Subsume and Non-rec
Time:  0.00 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.00)
Prover steps counted:  28

ACL2 Warning [Non-rec] in ( DEFTHM FRAME-1-INIT-OF-IFIX-RESULT ...):
A :REWRITE rule generated from FRAME-1-INIT-OF-IFIX-RESULT will be
triggered only by terms containing the function symbols FRAME-1-INIT
and IFIX, which have non-recursive definitions.  Unless these definitions
are disabled, this rule is unlikely ever to be used.


ACL2 Warning [Subsume] in ( DEFTHM FRAME-1-INIT-OF-IFIX-RESULT ...):
The previously added rule FRAME-1-INIT subsumes a newly proposed :REWRITE
rule generated from FRAME-1-INIT-OF-IFIX-RESULT, in the sense that
the old rule rewrites a more general target.  Because the new rule
will be tried first, it may nonetheless find application.


<< Starting proof tree logging >>
#<\<0( DEFTHM FRAME-1-INIT-OF-IFIX-RESULT ...)
Q.E.D.#>\>
But we reduce the conjecture to T, by the simple :definition FRAME-1-INIT
and the simple :rewrite rule FRAME-1-OF-IFIX-RESULT.

Q.E.D.

Summary
Form:  ( DEFTHM FRAME-1-INIT-OF-IFIX-RESULT ...)
Rules: ((:DEFINITION FRAME-1-INIT)
        (:REWRITE FRAME-1-OF-IFIX-RESULT))
Warnings:  Subsume and Non-rec
Time:  0.00 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.00)
Prover steps counted:  28
FRAME-1-INIT-INT-EQUIV-CONGRUENCE-ON-RESULT

Summary
Form:  ( PROGN (FTY::DEFFIXEQUIV FRAME-1-INIT) ...)
Rules: NIL
Warnings:  Subsume and Non-rec
Time:  0.02 seconds (prove: 0.02, print: 0.00, proof tree: 0.00, other: 0.00)
Prover steps counted:  130
FRAME-1-INIT


ACL2 !>>(FTY::DEFPROD ENVIR-1
                      ((LOOP-COUNTER-SHIFT INTEGERP)
                       (A INTEGER-LISTP)))
Form:  ( TABLE XDOC ...)
Time:  0.00 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.00)
Form:  ( TABLE STD::DEFAULT-HINTS-TABLE ...)
Time:  0.00 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.00)
Form:  ( TABLE STD::DEFAULT-HINTS-TABLE ...)
Time:  0.00 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.00)
Form:  ( TABLE STD::DEFAULT-HINTS-TABLE ...)
Time:  0.00 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.00)
Form:  ( TABLE STD::DEFAULT-HINTS-TABLE ...)
Time:  0.00 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.00)
Form:  ( DEFTHEORY FTY::DEFTYPES-ORIG-THEORY ...)
Time:  0.00 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.00)
Form:  ( DEFTHEORY FTY::DEFTYPES-TYPE-THEORY ...)
Time:  0.00 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.00)
Form:  ( MAKE-EVENT (CONS ...))
Time:  0.00 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.00)
Form:  ( DEFLABEL FTY::DEFTYPES-BEFORE-TEMP-THMS ...)
Time:  0.00 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.00)
#<\<0( DEFTHM TMP-DEFTYPES-INTEGERP-OF-IFIX ...)
Q.E.D.#>\>Form:  ( DEFTHM TMP-DEFTYPES-INTEGERP-OF-IFIX ...)
Time:  0.00 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.00)
Form:  ( MAKE-EVENT (QUOTE ...))
Time:  0.00 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.00)
#<\<0( DEFTHM TMP-DEFTYPES-IFIX-WHEN-INTEGERP ...)
   1 Goal preprocess
     |  <1 subgoal>
#>\>#<\<0( DEFTHM TMP-DEFTYPES-IFIX-WHEN-INTEGERP ...)
Q.E.D.#>\>Form:  ( DEFTHM TMP-DEFTYPES-IFIX-WHEN-INTEGERP ...)
Time:  0.00 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.00)
Form:  ( MAKE-EVENT (QUOTE ...))
Time:  0.00 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.00)
Form:  ( PROGN (LOCAL ...) ...)
Time:  0.00 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.00)
Form:  ( DEFTHEORY FTY::DEFTYPES-TEMP-THMS ...)
Time:  0.00 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.00)

ACL2 Warning [Theory] in ( IN-THEORY (DISABLE ...)):  The :DEFINITION
rules for the built-in functions DOUBLE-REWRITE, THE-CHECK, CONS-WITH-HINT,
IFF, WORMHOLE-EVAL, MV-LIST, MINUSP, PLUSP, ZEROP, LISTP, SYNP, CASE-SPLIT,
FORCE, /=, =, RETURN-LAST, NULL, ENDP, ATOM, EQL, NOT, IMPLIES and
EQ are disabled by the theory expression (DISABLE FTY::DEFTYPES-ORIG-THEORY),
but some expansions of their calls may still occur.  See :DOC theories-
and-primitives.


ACL2 Warning [Theory] in ( IN-THEORY (DISABLE ...)):  The :EXECUTABLE-
COUNTERPART rules for the built-in functions NOT, SYMBOLP, 
SYMBOL-PACKAGE-NAME, SYMBOL-NAME, STRINGP, REALPART, RATIONALP, PKG-WITNESS,
PKG-IMPORTS, NUMERATOR, INTERN-IN-PACKAGE-OF-SYMBOL, INTEGERP, IMAGPART,
IF, EQUAL, DENOMINATOR, CONSP, CONS, COERCE, COMPLEX-RATIONALP, COMPLEX,
CODE-CHAR, CHARACTERP, CHAR-CODE, CDR, CAR, <, UNARY-/, UNARY--, BINARY-+,
BINARY-* and ACL2-NUMBERP are disabled by the theory expression 
(DISABLE FTY::DEFTYPES-ORIG-THEORY), but some evaluations of their
calls may still occur.  See :DOC theories-and-primitives.

Form:  ( IN-THEORY (DISABLE ...))
Time:  0.02 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.02)
Form:  ( IN-THEORY (ENABLE ...))
Time:  0.00 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.00)
Form:  ( IN-THEORY (ENABLE* ...))
Time:  0.00 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.00)
Form:  ( TABLE DEFINE ...)
Time:  0.00 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.00)
#<\<0( DEFUN ENVIR-1-P ...)
   3 Goal preprocess
     |  <3 subgoals>
#>\>#<\<0( DEFUN ENVIR-1-P ...)
   3 Goal preprocess
     |  <2 more subgoals>
#>\>#<\<0( DEFUN ENVIR-1-P ...)
   3 Goal preprocess
     |  <1 more subgoal>
#>\>#<\<0( DEFUN ENVIR-1-P ...)
Q.E.D.#>\>Form:  ( DEFUN ENVIR-1-P ...)
Time:  0.00 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.00)
#<\<0( DEFTHM CONSP-WHEN-ENVIR-1-P ...)
   1 Goal preprocess
     |  <1 subgoal>
#>\>#<\<0( DEFTHM CONSP-WHEN-ENVIR-1-P ...)
Q.E.D.#>\>Form:  ( DEFTHM CONSP-WHEN-ENVIR-1-P ...)
Time:  0.00 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.00)
Form:  ( MAKE-EVENT (QUOTE ...))
Time:  0.00 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.00)
Form:  ( PROGN (MAKE-EVENT ...) ...)
Time:  0.00 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.00)
Form:  ( IN-THEORY (DISABLE ...))
Time:  0.00 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.00)
Form:  ( DEFMACRO ENVIR-1-FIX ...)
Time:  0.00 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.00)
Form:  ( DEFUN ENVIR-1-FIX$INLINE ...)
Time:  0.00 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.00)
#<\<0( DEFTHM ENVIR-1-P-OF-ENVIR-1-FIX ...)
   1 Goal preprocess
     |  <1 subgoal>
#>\>#<\<0( DEFTHM ENVIR-1-P-OF-ENVIR-1-FIX ...)
   1 Goal preprocess
   1 |  Goal' simp
     |  |  <1 subgoal>
#>\>#<\<0( DEFTHM ENVIR-1-P-OF-ENVIR-1-FIX ...)
   1 Goal preprocess
   1 |  Goal' simp
   1 |  |  Goal'' simp
     |  |  |  <1 subgoal>
#>\>#<\<0( DEFTHM ENVIR-1-P-OF-ENVIR-1-FIX ...)
Q.E.D.#>\>Form:  ( DEFTHM ENVIR-1-P-OF-ENVIR-1-FIX ...)
Time:  0.00 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.00)
Form:  ( PROGN (DEFTHM ENVIR-1-P-OF-ENVIR-1-FIX ...) ...)
Time:  0.00 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.00)
Form:  ( IN-THEORY (DISABLE ...))
Time:  0.00 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.00)
#<\<0( DEFTHM ENVIR-1-FIX-WHEN-ENVIR-1-P ...)
   1 Goal preprocess
     |  <1 subgoal>
#>\>#<\<0( DEFTHM ENVIR-1-FIX-WHEN-ENVIR-1-P ...)
   1 Goal simp
     |  <1 subgoal>
#>\>#<\<0( DEFTHM ENVIR-1-FIX-WHEN-ENVIR-1-P ...)
   1 Goal simp
   1 |  Goal' preprocess
     |  |  <1 subgoal>
#>\>#<\<0( DEFTHM ENVIR-1-FIX-WHEN-ENVIR-1-P ...)
Q.E.D.#>\>Form:  ( DEFTHM ENVIR-1-FIX-WHEN-ENVIR-1-P ...)
Time:  0.02 seconds (prove: 0.02, print: 0.00, proof tree: 0.00, other: 0.00)
#<\<0( VERIFY-GUARDS ENVIR-1-FIX$INLINE ...)
   1 Goal preprocess
     |  <1 subgoal>
#>\>#<\<0( VERIFY-GUARDS ENVIR-1-FIX$INLINE ...)
   1 Goal preprocess
   1 |  Goal' simp
     |  |  <1 subgoal>
#>\>#<\<0( VERIFY-GUARDS ENVIR-1-FIX$INLINE ...)
   1 Goal preprocess
   1 |  Goal' simp
   1 |  |  Goal'' preprocess
     |  |  |  <1 subgoal>
#>\>#<\<0( VERIFY-GUARDS ENVIR-1-FIX$INLINE ...)
Q.E.D.#>\>Form:  ( VERIFY-GUARDS ENVIR-1-FIX$INLINE ...)
Time:  0.00 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.00)
Form:  ( MAKE-EVENT (LET* ...) ...)
Time:  0.00 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.00)
#<\<0( DEFTHM FTY::TMP-DEFFIXTYPE-IDEMPOTENT ...)
Q.E.D.#>\>Form:  ( DEFTHM FTY::TMP-DEFFIXTYPE-IDEMPOTENT ...)
Time:  0.00 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.00)
Form:  ( ENCAPSULATE NIL (FTY::DEFFIXTYPE ... T) ...)
Time:  0.00 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.00)
Form:  ( IN-THEORY (ENABLE ...))
Time:  0.00 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.00)
Form:  ( PROGN (LOCAL ...) ...)
Time:  0.03 seconds (prove: 0.02, print: 0.00, proof tree: 0.00, other: 0.02)
Form:  ( IN-THEORY (ENABLE ...))
Time:  0.00 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.00)
Form:  ( IN-THEORY (DISABLE ...))
Time:  0.00 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.00)
Form:  ( DEFMACRO ENVIR-1->LOOP-COUNTER-SHIFT ...)
Time:  0.00 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.00)
#<\<0( DEFUN ENVIR-1->LOOP-COUNTER-SHIFT$INLINE ...)
   1 Goal preprocess
     |  <1 subgoal>
#>\>#<\<0( DEFUN ENVIR-1->LOOP-COUNTER-SHIFT$INLINE ...)
Q.E.D.#>\>Form:  ( DEFUN ENVIR-1->LOOP-COUNTER-SHIFT$INLINE ...)
Time:  0.00 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.00)
#<\<0( DEFTHM INTEGERP-OF-ENVIR-1->LOOP-COUNTER-SHIFT ...)
Q.E.D.#>\>Form:  ( DEFTHM INTEGERP-OF-ENVIR-1->LOOP-COUNTER-SHIFT ...)
Time:  0.00 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.00)
Form:  ( PROGN (DEFTHM INTEGERP-OF-ENVIR-1->LOOP-COUNTER-SHIFT ...)
...)
Time:  0.00 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.00)
#<\<0( DEFTHM ENVIR-1->LOOP-COUNTER-SHIFT$INLINE-OF-ENVIR-1-FIX-X ...)
   1 Goal preprocess
     |  <1 subgoal>
#>\>#<\<0( DEFTHM ENVIR-1->LOOP-COUNTER-SHIFT$INLINE-OF-ENVIR-1-FIX-X ...)
Q.E.D.#>\>Form:  ( DEFTHM ENVIR-1->LOOP-COUNTER-SHIFT$INLINE-OF-ENVIR-1-FIX-X
...)
Time:  0.00 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.00)
Form:  ( PROGN (FTY::DEFFIXEQUIV ENVIR-1->LOOP-COUNTER-SHIFT ...) ...)
Time:  0.00 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.00)
Form:  ( IN-THEORY (ENABLE ...))
Time:  0.00 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.00)
Form:  ( DEFMACRO ENVIR-1->A ...)
Time:  0.00 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.00)
#<\<0( DEFUN ENVIR-1->A$INLINE ...)
   1 Goal preprocess
     |  <1 subgoal>
#>\>#<\<0( DEFUN ENVIR-1->A$INLINE ...)
Q.E.D.#>\>Form:  ( DEFUN ENVIR-1->A$INLINE ...)
Time:  0.02 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.02)
#<\<0( DEFTHM INTEGER-LISTP-OF-ENVIR-1->A ...)
Q.E.D.#>\>Form:  ( DEFTHM INTEGER-LISTP-OF-ENVIR-1->A ...)
Time:  0.00 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.00)
Form:  ( PROGN (DEFTHM INTEGER-LISTP-OF-ENVIR-1->A ...) ...)
Time:  0.00 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.00)
#<\<0( DEFTHM ENVIR-1->A$INLINE-OF-ENVIR-1-FIX-X ...)
   1 Goal preprocess
     |  <1 subgoal>
#>\>#<\<0( DEFTHM ENVIR-1->A$INLINE-OF-ENVIR-1-FIX-X ...)
Q.E.D.#>\>Form:  ( DEFTHM ENVIR-1->A$INLINE-OF-ENVIR-1-FIX-X ...)
Time:  0.00 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.00)
Form:  ( PROGN (FTY::DEFFIXEQUIV ENVIR-1->A ...) ...)
Time:  0.00 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.00)
Form:  ( IN-THEORY (ENABLE ...))
Time:  0.00 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.00)
#<\<0( DEFUN ENVIR-1 ...)
   1 Goal preprocess
     |  <1 subgoal>
#>\>#<\<0( DEFUN ENVIR-1 ...)
Q.E.D.#>\>Form:  ( DEFUN ENVIR-1 ...)
Time:  0.00 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.00)
#<\<0( DEFTHM ENVIR-1-P-OF-ENVIR-1 ...)
   2 Goal preprocess
     |  <2 subgoals>
#>\>#<\<0( DEFTHM ENVIR-1-P-OF-ENVIR-1 ...)
   2 Goal preprocess
     |  <1 more subgoal>
#>\>#<\<0( DEFTHM ENVIR-1-P-OF-ENVIR-1 ...)
Q.E.D.#>\>Form:  ( DEFTHM ENVIR-1-P-OF-ENVIR-1 ...)
Time:  0.02 seconds (prove: 0.02, print: 0.00, proof tree: 0.00, other: 0.00)
Form:  ( PROGN (DEFTHM ENVIR-1-P-OF-ENVIR-1 ...) ...)
Time:  0.02 seconds (prove: 0.02, print: 0.00, proof tree: 0.00, other: 0.00)
#<\<0( DEFTHM ENVIR-1->LOOP-COUNTER-SHIFT-OF-ENVIR-1 ...)
   1 Goal preprocess
     |  <1 subgoal>
#>\>#<\<0( DEFTHM ENVIR-1->LOOP-COUNTER-SHIFT-OF-ENVIR-1 ...)
   1 Goal preprocess
   1 |  Goal' preprocess
     |  |  <1 subgoal>
#>\>#<\<0( DEFTHM ENVIR-1->LOOP-COUNTER-SHIFT-OF-ENVIR-1 ...)
Q.E.D.#>\>Form:  ( DEFTHM ENVIR-1->LOOP-COUNTER-SHIFT-OF-ENVIR-1 ...)
Time:  0.00 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.00)
#<\<0( DEFTHM ENVIR-1->A-OF-ENVIR-1 ...)
   1 Goal preprocess
     |  <1 subgoal>
#>\>#<\<0( DEFTHM ENVIR-1->A-OF-ENVIR-1 ...)
   1 Goal preprocess
   1 |  Goal' preprocess
     |  |  <1 subgoal>
#>\>#<\<0( DEFTHM ENVIR-1->A-OF-ENVIR-1 ...)
Q.E.D.#>\>Form:  ( DEFTHM ENVIR-1->A-OF-ENVIR-1 ...)
Time:  0.02 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.02)
#<\<0( DEFTHM ENVIR-1-OF-FIELDS ...)
   1 Goal preprocess
     |  <1 subgoal>
#>\>#<\<0( DEFTHM ENVIR-1-OF-FIELDS ...)
Q.E.D.#>\>Form:  ( DEFTHM ENVIR-1-OF-FIELDS ...)
Time:  0.00 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.00)
#<\<0( DEFTHM ENVIR-1-FIX-WHEN-ENVIR-1 ...)
   1 Goal preprocess
     |  <1 subgoal>
#>\>#<\<0( DEFTHM ENVIR-1-FIX-WHEN-ENVIR-1 ...)
Q.E.D.#>\>Form:  ( DEFTHM ENVIR-1-FIX-WHEN-ENVIR-1 ...)
Time:  0.00 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.00)
#<\<0( DEFTHM EQUAL-OF-ENVIR-1 ...)
   1 Goal top-level-hints
     |  <1 subgoal>
#>\>#<\<0( DEFTHM EQUAL-OF-ENVIR-1 ...)
   1 Goal top-level-hints
   4 |  Goal' simp
     |  |  <4 subgoals>
#>\>#<\<0( DEFTHM EQUAL-OF-ENVIR-1 ...)
   1 Goal top-level-hints
   4 |  Goal' simp
   1 |  |  Subgoal 4 simp
     |  |  |  <1 subgoal>
     |  |  <3 more subgoals>
#>\>#<\<0( DEFTHM EQUAL-OF-ENVIR-1 ...)
   1 Goal top-level-hints
   4 |  Goal' simp
   1 |  |  Subgoal 4 simp
   1 |  |  |  Subgoal 4' preprocess
     |  |  |  |  <1 subgoal>
     |  |  <3 more subgoals>
#>\>#<\<0( DEFTHM EQUAL-OF-ENVIR-1 ...)
   1 Goal top-level-hints
   4 |  Goal' simp
   1 |  |  Subgoal 4 simp
   1 |  |  |  Subgoal 4' preprocess
   1 |  |  |  |  Subgoal 4'' simp
     |  |  |  |  |  <1 subgoal>
     |  |  <3 more subgoals>
#>\>#<\<0( DEFTHM EQUAL-OF-ENVIR-1 ...)
   1 Goal top-level-hints
   4 |  Goal' simp
     |  |  <3 more subgoals>
#>\>#<\<0( DEFTHM EQUAL-OF-ENVIR-1 ...)
   1 Goal top-level-hints
   4 |  Goal' simp
     |  |  <2 more subgoals>
#>\>#<\<0( DEFTHM EQUAL-OF-ENVIR-1 ...)
   1 Goal top-level-hints
   4 |  Goal' simp
     |  |  <1 more subgoal>
#>\>#<\<0( DEFTHM EQUAL-OF-ENVIR-1 ...)
Q.E.D.#>\>Form:  ( DEFTHM EQUAL-OF-ENVIR-1 ...)
Time:  0.03 seconds (prove: 0.03, print: 0.00, proof tree: 0.00, other: 0.00)
#<\<0( DEFTHM ENVIR-1-OF-IFIX-LOOP-COUNTER-SHIFT ...)
   1 Goal preprocess
     |  <1 subgoal>
#>\>#<\<0( DEFTHM ENVIR-1-OF-IFIX-LOOP-COUNTER-SHIFT ...)
Q.E.D.#>\>Form:  ( DEFTHM ENVIR-1-OF-IFIX-LOOP-COUNTER-SHIFT ...)
Time:  0.00 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.00)
#<\<0( DEFTHM ENVIR-1-OF-INTEGER-LIST-FIX-A ...)
   1 Goal preprocess
     |  <1 subgoal>
#>\>#<\<0( DEFTHM ENVIR-1-OF-INTEGER-LIST-FIX-A ...)
Q.E.D.#>\>Form:  ( DEFTHM ENVIR-1-OF-INTEGER-LIST-FIX-A ...)
Time:  0.00 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.00)
Form:  ( DEFMACRO PATBIND-ENVIR-1 ...)
Time:  0.00 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.00)
Form:  ( TABLE B*-BINDER-TABLE ...)
Time:  0.00 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.00)
Form:  ( PROGN (DEFXDOC PATBIND-ENVIR-1 ...) ...)
Time:  0.00 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.00)
Form:  ( DEFMACRO MAKE-ENVIR-1 ...)
Time:  0.00 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.00)
Form:  ( DEFMACRO CHANGE-ENVIR-1 ...)
Time:  0.00 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.00)
Form:  ( PROGN (DEFTHM ENVIR-1->LOOP-COUNTER-SHIFT-OF-ENVIR-1 ...)
...)
Time:  0.05 seconds (prove: 0.03, print: 0.00, proof tree: 0.00, other: 0.02)
Form:  ( IN-THEORY (ENABLE ...))
Time:  0.00 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.00)
#<\<0( DEFTHM ENVIR-1-FIX-REDEF ...)
Q.E.D.#>\>Form:  ( DEFTHM ENVIR-1-FIX-REDEF ...)
Time:  0.00 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.00)
Form:  ( IN-THEORY (DISABLE ...))
Time:  0.00 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.00)
Form:  ( IN-THEORY (ENABLE ...))
Time:  0.02 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.02)
Form:  ( TABLE FTY::FLEXTYPES-TABLE ...)
Time:  0.00 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.00)
Form:  ( TABLE XDOC ...)
Time:  0.00 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.00)
Form:  ( PROGN (DEFXDOC ENVIR-1 ...) ...)
Time:  0.00 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.00)
Form:  ( MAKE-EVENT (B* ...))
Time:  0.00 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.00)
Form:  ( TABLE XDOC ...)
Time:  0.00 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.00)
Form:  ( TABLE XDOC ...)
Time:  0.00 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.00)
Form:  ( PROGN (DEFXDOC ENVIR-1 ...) ...)
Time:  0.00 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.00)
Form:  ( MAKE-EVENT (B* ...))
Time:  0.00 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.00)
Form:  ( PROGN (TABLE XDOC ...) ...)
Time:  0.00 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.00)
Form:  ( MAKE-EVENT (FTY::FLEXTYPES-FINAL-XDOC-FN ...))
Time:  0.00 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.00)
Form:  ( PROGN (LOCAL ...) ...)
Time:  0.16 seconds (prove: 0.06, print: 0.00, proof tree: 0.00, other: 0.09)
Form:  ( ENCAPSULATE NIL (WITH-OUTPUT :SUMMARY ...) ...)
Time:  0.17 seconds (prove: 0.06, print: 0.00, proof tree: 0.00, other: 0.11)

Summary
Form:  ( MAKE-EVENT (FTY::DEFPROD-FN ...))
Rules: NIL
Warnings:  Theory
Time:  0.17 seconds (prove: 0.06, print: 0.00, proof tree: 0.00, other: 0.11)
Prover steps counted:  5192
T


ACL2 !>>(DEFINE ENVIR-1-INIT
                ((LOOP-COUNTER-SHIFT INTEGERP)
                 (A INTEGER-LISTP))
                :RETURNS (ENV ENVIR-1-P)
                (MAKE-ENVIR-1 :LOOP-COUNTER-SHIFT LOOP-COUNTER-SHIFT
                              :A A)
                /// (FTY::DEFFIXEQUIV ENVIR-1-INIT))

Since ENVIR-1-INIT is non-recursive, its admission is trivial.  We
observe that the type of ENVIR-1-INIT is described by the theorem 
(AND (CONSP (ENVIR-1-INIT LOOP-COUNTER-SHIFT A))
     (TRUE-LISTP (ENVIR-1-INIT LOOP-COUNTER-SHIFT A))).
We used the :type-prescription rule ENVIR-1.

Computing the guard conjecture for ENVIR-1-INIT....

The guard conjecture for ENVIR-1-INIT is trivial to prove.  ENVIR-1-INIT
is compliant with Common Lisp.

Summary
Form:  ( DEFUN ENVIR-1-INIT ...)
Rules: ((:TYPE-PRESCRIPTION ENVIR-1))
Time:  0.00 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.00)


ACL2 !>>(DEFTHM ENVIR-1-P-OF-ENVIR-1-INIT
                (B* ((ENV (ENVIR-1-INIT LOOP-COUNTER-SHIFT A)))
                    (ENVIR-1-P ENV))
                :HINTS ((STD::RETURNSPEC-DEFAULT-DEFAULT-HINT 'ENVIR-1-INIT
                                                              ID WORLD))
                :RULE-CLASSES :REWRITE)

ACL2 Warning [Non-rec] in ( DEFTHM ENVIR-1-P-OF-ENVIR-1-INIT ...):
A :REWRITE rule generated from ENVIR-1-P-OF-ENVIR-1-INIT will be triggered
only by terms containing the function symbol ENVIR-1-INIT, which has
a non-recursive definition.  Unless this definition is disabled, this
rule is unlikely ever to be used.


<< Starting proof tree logging >>
#<\<0( DEFTHM ENVIR-1-P-OF-ENVIR-1-INIT ...)
Q.E.D.#>\>
But we reduce the conjecture to T, by the simple :definition ENVIR-1-INIT
and the simple :rewrite rule ENVIR-1-P-OF-ENVIR-1.

Q.E.D.

The storage of ENVIR-1-P-OF-ENVIR-1-INIT depends upon the :compound-
recognizer rule CONSP-WHEN-ENVIR-1-P and the :type-prescription rule
ENVIR-1-P.

Summary
Form:  ( DEFTHM ENVIR-1-P-OF-ENVIR-1-INIT ...)
Rules: ((:COMPOUND-RECOGNIZER CONSP-WHEN-ENVIR-1-P)
        (:DEFINITION ENVIR-1-INIT)
        (:REWRITE ENVIR-1-P-OF-ENVIR-1)
        (:TYPE-PRESCRIPTION ENVIR-1-P))
Warnings:  Non-rec
Time:  0.00 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.00)
Prover steps counted:  14
ENVIR-1-P-OF-ENVIR-1-INIT

Summary
Form:  ( PROGN (DEFTHM ENVIR-1-P-OF-ENVIR-1-INIT ...) ...)
Rules: NIL
Warnings:  Non-rec
Time:  0.00 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.00)
Prover steps counted:  14


ACL2 !>>(FTY::DEFFIXEQUIV ENVIR-1-INIT)

ACL2 Warning [Non-rec] in ( DEFTHM ENVIR-1-INIT-OF-IFIX-LOOP-COUNTER-SHIFT
...):  A :REWRITE rule generated from 
ENVIR-1-INIT-OF-IFIX-LOOP-COUNTER-SHIFT will be triggered only by terms
containing the function symbols ENVIR-1-INIT and IFIX, which have non-
recursive definitions.  Unless these definitions are disabled, this
rule is unlikely ever to be used.


ACL2 Warning [Subsume] in ( DEFTHM ENVIR-1-INIT-OF-IFIX-LOOP-COUNTER-SHIFT
...):  The previously added rule ENVIR-1-INIT subsumes a newly proposed
:REWRITE rule generated from ENVIR-1-INIT-OF-IFIX-LOOP-COUNTER-SHIFT,
in the sense that the old rule rewrites a more general target.  Because
the new rule will be tried first, it may nonetheless find application.


<< Starting proof tree logging >>
#<\<0( DEFTHM ENVIR-1-INIT-OF-IFIX-LOOP-COUNTER-SHIFT ...)
Q.E.D.#>\>
But we reduce the conjecture to T, by the simple :definition ENVIR-1-INIT
and the simple :rewrite rule ENVIR-1-OF-IFIX-LOOP-COUNTER-SHIFT.

Q.E.D.

Summary
Form:  ( DEFTHM ENVIR-1-INIT-OF-IFIX-LOOP-COUNTER-SHIFT ...)
Rules: ((:DEFINITION ENVIR-1-INIT)
        (:REWRITE ENVIR-1-OF-IFIX-LOOP-COUNTER-SHIFT))
Warnings:  Subsume and Non-rec
Time:  0.00 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.00)
Prover steps counted:  25

ACL2 Warning [Non-rec] in ( DEFTHM ENVIR-1-INIT-OF-INTEGER-LIST-FIX-A
...):  A :REWRITE rule generated from ENVIR-1-INIT-OF-INTEGER-LIST-FIX-A
will be triggered only by terms containing the function symbol ENVIR-1-INIT,
which has a non-recursive definition.  Unless this definition is disabled,
this rule is unlikely ever to be used.


ACL2 Warning [Subsume] in ( DEFTHM ENVIR-1-INIT-OF-INTEGER-LIST-FIX-A
...):  The previously added rule ENVIR-1-INIT subsumes a newly proposed
:REWRITE rule generated from ENVIR-1-INIT-OF-INTEGER-LIST-FIX-A, in
the sense that the old rule rewrites a more general target.  Because
the new rule will be tried first, it may nonetheless find application.


<< Starting proof tree logging >>
#<\<0( DEFTHM ENVIR-1-INIT-OF-INTEGER-LIST-FIX-A ...)
Q.E.D.#>\>
But we reduce the conjecture to T, by the simple :definition ENVIR-1-INIT
and the simple :rewrite rule ENVIR-1-OF-INTEGER-LIST-FIX-A.

Q.E.D.

Summary
Form:  ( DEFTHM ENVIR-1-INIT-OF-INTEGER-LIST-FIX-A ...)
Rules: ((:DEFINITION ENVIR-1-INIT)
        (:REWRITE ENVIR-1-OF-INTEGER-LIST-FIX-A))
Warnings:  Subsume and Non-rec
Time:  0.00 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.00)
Prover steps counted:  25
ENVIR-1-INIT-INTEGER-LIST-EQUIV-CONGRUENCE-ON-A

Summary
Form:  ( PROGN (FTY::DEFFIXEQUIV ENVIR-1-INIT) ...)
Rules: NIL
Warnings:  Subsume and Non-rec
Time:  0.02 seconds (prove: 0.02, print: 0.00, proof tree: 0.00, other: 0.00)
Prover steps counted:  124
ENVIR-1-INIT


ACL2 !>>(DEFINE
         REP-1
         ((ITERATION NATP)
          (ENV-1 ENVIR-1-P)
          (FR-1 FRAME-1-P))
         :MEASURE (NFIX ITERATION)
         :VERIFY-GUARDS
         NIL :RETURNS (UPD-FR-1 FRAME-1-P)
         (B*
          ((ITERATION (NFIX ITERATION))
           (ENV-1 (ENVIR-1-FIX ENV-1))
           (FR-1 (FRAME-1-FIX FR-1))
           ((WHEN (ZP ITERATION)) FR-1)
           (FR-1 (REP-1 (- ITERATION 1) ENV-1 FR-1))
           ((WHEN (FRAME-1->LOOP-BREAK FR-1)) FR-1)
           (FR-1
              (IF (NOT (EQUAL (NTH (- (+ (- ITERATION 1)
                                         (ENVIR-1->LOOP-COUNTER-SHIFT ENV-1))
                                      1)
                                   (ENVIR-1->A ENV-1))
                              (NTH (+ (- ITERATION 1)
                                      (ENVIR-1->LOOP-COUNTER-SHIFT ENV-1))
                                   (ENVIR-1->A ENV-1))))
                  (B* ((FR-1 (CHANGE-FRAME-1 FR-1 :RESULT 0))
                       (FR-1 (CHANGE-FRAME-1 FR-1 :LOOP-BREAK T))
                       ((WHEN T) FR-1)
                       ((WHEN (FRAME-1->LOOP-BREAK FR-1))
                        FR-1))
                      FR-1)
                  FR-1))
           ((WHEN (FRAME-1->LOOP-BREAK FR-1)) FR-1)
           ((WHEN (FRAME-1->LOOP-BREAK FR-1)) FR-1)
           (FR-1 (CHANGE-FRAME-1 FR-1
                                 :I (+ (FRAME-1->I FR-1) 1))))
          FR-1))

For the admission of REP-1 we will use the relation O< (which is known
to be well-founded on the domain recognized by O-P) and the measure
(NFIX ITERATION).  The non-trivial part of the measure conjecture is

Goal
(AND (O-P (NFIX ITERATION))
     (IMPLIES (NOT (ZP (NFIX ITERATION)))
              (O< (NFIX (+ -1 (NFIX ITERATION)))
                  (NFIX ITERATION)))).

<< Starting proof tree logging >>
#<\<0( DEFUN REP-1 ...)
   1 Goal preprocess
     |  <1 subgoal>
#>\>
By the :congruence rule NAT-EQUIV-IMPLIES-EQUAL-ZP-1, the :executable-
counterpart of TAU-SYSTEM and the simple :rewrite rule NFIX-UNDER-NAT-EQUIV
we reduce the conjecture to

Goal'
(IMPLIES (NOT (ZP ITERATION))
         (O< (NFIX (+ -1 (NFIX ITERATION)))
             (NFIX ITERATION))).
#<\<0( DEFUN REP-1 ...)
   1 Goal preprocess
   1 |  Goal' simp
     |  |  <1 subgoal>
#>\>
This simplifies, using the :compound-recognizer rule ZP-COMPOUND-RECOGNIZER,
the :definitions NFIX, O-FINP and O< and primitive type reasoning,
to

Goal''
(IMPLIES (NOT (ZP ITERATION))
         (< (+ -1 ITERATION) ITERATION)).
#<\<0( DEFUN REP-1 ...)
Q.E.D.#>\>
But we reduce the conjecture to T, by the :executable-counterpart of
TAU-SYSTEM.

Q.E.D.

That completes the proof of the measure theorem for REP-1.  Thus, we
admit this function under the principle of definition.  We observe
that the type of REP-1 is described by the theorem 
(AND (CONSP (REP-1 ITERATION ENV-1 FR-1))
     (TRUE-LISTP (REP-1 ITERATION ENV-1 FR-1))).
We used the :type-prescription rules FRAME-1 and FRAME-1-FIX$INLINE.

Summary
Form:  ( DEFUN REP-1 ...)
Rules: ((:COMPOUND-RECOGNIZER ZP-COMPOUND-RECOGNIZER)
        (:CONGRUENCE NAT-EQUIV-IMPLIES-EQUAL-ZP-1)
        (:DEFINITION NFIX)
        (:DEFINITION O-FINP)
        (:DEFINITION O<)
        (:EXECUTABLE-COUNTERPART TAU-SYSTEM)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:REWRITE NFIX-UNDER-NAT-EQUIV)
        (:TYPE-PRESCRIPTION FRAME-1)
        (:TYPE-PRESCRIPTION FRAME-1-FIX$INLINE))
Time:  0.00 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.00)
Prover steps counted:  91


ACL2 !>>(DEFTHM FRAME-1-P-OF-REP-1
                (B* ((UPD-FR-1 (REP-1 ITERATION ENV-1 FR-1)))
                    (FRAME-1-P UPD-FR-1))
                :HINTS ((STD::RETURNSPEC-DEFAULT-DEFAULT-HINT 'REP-1
                                                              ID WORLD))
                :RULE-CLASSES :REWRITE)

<< Starting proof tree logging >>

[Note:  A hint was supplied for our processing of the goal above. 
Thanks!]
#<\<0( DEFTHM FRAME-1-P-OF-REP-1 ...)
c  0 Goal PUSH *1
#>\>
Name the formula above *1.

We have been told to use induction.  One induction scheme is suggested
by the induction hint.  

We will induct according to a scheme suggested by 
(REP-1 ITERATION ENV-1 FR-1).  This suggestion was produced using the
:induction rule REP-1.  If we let (:P ENV-1 FR-1 ITERATION) denote
*1 above then the induction scheme we'll use is
(AND
 (IMPLIES
  (AND
   (NOT (ZP (NFIX ITERATION)))
   (NOT (FRAME-1->LOOP-BREAK (REP-1 (+ -1 (NFIX ITERATION))
                                    (ENVIR-1-FIX ENV-1)
                                    (FRAME-1-FIX FR-1))))
   (NOT
    (FRAME-1->LOOP-BREAK
     (IF
       (NOT (EQUAL (NTH (+ -1 (+ -1 (NFIX ITERATION))
                           (ENVIR-1->LOOP-COUNTER-SHIFT (ENVIR-1-FIX ENV-1)))
                        (ENVIR-1->A (ENVIR-1-FIX ENV-1)))
                   (NTH (+ (+ -1 (NFIX ITERATION))
                           (ENVIR-1->LOOP-COUNTER-SHIFT (ENVIR-1-FIX ENV-1)))
                        (ENVIR-1->A (ENVIR-1-FIX ENV-1)))))
       (LET* ((FR-1 (LET ((CHANGE-FRAME-1 (REP-1 (+ -1 (NFIX ITERATION))
                                                 (ENVIR-1-FIX ENV-1)
                                                 (FRAME-1-FIX FR-1)))
                          (FRAME-1->RESULT 0))
                         (FRAME-1 (FRAME-1->I CHANGE-FRAME-1)
                                  FRAME-1->RESULT
                                  (FRAME-1->LOOP-BREAK CHANGE-FRAME-1))))
              (FR-1 (LET ((CHANGE-FRAME-1 FR-1)
                          (FRAME-1->LOOP-BREAK T))
                         (FRAME-1 (FRAME-1->I CHANGE-FRAME-1)
                                  (FRAME-1->RESULT CHANGE-FRAME-1)
                                  FRAME-1->LOOP-BREAK))))
             (COND (T FR-1)
                   ((FRAME-1->LOOP-BREAK FR-1) FR-1)
                   (T FR-1)))
       (REP-1 (+ -1 (NFIX ITERATION))
              (ENVIR-1-FIX ENV-1)
              (FRAME-1-FIX FR-1)))))
   (NOT
    (FRAME-1->LOOP-BREAK
     (IF
       (NOT (EQUAL (NTH (+ -1 (+ -1 (NFIX ITERATION))
                           (ENVIR-1->LOOP-COUNTER-SHIFT (ENVIR-1-FIX ENV-1)))
                        (ENVIR-1->A (ENVIR-1-FIX ENV-1)))
                   (NTH (+ (+ -1 (NFIX ITERATION))
                           (ENVIR-1->LOOP-COUNTER-SHIFT (ENVIR-1-FIX ENV-1)))
                        (ENVIR-1->A (ENVIR-1-FIX ENV-1)))))
       (LET* ((FR-1 (LET ((CHANGE-FRAME-1 (REP-1 (+ -1 (NFIX ITERATION))
                                                 (ENVIR-1-FIX ENV-1)
                                                 (FRAME-1-FIX FR-1)))
                          (FRAME-1->RESULT 0))
                         (FRAME-1 (FRAME-1->I CHANGE-FRAME-1)
                                  FRAME-1->RESULT
                                  (FRAME-1->LOOP-BREAK CHANGE-FRAME-1))))
              (FR-1 (LET ((CHANGE-FRAME-1 FR-1)
                          (FRAME-1->LOOP-BREAK T))
                         (FRAME-1 (FRAME-1->I CHANGE-FRAME-1)
                                  (FRAME-1->RESULT CHANGE-FRAME-1)
                                  FRAME-1->LOOP-BREAK))))
             (COND (T FR-1)
                   ((FRAME-1->LOOP-BREAK FR-1) FR-1)
                   (T FR-1)))
       (REP-1 (+ -1 (NFIX ITERATION))
              (ENVIR-1-FIX ENV-1)
              (FRAME-1-FIX FR-1)))))
   (:P (ENVIR-1-FIX ENV-1)
       (FRAME-1-FIX FR-1)
       (+ -1 (NFIX ITERATION))))
  (:P ENV-1 FR-1 ITERATION))
 (IMPLIES
  (AND
   (NOT (ZP (NFIX ITERATION)))
   (NOT (FRAME-1->LOOP-BREAK (REP-1 (+ -1 (NFIX ITERATION))
                                    (ENVIR-1-FIX ENV-1)
                                    (FRAME-1-FIX FR-1))))
   (FRAME-1->LOOP-BREAK
    (IF
       (NOT (EQUAL (NTH (+ -1 (+ -1 (NFIX ITERATION))
                           (ENVIR-1->LOOP-COUNTER-SHIFT (ENVIR-1-FIX ENV-1)))
                        (ENVIR-1->A (ENVIR-1-FIX ENV-1)))
                   (NTH (+ (+ -1 (NFIX ITERATION))
                           (ENVIR-1->LOOP-COUNTER-SHIFT (ENVIR-1-FIX ENV-1)))
                        (ENVIR-1->A (ENVIR-1-FIX ENV-1)))))
       (LET* ((FR-1 (LET ((CHANGE-FRAME-1 (REP-1 (+ -1 (NFIX ITERATION))
                                                 (ENVIR-1-FIX ENV-1)
                                                 (FRAME-1-FIX FR-1)))
                          (FRAME-1->RESULT 0))
                         (FRAME-1 (FRAME-1->I CHANGE-FRAME-1)
                                  FRAME-1->RESULT
                                  (FRAME-1->LOOP-BREAK CHANGE-FRAME-1))))
              (FR-1 (LET ((CHANGE-FRAME-1 FR-1)
                          (FRAME-1->LOOP-BREAK T))
                         (FRAME-1 (FRAME-1->I CHANGE-FRAME-1)
                                  (FRAME-1->RESULT CHANGE-FRAME-1)
                                  FRAME-1->LOOP-BREAK))))
             (COND (T FR-1)
                   ((FRAME-1->LOOP-BREAK FR-1) FR-1)
                   (T FR-1)))
       (REP-1 (+ -1 (NFIX ITERATION))
              (ENVIR-1-FIX ENV-1)
              (FRAME-1-FIX FR-1))))
   (:P (ENVIR-1-FIX ENV-1)
       (FRAME-1-FIX FR-1)
       (+ -1 (NFIX ITERATION))))
  (:P ENV-1 FR-1 ITERATION))
 (IMPLIES (AND (NOT (ZP (NFIX ITERATION)))
               (FRAME-1->LOOP-BREAK (REP-1 (+ -1 (NFIX ITERATION))
                                           (ENVIR-1-FIX ENV-1)
                                           (FRAME-1-FIX FR-1)))
               (:P (ENVIR-1-FIX ENV-1)
                   (FRAME-1-FIX FR-1)
                   (+ -1 (NFIX ITERATION))))
          (:P ENV-1 FR-1 ITERATION))
 (IMPLIES (ZP (NFIX ITERATION))
          (:P ENV-1 FR-1 ITERATION))).
This induction is justified by the same argument used to admit REP-1.
Note, however, that the unmeasured variables ENV-1 and FR-1 are being
instantiated.  When applied to the goal at hand the above induction
scheme produces four nontautological subgoals.

[Note:  A hint was supplied for our processing of the goal below. 
Thanks!]

Subgoal *1/4
(IMPLIES
 (AND
  (NOT (ZP (NFIX ITERATION)))
  (NOT (FRAME-1->LOOP-BREAK (REP-1 (+ -1 (NFIX ITERATION))
                                   (ENVIR-1-FIX ENV-1)
                                   (FRAME-1-FIX FR-1))))
  (NOT
   (FRAME-1->LOOP-BREAK
    (IF
       (NOT (EQUAL (NTH (+ -1 (+ -1 (NFIX ITERATION))
                           (ENVIR-1->LOOP-COUNTER-SHIFT (ENVIR-1-FIX ENV-1)))
                        (ENVIR-1->A (ENVIR-1-FIX ENV-1)))
                   (NTH (+ (+ -1 (NFIX ITERATION))
                           (ENVIR-1->LOOP-COUNTER-SHIFT (ENVIR-1-FIX ENV-1)))
                        (ENVIR-1->A (ENVIR-1-FIX ENV-1)))))
       (LET* ((FR-1 (LET ((CHANGE-FRAME-1 (REP-1 (+ -1 (NFIX ITERATION))
                                                 (ENVIR-1-FIX ENV-1)
                                                 (FRAME-1-FIX FR-1)))
                          (FRAME-1->RESULT 0))
                         (FRAME-1 (FRAME-1->I CHANGE-FRAME-1)
                                  FRAME-1->RESULT
                                  (FRAME-1->LOOP-BREAK CHANGE-FRAME-1))))
              (FR-1 (LET ((CHANGE-FRAME-1 FR-1)
                          (FRAME-1->LOOP-BREAK T))
                         (FRAME-1 (FRAME-1->I CHANGE-FRAME-1)
                                  (FRAME-1->RESULT CHANGE-FRAME-1)
                                  FRAME-1->LOOP-BREAK))))
             (COND (T FR-1)
                   ((FRAME-1->LOOP-BREAK FR-1) FR-1)
                   (T FR-1)))
       (REP-1 (+ -1 (NFIX ITERATION))
              (ENVIR-1-FIX ENV-1)
              (FRAME-1-FIX FR-1)))))
  (NOT
   (FRAME-1->LOOP-BREAK
    (IF
       (NOT (EQUAL (NTH (+ -1 (+ -1 (NFIX ITERATION))
                           (ENVIR-1->LOOP-COUNTER-SHIFT (ENVIR-1-FIX ENV-1)))
                        (ENVIR-1->A (ENVIR-1-FIX ENV-1)))
                   (NTH (+ (+ -1 (NFIX ITERATION))
                           (ENVIR-1->LOOP-COUNTER-SHIFT (ENVIR-1-FIX ENV-1)))
                        (ENVIR-1->A (ENVIR-1-FIX ENV-1)))))
       (LET* ((FR-1 (LET ((CHANGE-FRAME-1 (REP-1 (+ -1 (NFIX ITERATION))
                                                 (ENVIR-1-FIX ENV-1)
                                                 (FRAME-1-FIX FR-1)))
                          (FRAME-1->RESULT 0))
                         (FRAME-1 (FRAME-1->I CHANGE-FRAME-1)
                                  FRAME-1->RESULT
                                  (FRAME-1->LOOP-BREAK CHANGE-FRAME-1))))
              (FR-1 (LET ((CHANGE-FRAME-1 FR-1)
                          (FRAME-1->LOOP-BREAK T))
                         (FRAME-1 (FRAME-1->I CHANGE-FRAME-1)
                                  (FRAME-1->RESULT CHANGE-FRAME-1)
                                  FRAME-1->LOOP-BREAK))))
             (COND (T FR-1)
                   ((FRAME-1->LOOP-BREAK FR-1) FR-1)
                   (T FR-1)))
       (REP-1 (+ -1 (NFIX ITERATION))
              (ENVIR-1-FIX ENV-1)
              (FRAME-1-FIX FR-1)))))
  (LET ((UPD-FR-1 (REP-1 (+ -1 (NFIX ITERATION))
                         (ENVIR-1-FIX ENV-1)
                         (FRAME-1-FIX FR-1))))
       (FRAME-1-P UPD-FR-1)))
 (LET ((UPD-FR-1 (REP-1 ITERATION ENV-1 FR-1)))
      (FRAME-1-P UPD-FR-1))).
#<\<0( DEFTHM FRAME-1-P-OF-REP-1 ...)
c  0 Goal PUSH *1
++++++++++++++++++++++++++++++
c  4 *1 INDUCT
   1 |  Subgoal *1/4 preprocess
     |  |  <1 subgoal>
     |  <3 more subgoals>
#>\>
By the :congruence rules ENVIR-1->A$INLINE-ENVIR-1-EQUIV-CONGRUENCE-ON-X,
ENVIR-1->LOOP-COUNTER-SHIFT$INLINE-ENVIR-1-EQUIV-CONGRUENCE-ON-X and
NAT-EQUIV-IMPLIES-EQUAL-ZP-1 and the simple :rewrite rules 
ASSOCIATIVITY-OF-+, ENVIR-1-FIX-UNDER-ENVIR-1-EQUIV and NFIX-UNDER-NAT-EQUIV
we reduce the conjecture to

Subgoal *1/4'
(IMPLIES
 (AND
  (NOT (ZP ITERATION))
  (NOT (FRAME-1->LOOP-BREAK (REP-1 (+ -1 (NFIX ITERATION))
                                   (ENVIR-1-FIX ENV-1)
                                   (FRAME-1-FIX FR-1))))
  (NOT
   (FRAME-1->LOOP-BREAK
    (IF
     (NOT (EQUAL (NTH (+ -1 -1 (NFIX ITERATION)
                         (ENVIR-1->LOOP-COUNTER-SHIFT ENV-1))
                      (ENVIR-1->A ENV-1))
                 (NTH (+ -1 (NFIX ITERATION)
                         (ENVIR-1->LOOP-COUNTER-SHIFT ENV-1))
                      (ENVIR-1->A ENV-1))))
     (LET
       ((CHANGE-FRAME-1 (LET ((CHANGE-FRAME-1 (REP-1 (+ -1 (NFIX ITERATION))
                                                     (ENVIR-1-FIX ENV-1)
                                                     (FRAME-1-FIX FR-1)))
                              (FRAME-1->RESULT 0))
                             (FRAME-1 (FRAME-1->I CHANGE-FRAME-1)
                                      FRAME-1->RESULT
                                      (FRAME-1->LOOP-BREAK CHANGE-FRAME-1))))
        (FRAME-1->LOOP-BREAK T))
       (FRAME-1 (FRAME-1->I CHANGE-FRAME-1)
                (FRAME-1->RESULT CHANGE-FRAME-1)
                FRAME-1->LOOP-BREAK))
     (REP-1 (+ -1 (NFIX ITERATION))
            (ENVIR-1-FIX ENV-1)
            (FRAME-1-FIX FR-1)))))
  (FRAME-1-P (REP-1 (+ -1 (NFIX ITERATION))
                    (ENVIR-1-FIX ENV-1)
                    (FRAME-1-FIX FR-1))))
 (FRAME-1-P (REP-1 ITERATION ENV-1 FR-1))).
#<\<0( DEFTHM FRAME-1-P-OF-REP-1 ...)
c  0 Goal PUSH *1
++++++++++++++++++++++++++++++
c  4 *1 INDUCT
   1 |  Subgoal *1/4 preprocess
   2 |  |  Subgoal *1/4' simp
     |  |  |  <2 subgoals>
     |  <3 more subgoals>
#>\>
This simplifies, using the :compound-recognizer rule ZP-COMPOUND-RECOGNIZER,
the :congruence rules FRAME-1-IFF-CONGRUENCE-ON-LOOP-BREAK and 
FRAME-1-INT-EQUIV-CONGRUENCE-ON-I, the :definitions NFIX, NOT (if-intro)
and SYNP, the :executable-counterparts of BINARY-+ and IFIX, primitive
type reasoning and the :rewrite rules FOLD-CONSTS-IN-+, 
FRAME-1->I-OF-FRAME-1, FRAME-1->RESULT-OF-FRAME-1 and IFIX-UNDER-INT-EQUIV,
to the following two conjectures.

Subgoal *1/4.2
(IMPLIES (AND (NOT (ZP ITERATION))
              (NOT (FRAME-1->LOOP-BREAK (REP-1 (+ -1 (NFIX ITERATION))
                                               (ENVIR-1-FIX ENV-1)
                                               (FRAME-1-FIX FR-1))))
              (EQUAL (NTH (+ -2 ITERATION
                             (ENVIR-1->LOOP-COUNTER-SHIFT ENV-1))
                          (ENVIR-1->A ENV-1))
                     (NTH (+ -1 ITERATION
                             (ENVIR-1->LOOP-COUNTER-SHIFT ENV-1))
                          (ENVIR-1->A ENV-1)))
              (FRAME-1-P (REP-1 (+ -1 (NFIX ITERATION))
                                (ENVIR-1-FIX ENV-1)
                                (FRAME-1-FIX FR-1))))
         (FRAME-1-P (REP-1 ITERATION ENV-1 FR-1))).
#<\<0( DEFTHM FRAME-1-P-OF-REP-1 ...)
c  0 Goal PUSH *1
++++++++++++++++++++++++++++++
c  4 *1 INDUCT
   1 |  Subgoal *1/4 preprocess
   2 |  |  Subgoal *1/4' simp
   1 |  |  |  Subgoal *1/4.2 simp
     |  |  |  |  <1 subgoal>
     |  |  |  <1 more subgoal>
     |  <3 more subgoals>
#>\>
This simplifies, using the :compound-recognizer rule ZP-COMPOUND-RECOGNIZER,
the :definition NFIX and primitive type reasoning, to

Subgoal *1/4.2'
(IMPLIES (AND (NOT (ZP ITERATION))
              (NOT (FRAME-1->LOOP-BREAK (REP-1 (+ -1 ITERATION)
                                               (ENVIR-1-FIX ENV-1)
                                               (FRAME-1-FIX FR-1))))
              (EQUAL (NTH (+ -2 ITERATION
                             (ENVIR-1->LOOP-COUNTER-SHIFT ENV-1))
                          (ENVIR-1->A ENV-1))
                     (NTH (+ -1 ITERATION
                             (ENVIR-1->LOOP-COUNTER-SHIFT ENV-1))
                          (ENVIR-1->A ENV-1)))
              (FRAME-1-P (REP-1 (+ -1 ITERATION)
                                (ENVIR-1-FIX ENV-1)
                                (FRAME-1-FIX FR-1))))
         (FRAME-1-P (REP-1 ITERATION ENV-1 FR-1))).

[Note:  A hint was supplied for our processing of the goal above. 
Thanks!]
#<\<0( DEFTHM FRAME-1-P-OF-REP-1 ...)
c  0 Goal PUSH *1
++++++++++++++++++++++++++++++
c  4 *1 INDUCT
   1 |  Subgoal *1/4 preprocess
   2 |  |  Subgoal *1/4' simp
     |  |  |  <1 more subgoal>
     |  <3 more subgoals>
#>\>
But simplification reduces this to T, using the :compound-recognizer
rule ZP-COMPOUND-RECOGNIZER, the :definitions NFIX, REP-1 and SYNP,
the :executable-counterpart of BINARY-+, primitive type reasoning and
the :rewrite rules COMMUTATIVITY-2-OF-+, COMMUTATIVITY-OF-+, 
ENVIR-1->A$INLINE-OF-ENVIR-1-FIX-X, 
ENVIR-1->LOOP-COUNTER-SHIFT$INLINE-OF-ENVIR-1-FIX-X, FOLD-CONSTS-IN-+
and FRAME-1-P-OF-FRAME-1.

Subgoal *1/4.1
(IMPLIES
 (AND
  (NOT (ZP ITERATION))
  (NOT (FRAME-1->LOOP-BREAK (REP-1 (+ -1 (NFIX ITERATION))
                                   (ENVIR-1-FIX ENV-1)
                                   (FRAME-1-FIX FR-1))))
  (NOT
     (FRAME-1->LOOP-BREAK (FRAME-1 (FRAME-1->I (REP-1 (+ -1 (NFIX ITERATION))
                                                      (ENVIR-1-FIX ENV-1)
                                                      (FRAME-1-FIX FR-1)))
                                   0 T)))
  (FRAME-1-P (REP-1 (+ -1 (NFIX ITERATION))
                    (ENVIR-1-FIX ENV-1)
                    (FRAME-1-FIX FR-1))))
 (FRAME-1-P (REP-1 ITERATION ENV-1 FR-1))).
#<\<0( DEFTHM FRAME-1-P-OF-REP-1 ...)
c  0 Goal PUSH *1
++++++++++++++++++++++++++++++
c  4 *1 INDUCT
     |  <3 more subgoals>
#>\>
But we reduce the conjecture to T, by the :executable-counterpart of
BOOL-FIX$INLINE and the simple :rewrite rule FRAME-1->LOOP-BREAK-OF-FRAME-1.

[Note:  A hint was supplied for our processing of the goal below. 
Thanks!]

Subgoal *1/3
(IMPLIES
 (AND
  (NOT (ZP (NFIX ITERATION)))
  (NOT (FRAME-1->LOOP-BREAK (REP-1 (+ -1 (NFIX ITERATION))
                                   (ENVIR-1-FIX ENV-1)
                                   (FRAME-1-FIX FR-1))))
  (FRAME-1->LOOP-BREAK
   (IF (NOT (EQUAL (NTH (+ -1 (+ -1 (NFIX ITERATION))
                           (ENVIR-1->LOOP-COUNTER-SHIFT (ENVIR-1-FIX ENV-1)))
                        (ENVIR-1->A (ENVIR-1-FIX ENV-1)))
                   (NTH (+ (+ -1 (NFIX ITERATION))
                           (ENVIR-1->LOOP-COUNTER-SHIFT (ENVIR-1-FIX ENV-1)))
                        (ENVIR-1->A (ENVIR-1-FIX ENV-1)))))
       (LET* ((FR-1 (LET ((CHANGE-FRAME-1 (REP-1 (+ -1 (NFIX ITERATION))
                                                 (ENVIR-1-FIX ENV-1)
                                                 (FRAME-1-FIX FR-1)))
                          (FRAME-1->RESULT 0))
                         (FRAME-1 (FRAME-1->I CHANGE-FRAME-1)
                                  FRAME-1->RESULT
                                  (FRAME-1->LOOP-BREAK CHANGE-FRAME-1))))
              (FR-1 (LET ((CHANGE-FRAME-1 FR-1)
                          (FRAME-1->LOOP-BREAK T))
                         (FRAME-1 (FRAME-1->I CHANGE-FRAME-1)
                                  (FRAME-1->RESULT CHANGE-FRAME-1)
                                  FRAME-1->LOOP-BREAK))))
             (COND (T FR-1)
                   ((FRAME-1->LOOP-BREAK FR-1) FR-1)
                   (T FR-1)))
       (REP-1 (+ -1 (NFIX ITERATION))
              (ENVIR-1-FIX ENV-1)
              (FRAME-1-FIX FR-1))))
  (LET ((UPD-FR-1 (REP-1 (+ -1 (NFIX ITERATION))
                         (ENVIR-1-FIX ENV-1)
                         (FRAME-1-FIX FR-1))))
       (FRAME-1-P UPD-FR-1)))
 (LET ((UPD-FR-1 (REP-1 ITERATION ENV-1 FR-1)))
      (FRAME-1-P UPD-FR-1))).
#<\<0( DEFTHM FRAME-1-P-OF-REP-1 ...)
c  0 Goal PUSH *1
++++++++++++++++++++++++++++++
c  4 *1 INDUCT
   1 |  Subgoal *1/3 preprocess
     |  |  <1 subgoal>
     |  <2 more subgoals>
#>\>
By the :congruence rules ENVIR-1->A$INLINE-ENVIR-1-EQUIV-CONGRUENCE-ON-X,
ENVIR-1->LOOP-COUNTER-SHIFT$INLINE-ENVIR-1-EQUIV-CONGRUENCE-ON-X and
NAT-EQUIV-IMPLIES-EQUAL-ZP-1 and the simple :rewrite rules 
ASSOCIATIVITY-OF-+, ENVIR-1-FIX-UNDER-ENVIR-1-EQUIV and NFIX-UNDER-NAT-EQUIV
we reduce the conjecture to

Subgoal *1/3'
(IMPLIES
 (AND
  (NOT (ZP ITERATION))
  (NOT (FRAME-1->LOOP-BREAK (REP-1 (+ -1 (NFIX ITERATION))
                                   (ENVIR-1-FIX ENV-1)
                                   (FRAME-1-FIX FR-1))))
  (FRAME-1->LOOP-BREAK
   (IF
    (NOT (EQUAL (NTH (+ -1 -1 (NFIX ITERATION)
                        (ENVIR-1->LOOP-COUNTER-SHIFT ENV-1))
                     (ENVIR-1->A ENV-1))
                (NTH (+ -1 (NFIX ITERATION)
                        (ENVIR-1->LOOP-COUNTER-SHIFT ENV-1))
                     (ENVIR-1->A ENV-1))))
    (LET
       ((CHANGE-FRAME-1 (LET ((CHANGE-FRAME-1 (REP-1 (+ -1 (NFIX ITERATION))
                                                     (ENVIR-1-FIX ENV-1)
                                                     (FRAME-1-FIX FR-1)))
                              (FRAME-1->RESULT 0))
                             (FRAME-1 (FRAME-1->I CHANGE-FRAME-1)
                                      FRAME-1->RESULT
                                      (FRAME-1->LOOP-BREAK CHANGE-FRAME-1))))
        (FRAME-1->LOOP-BREAK T))
       (FRAME-1 (FRAME-1->I CHANGE-FRAME-1)
                (FRAME-1->RESULT CHANGE-FRAME-1)
                FRAME-1->LOOP-BREAK))
    (REP-1 (+ -1 (NFIX ITERATION))
           (ENVIR-1-FIX ENV-1)
           (FRAME-1-FIX FR-1))))
  (FRAME-1-P (REP-1 (+ -1 (NFIX ITERATION))
                    (ENVIR-1-FIX ENV-1)
                    (FRAME-1-FIX FR-1))))
 (FRAME-1-P (REP-1 ITERATION ENV-1 FR-1))).
#<\<0( DEFTHM FRAME-1-P-OF-REP-1 ...)
c  0 Goal PUSH *1
++++++++++++++++++++++++++++++
c  4 *1 INDUCT
   1 |  Subgoal *1/3 preprocess
   1 |  |  Subgoal *1/3' simp
     |  |  |  <1 subgoal>
     |  <2 more subgoals>
#>\>
This simplifies, using the :compound-recognizer rule ZP-COMPOUND-RECOGNIZER,
the :congruence rules FRAME-1-IFF-CONGRUENCE-ON-LOOP-BREAK and 
FRAME-1-INT-EQUIV-CONGRUENCE-ON-I, the :definitions NFIX, NOT and SYNP,
the :executable-counterparts of BINARY-+ and IFIX, primitive type reasoning
and the :rewrite rules FOLD-CONSTS-IN-+, FRAME-1->I-OF-FRAME-1, 
FRAME-1->RESULT-OF-FRAME-1 and IFIX-UNDER-INT-EQUIV, to

Subgoal *1/3''
(IMPLIES
 (AND
     (NOT (ZP ITERATION))
     (NOT (FRAME-1->LOOP-BREAK (REP-1 (+ -1 (NFIX ITERATION))
                                      (ENVIR-1-FIX ENV-1)
                                      (FRAME-1-FIX FR-1))))
     (NOT (EQUAL (NTH (+ -2 ITERATION
                         (ENVIR-1->LOOP-COUNTER-SHIFT ENV-1))
                      (ENVIR-1->A ENV-1))
                 (NTH (+ -1 ITERATION
                         (ENVIR-1->LOOP-COUNTER-SHIFT ENV-1))
                      (ENVIR-1->A ENV-1))))
     (FRAME-1->LOOP-BREAK (FRAME-1 (FRAME-1->I (REP-1 (+ -1 (NFIX ITERATION))
                                                      (ENVIR-1-FIX ENV-1)
                                                      (FRAME-1-FIX FR-1)))
                                   0 T))
     (FRAME-1-P (REP-1 (+ -1 (NFIX ITERATION))
                       (ENVIR-1-FIX ENV-1)
                       (FRAME-1-FIX FR-1))))
 (FRAME-1-P (REP-1 ITERATION ENV-1 FR-1))).
#<\<0( DEFTHM FRAME-1-P-OF-REP-1 ...)
c  0 Goal PUSH *1
++++++++++++++++++++++++++++++
c  4 *1 INDUCT
   1 |  Subgoal *1/3 preprocess
   1 |  |  Subgoal *1/3' simp
   1 |  |  |  Subgoal *1/3'' preprocess
     |  |  |  |  <1 subgoal>
     |  <2 more subgoals>
#>\>
By the :executable-counterpart of BOOL-FIX$INLINE and the simple :rewrite
rule FRAME-1->LOOP-BREAK-OF-FRAME-1 we reduce the conjecture to

Subgoal *1/3'''
(IMPLIES (AND (NOT (ZP ITERATION))
              (NOT (FRAME-1->LOOP-BREAK (REP-1 (+ -1 (NFIX ITERATION))
                                               (ENVIR-1-FIX ENV-1)
                                               (FRAME-1-FIX FR-1))))
              (NOT (EQUAL (NTH (+ -2 ITERATION
                                  (ENVIR-1->LOOP-COUNTER-SHIFT ENV-1))
                               (ENVIR-1->A ENV-1))
                          (NTH (+ -1 ITERATION
                                  (ENVIR-1->LOOP-COUNTER-SHIFT ENV-1))
                               (ENVIR-1->A ENV-1))))
              (FRAME-1-P (REP-1 (+ -1 (NFIX ITERATION))
                                (ENVIR-1-FIX ENV-1)
                                (FRAME-1-FIX FR-1))))
         (FRAME-1-P (REP-1 ITERATION ENV-1 FR-1))).
#<\<0( DEFTHM FRAME-1-P-OF-REP-1 ...)
c  0 Goal PUSH *1
++++++++++++++++++++++++++++++
c  4 *1 INDUCT
   1 |  Subgoal *1/3 preprocess
   1 |  |  Subgoal *1/3' simp
   1 |  |  |  Subgoal *1/3'' preprocess
   1 |  |  |  |  Subgoal *1/3''' simp
     |  |  |  |  |  <1 subgoal>
     |  <2 more subgoals>
#>\>
This simplifies, using the :compound-recognizer rule ZP-COMPOUND-RECOGNIZER,
the :definition NFIX and primitive type reasoning, to

Subgoal *1/3'4'
(IMPLIES (AND (NOT (ZP ITERATION))
              (NOT (FRAME-1->LOOP-BREAK (REP-1 (+ -1 ITERATION)
                                               (ENVIR-1-FIX ENV-1)
                                               (FRAME-1-FIX FR-1))))
              (NOT (EQUAL (NTH (+ -2 ITERATION
                                  (ENVIR-1->LOOP-COUNTER-SHIFT ENV-1))
                               (ENVIR-1->A ENV-1))
                          (NTH (+ -1 ITERATION
                                  (ENVIR-1->LOOP-COUNTER-SHIFT ENV-1))
                               (ENVIR-1->A ENV-1))))
              (FRAME-1-P (REP-1 (+ -1 ITERATION)
                                (ENVIR-1-FIX ENV-1)
                                (FRAME-1-FIX FR-1))))
         (FRAME-1-P (REP-1 ITERATION ENV-1 FR-1))).

[Note:  A hint was supplied for our processing of the goal above. 
Thanks!]
#<\<0( DEFTHM FRAME-1-P-OF-REP-1 ...)
c  0 Goal PUSH *1
++++++++++++++++++++++++++++++
c  4 *1 INDUCT
     |  <2 more subgoals>
#>\>
But simplification reduces this to T, using the :compound-recognizer
rule ZP-COMPOUND-RECOGNIZER, the :congruence rules 
FRAME-1-INT-EQUIV-CONGRUENCE-ON-I and IFF-IMPLIES-EQUAL-BOOL-FIX-1,
the :definitions NFIX, REP-1 and SYNP, the :executable-counterparts
of BINARY-+, BOOL-FIX$INLINE and IFIX, primitive type reasoning and
the :rewrite rules COMMUTATIVITY-2-OF-+, COMMUTATIVITY-OF-+, 
ENVIR-1->A$INLINE-OF-ENVIR-1-FIX-X, 
ENVIR-1->LOOP-COUNTER-SHIFT$INLINE-OF-ENVIR-1-FIX-X, FOLD-CONSTS-IN-+,
FRAME-1->I-OF-FRAME-1, FRAME-1->LOOP-BREAK-OF-FRAME-1, 
FRAME-1->RESULT-OF-FRAME-1, FRAME-1-P-OF-FRAME-1 and IFIX-UNDER-INT-EQUIV.

[Note:  A hint was supplied for our processing of the goal below. 
Thanks!]

Subgoal *1/2
(IMPLIES (AND (NOT (ZP (NFIX ITERATION)))
              (FRAME-1->LOOP-BREAK (REP-1 (+ -1 (NFIX ITERATION))
                                          (ENVIR-1-FIX ENV-1)
                                          (FRAME-1-FIX FR-1)))
              (LET ((UPD-FR-1 (REP-1 (+ -1 (NFIX ITERATION))
                                     (ENVIR-1-FIX ENV-1)
                                     (FRAME-1-FIX FR-1))))
                   (FRAME-1-P UPD-FR-1)))
         (LET ((UPD-FR-1 (REP-1 ITERATION ENV-1 FR-1)))
              (FRAME-1-P UPD-FR-1))).
#<\<0( DEFTHM FRAME-1-P-OF-REP-1 ...)
c  0 Goal PUSH *1
++++++++++++++++++++++++++++++
c  4 *1 INDUCT
   1 |  Subgoal *1/2 preprocess
     |  |  <1 subgoal>
     |  <1 more subgoal>
#>\>
By the :congruence rule NAT-EQUIV-IMPLIES-EQUAL-ZP-1 and the simple
:rewrite rule NFIX-UNDER-NAT-EQUIV we reduce the conjecture to

Subgoal *1/2'
(IMPLIES (AND (NOT (ZP ITERATION))
              (FRAME-1->LOOP-BREAK (REP-1 (+ -1 (NFIX ITERATION))
                                          (ENVIR-1-FIX ENV-1)
                                          (FRAME-1-FIX FR-1)))
              (FRAME-1-P (REP-1 (+ -1 (NFIX ITERATION))
                                (ENVIR-1-FIX ENV-1)
                                (FRAME-1-FIX FR-1))))
         (FRAME-1-P (REP-1 ITERATION ENV-1 FR-1))).
#<\<0( DEFTHM FRAME-1-P-OF-REP-1 ...)
c  0 Goal PUSH *1
++++++++++++++++++++++++++++++
c  4 *1 INDUCT
   1 |  Subgoal *1/2 preprocess
   1 |  |  Subgoal *1/2' simp
     |  |  |  <1 subgoal>
     |  <1 more subgoal>
#>\>
This simplifies, using the :compound-recognizer rule ZP-COMPOUND-RECOGNIZER,
the :definition NFIX and primitive type reasoning, to

Subgoal *1/2''
(IMPLIES (AND (NOT (ZP ITERATION))
              (FRAME-1->LOOP-BREAK (REP-1 (+ -1 ITERATION)
                                          (ENVIR-1-FIX ENV-1)
                                          (FRAME-1-FIX FR-1)))
              (FRAME-1-P (REP-1 (+ -1 ITERATION)
                                (ENVIR-1-FIX ENV-1)
                                (FRAME-1-FIX FR-1))))
         (FRAME-1-P (REP-1 ITERATION ENV-1 FR-1))).

[Note:  A hint was supplied for our processing of the goal above. 
Thanks!]
#<\<0( DEFTHM FRAME-1-P-OF-REP-1 ...)
c  0 Goal PUSH *1
++++++++++++++++++++++++++++++
c  4 *1 INDUCT
     |  <1 more subgoal>
#>\>
But simplification reduces this to T, using the :compound-recognizer
rules CONSP-WHEN-FRAME-1-P and ZP-COMPOUND-RECOGNIZER, the :definitions
NFIX and REP-1, primitive type reasoning and the :type-prescription
rule FRAME-1->LOOP-BREAK$INLINE.

[Note:  A hint was supplied for our processing of the goal below. 
Thanks!]

Subgoal *1/1
(IMPLIES (ZP (NFIX ITERATION))
         (LET ((UPD-FR-1 (REP-1 ITERATION ENV-1 FR-1)))
              (FRAME-1-P UPD-FR-1))).
#<\<0( DEFTHM FRAME-1-P-OF-REP-1 ...)
c  0 Goal PUSH *1
++++++++++++++++++++++++++++++
c  4 *1 INDUCT
   1 |  Subgoal *1/1 preprocess
     |  |  <1 subgoal>
#>\>
By the :congruence rule NAT-EQUIV-IMPLIES-EQUAL-ZP-1 and the simple
:rewrite rule NFIX-UNDER-NAT-EQUIV we reduce the conjecture to

Subgoal *1/1'
(IMPLIES (ZP ITERATION)
         (FRAME-1-P (REP-1 ITERATION ENV-1 FR-1))).

[Note:  A hint was supplied for our processing of the goal above. 
Thanks!]
#<\<0( DEFTHM FRAME-1-P-OF-REP-1 ...)
Q.E.D.#>\>
But simplification reduces this to T, using the :compound-recognizer
rule ZP-COMPOUND-RECOGNIZER, the :definitions NFIX and REP-1, the :executable-
counterpart of ZP and the :rewrite rule FRAME-1-P-OF-FRAME-1-FIX.

That completes the proof of *1.

Q.E.D.

The storage of FRAME-1-P-OF-REP-1 depends upon the :compound-recognizer
rule CONSP-WHEN-FRAME-1-P and the :type-prescription rule FRAME-1-P.

Summary
Form:  ( DEFTHM FRAME-1-P-OF-REP-1 ...)
Rules: ((:COMPOUND-RECOGNIZER CONSP-WHEN-FRAME-1-P)
        (:COMPOUND-RECOGNIZER ZP-COMPOUND-RECOGNIZER)
        (:CONGRUENCE ENVIR-1->A$INLINE-ENVIR-1-EQUIV-CONGRUENCE-ON-X)
        (:CONGRUENCE
            ENVIR-1->LOOP-COUNTER-SHIFT$INLINE-ENVIR-1-EQUIV-CONGRUENCE-ON-X)
        (:CONGRUENCE FRAME-1-IFF-CONGRUENCE-ON-LOOP-BREAK)
        (:CONGRUENCE FRAME-1-INT-EQUIV-CONGRUENCE-ON-I)
        (:CONGRUENCE IFF-IMPLIES-EQUAL-BOOL-FIX-1)
        (:CONGRUENCE NAT-EQUIV-IMPLIES-EQUAL-ZP-1)
        (:DEFINITION NFIX)
        (:DEFINITION NOT)
        (:DEFINITION REP-1)
        (:DEFINITION SYNP)
        (:EXECUTABLE-COUNTERPART BINARY-+)
        (:EXECUTABLE-COUNTERPART BOOL-FIX$INLINE)
        (:EXECUTABLE-COUNTERPART IFIX)
        (:EXECUTABLE-COUNTERPART NOT)
        (:EXECUTABLE-COUNTERPART ZP)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:INDUCTION REP-1)
        (:REWRITE ASSOCIATIVITY-OF-+)
        (:REWRITE COMMUTATIVITY-2-OF-+)
        (:REWRITE COMMUTATIVITY-OF-+)
        (:REWRITE ENVIR-1->A$INLINE-OF-ENVIR-1-FIX-X)
        (:REWRITE ENVIR-1->LOOP-COUNTER-SHIFT$INLINE-OF-ENVIR-1-FIX-X)
        (:REWRITE ENVIR-1-FIX-UNDER-ENVIR-1-EQUIV)
        (:REWRITE FOLD-CONSTS-IN-+)
        (:REWRITE FRAME-1->I-OF-FRAME-1)
        (:REWRITE FRAME-1->LOOP-BREAK-OF-FRAME-1)
        (:REWRITE FRAME-1->RESULT-OF-FRAME-1)
        (:REWRITE FRAME-1-P-OF-FRAME-1)
        (:REWRITE FRAME-1-P-OF-FRAME-1-FIX)
        (:REWRITE IFIX-UNDER-INT-EQUIV)
        (:REWRITE NFIX-UNDER-NAT-EQUIV)
        (:TYPE-PRESCRIPTION FRAME-1->LOOP-BREAK$INLINE)
        (:TYPE-PRESCRIPTION FRAME-1-P))
Splitter rules (see :DOC splitter):
  if-intro: ((:DEFINITION NOT))
Time:  0.08 seconds (prove: 0.08, print: 0.00, proof tree: 0.00, other: 0.00)
Prover steps counted:  5116
FRAME-1-P-OF-REP-1

Summary
Form:  ( PROGN (DEFTHM FRAME-1-P-OF-REP-1 ...) ...)
Rules: NIL
Time:  0.08 seconds (prove: 0.08, print: 0.00, proof tree: 0.00, other: 0.00)
Prover steps counted:  5116
REP-1

* Step 3:  That completes the admissibility check.  Each form read
was an embedded event form and was admissible.  We now retract back
to the world created by the first ten events after the initial IN-
PACKAGE form and try to include the remainder of the book.  This may
expose local incompatibilities.

Summary
Form:  ( INCLUDE-BOOK "element_equality-verification-condition-theory"
...)
Rules: NIL
Time:  0.03 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.03)

ACL2 Warning [Guards] in (CERTIFY-BOOK 
"element_equality-verification-condition-theory" ...):  The book 
"C:/Users/whitebot/Desktop/C-lightVer2/element_equality-verification-condition-theory.lisp"
defines the function REP-1, which has not had its guards verified.
Moreover, this book's included sub-books and/or its certification world
define functions CDR-CDR-INDUCT, CDR-DEC-INDUCT, CDR-INDUCT, DEC-DEC-INDUCT,
DEC-INDUCT, DEFSORT-FUNCTIONAL-INST-SUBST, FLAG::DO-BOTH, ELEMENT-EQ,
ELEMENT-EQUIV, ELEMENT-LIST-EQUIV, ELEMENT-LIST-FIX, ELEMENT-LIST-NONEMPTY-P,
ELEMENT-LIST-P, ELEMENTLIST-MAPAPPEND, ELEMENTLIST-PROJECTION, 
FIX-COMPARABLEP, FLAG-IS, IFF-LIST, INTERSECTP-WITNESS, KEYVAL-ALIST-P,
STD::MAKE-DEFINE-CONFIG-FN, XDOC::MAKE-XDOC-FRAGMENTS, NATS-EQUIV,
OUTELEMENT-LIST-P, RULETABLE-DELETE-TAGS, RULETABLE-KEEP-TAGS, 
SAVED-OBLIGS-HINTS-TO-COMPUTED, SAVED-OBLIGS-PROOFLST-COLLECT-HINTS,
SET-UNEQUAL-WITNESS, SUBSETP-WITNESS, UNIVERSAL-EQUIV-EQUIVTERMS, 
UNIVERSAL-EQUIV-MULTI-QVAR-BINDINGS and UNIVERSAL-EQUIV-QVAR-BINDINGS,
which have not had their guards verified.  See :DOC guards.


* Step 4:  Write the certificate for 
"C:/Users/whitebot/Desktop/C-lightVer2/element_equality-verification-condition-theory.lisp"
in 
"C:/Users/whitebot/Desktop/C-lightVer2/element_equality-verification-condition-theory.cert".


* Step 5:  Compile the functions defined in 
"C:/Users/whitebot/Desktop/C-lightVer2/element_equality-verification-condition-theory.lisp".


Writing book expansion file, C:/Users/whitebot/Desktop/C-lightVer2/element_-
equality-verification-condition-theory@expansion.lsp.


Note: Deleting expansion file for the book,
C:/Users/whitebot/Desktop/C-lightVer2/element_equality-verification-
condition-theory.lisp.

Summary
Form:  (CERTIFY-BOOK "element_equality-verification-condition-theory"
...)
Rules: NIL
Warnings:  Guards, Subsume, Theory and Non-rec
Time:  1.34 seconds (prove: 0.27, print: 0.00, proof tree: 0.00, other: 1.08)
Prover steps counted:  19229
 "C:/Users/whitebot/Desktop/C-lightVer2/element_equality-verification-condition-theory.lisp"
ACL2 !>   d       1:x(INCLUDE-BOOK "centaur/fty/top"
                            :DIR ...)
ACL2 !>
Note: Writing .port file, C:/Users/whitebot/Desktop/C-lightVer2/element_-
equality-verification-condition-1.port.

CERTIFICATION ATTEMPT FOR 
"C:/Users/whitebot/Desktop/C-lightVer2/element_equality-verification-condition-1.lisp"

ACL2 Version 8.3

* Step 1:  Read 
"C:/Users/whitebot/Desktop/C-lightVer2/element_equality-verification-condition-1.lisp"
and compute its book-hash.

* Step 2:  There were ten forms in the file.  We now attempt to establish
that each form, whether local or non-local, is indeed an admissible
embedded event form in the context of the previously admitted ones.


ACL2 !>>(INCLUDE-BOOK "std/util/defrule"
                      :DIR :SYSTEM)

Summary
Form:  ( INCLUDE-BOOK "std/util/defrule" ...)
Rules: NIL
Time:  0.02 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.02)
"C:/Users/whitebot/Desktop/C-lightVer2/ACL2/books/std/util/defrule.lisp"


ACL2 !>>(INCLUDE-BOOK "centaur/fty/top"
                      :DIR :SYSTEM)

The event ( INCLUDE-BOOK "centaur/fty/top" ...) is redundant.  See
:DOC redundant-events.

Summary
Form:  ( INCLUDE-BOOK "centaur/fty/top" ...)
Rules: NIL
Time:  0.00 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.00)
:REDUNDANT


ACL2 !>>(INCLUDE-BOOK "std/util/bstar"
                      :DIR :SYSTEM)

The event ( INCLUDE-BOOK "std/util/bstar" ...) is redundant.  See :DOC
redundant-events.

Summary
Form:  ( INCLUDE-BOOK "std/util/bstar" ...)
Rules: NIL
Time:  0.00 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.00)
:REDUNDANT


ACL2 !>>(INCLUDE-BOOK "std/typed-lists/top"
                      :DIR :SYSTEM)

Summary
Form:  ( INCLUDE-BOOK "std/typed-lists/top" ...)
Rules: NIL
Time:  0.34 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.34)
"C:/Users/whitebot/Desktop/C-lightVer2/ACL2/books/std/typed-lists/top.lisp"


ACL2 !>>(INCLUDE-BOOK "std/lists/top"
                      :DIR :SYSTEM)
Note (from clause-processors/equality): disabling DISJOIN, DISJOIN2,
CONJOIN and CONJOIN2.


Summary
Form:  ( INCLUDE-BOOK "std/lists/top" ...)
Rules: NIL
Time:  0.33 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.33)
"C:/Users/whitebot/Desktop/C-lightVer2/ACL2/books/std/lists/top.lisp"


ACL2 !>>(INCLUDE-BOOK "std/basic/inductions"
                      :DIR :SYSTEM)

Summary
Form:  ( INCLUDE-BOOK "std/basic/inductions" ...)
Rules: NIL
Time:  0.02 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.02)
"C:/Users/whitebot/Desktop/C-lightVer2/ACL2/books/std/basic/inductions.lisp"


ACL2 !>>(INCLUDE-BOOK "element-eq")

Summary
Form:  ( INCLUDE-BOOK "element-eq" ...)
Rules: NIL
Time:  0.02 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.02)
"C:/Users/whitebot/Desktop/C-lightVer2/element-eq.lisp"


ACL2 !>>(INCLUDE-BOOK "element_equality-verification-condition-theory")

Summary
Form:  ( INCLUDE-BOOK "element_equality-verification-condition-theory"
...)
Rules: NIL
Time:  0.02 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.02)
"C:/Users/whitebot/Desktop/C-lightVer2/element_equality-verification-condition-theory.lisp"


ACL2 !>>(DEFRULE VERIFICATION-CONDITION-1
                 (IMPLIES (AND (INTEGER-LISTP A)
                               (NATP N)
                               (< 0 N)
                               (<= N (LENGTH A)))
                          (= (ELEMENT-EQ 0 (- N 1) A)
                             (FRAME-1->RESULT (REP-1 (- N 1)
                                                     (ENVIR-1-INIT 1 A)
                                                     (FRAME-1-INIT 1 1)))))
                 :RULE-CLASSES NIL
                 :ENABLE (ENVIR-1-INIT FRAME-1-INIT REP-1)
                 :INDUCT (DEC-INDUCT N))

<< Starting proof tree logging >>

[Note:  A hint was supplied for our processing of the goal above. 
Thanks!]
#<\<0( DEFTHM VERIFICATION-CONDITION-1 ...)
c  0 Goal PUSH *1
#>\>
Name the formula above *1.

We have been told to use induction.  One induction scheme is suggested
by the induction hint.  

We will induct according to a scheme suggested by (DEC-INDUCT N). 
This suggestion was produced using the :induction rule DEC-INDUCT.
If we let (:P A N) denote *1 above then the induction scheme we'll
use is
(AND (IMPLIES (AND (NOT (ZP N)) (:P A (+ -1 N)))
              (:P A N))
     (IMPLIES (ZP N) (:P A N))).
This induction is justified by the same argument used to admit DEC-INDUCT.
When applied to the goal at hand the above induction scheme produces
two nontautological subgoals.

Subgoal *1/2
(IMPLIES (AND (NOT (ZP N))
              (IMPLIES (AND (INTEGER-LISTP A)
                            (NATP (+ -1 N))
                            (< 0 (+ -1 N))
                            (<= (+ -1 N) (LENGTH A)))
                       (= (ELEMENT-EQ 0 (+ -1 -1 N) A)
                          (FRAME-1->RESULT (REP-1 (+ -1 -1 N)
                                                  (ENVIR-1-INIT 1 A)
                                                  (FRAME-1-INIT 1 1))))))
         (IMPLIES (AND (INTEGER-LISTP A)
                       (NATP N)
                       (< 0 N)
                       (<= N (LENGTH A)))
                  (= (ELEMENT-EQ 0 (+ -1 N) A)
                     (FRAME-1->RESULT (REP-1 (+ -1 N)
                                             (ENVIR-1-INIT 1 A)
                                             (FRAME-1-INIT 1 1)))))).
#<\<0( DEFTHM VERIFICATION-CONDITION-1 ...)
c  0 Goal PUSH *1
++++++++++++++++++++++++++++++
c  2 *1 INDUCT
   1 |  Subgoal *1/2 preprocess
     |  |  <1 subgoal>
     |  <1 more subgoal>
#>\>
By the simple :definitions =, ENVIR-1-INIT and NATP and the :executable-
counterpart of FRAME-1-INIT we reduce the conjecture to

Subgoal *1/2'
(IMPLIES
 (AND
  (NOT (ZP N))
  (IMPLIES
      (AND (INTEGER-LISTP A)
           (NATP (+ -1 N))
           (< 0 (+ -1 N))
           (<= (+ -1 N) (LENGTH A)))
      (EQUAL (ELEMENT-EQ 0 (+ -1 -1 N) A)
             (FRAME-1->RESULT (REP-1 (+ -1 -1 N)
                                     (ENVIR-1 1 A)
                                     '((I . 1) (RESULT . 1) (LOOP-BREAK))))))
  (INTEGER-LISTP A)
  (INTEGERP N)
  (<= 0 N)
  (< 0 N)
  (<= N (LENGTH A)))
 (EQUAL (ELEMENT-EQ 0 (+ -1 N) A)
        (FRAME-1->RESULT (REP-1 (+ -1 N)
                                (ENVIR-1 1 A)
                                '((I . 1) (RESULT . 1) (LOOP-BREAK)))))).
#<\<0( DEFTHM VERIFICATION-CONDITION-1 ...)
c  0 Goal PUSH *1
++++++++++++++++++++++++++++++
c  2 *1 INDUCT
   1 |  Subgoal *1/2 preprocess
   2 |  |  Subgoal *1/2' simp
     |  |  |  <2 subgoals>
     |  <1 more subgoal>
#>\>
This simplifies, using the :compound-recognizer rules 
NATP-COMPOUND-RECOGNIZER, TRUE-LISTP-WHEN-ACL2-NUMBER-LISTP, 
TRUE-LISTP-WHEN-INTEGER-LISTP, TRUE-LISTP-WHEN-RATIONAL-LISTP and 
ZP-COMPOUND-RECOGNIZER, the :definitions ELEMENT-EQ, LENGTH, NOT (if-
intro), REP-1 and SYNP, the :executable-counterparts of <, BINARY-+,
EQUAL, FRAME-1->RESULT$INLINE, FRAME-1-FIX$INLINE, NATP, NFIX and ZP,
primitive type reasoning, the :forward-chaining rules 
INTEGER-LISTP-FORWARD-TO-RATIONAL-LISTP and 
RATIONAL-LISTP-FORWARD-TO-ACL2-NUMBER-LISTP and the :rewrite rules
ENVIR-1-FIX-WHEN-ENVIR-1-P, ENVIR-1-P-OF-ENVIR-1, FOLD-CONSTS-IN-+,
INTEGER-LISTP-WHEN-SUBSETP-EQUAL and SUBSETP-REFL, to the following
two conjectures.

Subgoal *1/2.2
(IMPLIES
  (AND (EQUAL (ELEMENT-EQ 0 (+ -2 N) A)
              (FRAME-1->RESULT (REP-1 (+ -2 N)
                                      (ENVIR-1 1 A)
                                      '((I . 1) (RESULT . 1) (LOOP-BREAK)))))
       (INTEGER-LISTP A)
       (INTEGERP N)
       (<= 0 N)
       (< 0 N)
       (<= N (LEN A)))
  (EQUAL (ELEMENT-EQ 0 (+ -1 N) A)
         (FRAME-1->RESULT (REP-1 (+ -1 N)
                                 (ENVIR-1 1 A)
                                 '((I . 1) (RESULT . 1) (LOOP-BREAK)))))).
#<\<0( DEFTHM VERIFICATION-CONDITION-1 ...)
c  0 Goal PUSH *1
++++++++++++++++++++++++++++++
c  2 *1 INDUCT
   1 |  Subgoal *1/2 preprocess
   2 |  |  Subgoal *1/2' simp
   7 |  |  |  Subgoal *1/2.2 simp
     |  |  |  |  <7 subgoals>
     |  |  |  <1 more subgoal>
     |  <1 more subgoal>
#>\>
This simplifies, using the :compound-recognizer rules 
NATP-COMPOUND-RECOGNIZER and TRUE-LISTP-WHEN-INTEGER-LISTP, the :congruence
rule FRAME-1-INT-EQUIV-CONGRUENCE-ON-I, the :definitions ELEMENT-EQ
(if-intro), NFIX, NOT (if-intro), REP-1 (if-intro) and SYNP, the :executable-
counterparts of <, BINARY-+, FRAME-1-FIX$INLINE, IFIX, NATP and NOT,
primitive type reasoning and the :rewrite rules COMMUTATIVITY-OF-+,
ENVIR-1->A-OF-ENVIR-1, ENVIR-1->LOOP-COUNTER-SHIFT-OF-ENVIR-1, 
ENVIR-1-FIX-WHEN-ENVIR-1-P, ENVIR-1-P-OF-ENVIR-1, FOLD-CONSTS-IN-+,
FRAME-1->I-OF-FRAME-1, FRAME-1->RESULT-OF-FRAME-1, IFIX-UNDER-INT-EQUIV,
INTEGER-LIST-FIX-WHEN-INTEGER-LISTP and ZP-OPEN (if-intro), to the
following seven conjectures.

Subgoal *1/2.2.7
(IMPLIES
  (AND (EQUAL (ELEMENT-EQ 0 (+ -2 N) A)
              (FRAME-1->RESULT (REP-1 (+ -2 N)
                                      (ENVIR-1 1 A)
                                      '((I . 1) (RESULT . 1) (LOOP-BREAK)))))
       (INTEGER-LISTP A)
       (INTEGERP N)
       (<= 0 N)
       (< 0 N)
       (<= N (LEN A))
       (EQUAL 0 (+ -1 N)))
  (EQUAL 1
         (FRAME-1->RESULT '((I . 1) (RESULT . 1) (LOOP-BREAK))))).
#<\<0( DEFTHM VERIFICATION-CONDITION-1 ...)
c  0 Goal PUSH *1
++++++++++++++++++++++++++++++
c  2 *1 INDUCT
   1 |  Subgoal *1/2 preprocess
   2 |  |  Subgoal *1/2' simp
   7 |  |  |  Subgoal *1/2.2 simp
     |  |  |  |  <6 more subgoals>
     |  |  |  <1 more subgoal>
     |  <1 more subgoal>
#>\>
But we reduce the conjecture to T, by the :executable-counterparts
of EQUAL and FRAME-1->RESULT$INLINE.

Subgoal *1/2.2.6
(IMPLIES
 (AND
    (EQUAL (ELEMENT-EQ 0 (+ -2 N) A)
           (FRAME-1->RESULT (REP-1 (+ -2 N)
                                   (ENVIR-1 1 A)
                                   '((I . 1) (RESULT . 1) (LOOP-BREAK)))))
    (INTEGER-LISTP A)
    (INTEGERP N)
    (<= 0 N)
    (< 0 N)
    (<= N (LEN A))
    (NOT (EQUAL 0 (+ -1 N)))
    (EQUAL (NTH (+ -2 N) A)
           (NTH (+ -1 N) A))
    (< 0 (+ -1 N))
    (NOT (FRAME-1->LOOP-BREAK (REP-1 (+ -2 N)
                                     (ENVIR-1 1 A)
                                     '((I . 1) (RESULT . 1) (LOOP-BREAK))))))
 (EQUAL
  (ELEMENT-EQ 0 (+ -2 N) A)
  (FRAME-1->RESULT
      (FRAME-1 (+ 1
                  (FRAME-1->I (REP-1 (+ -2 N)
                                     (ENVIR-1 1 A)
                                     '((I . 1) (RESULT . 1) (LOOP-BREAK)))))
               (FRAME-1->RESULT (REP-1 (+ -2 N)
                                       (ENVIR-1 1 A)
                                       '((I . 1) (RESULT . 1) (LOOP-BREAK))))
               NIL)))).
#<\<0( DEFTHM VERIFICATION-CONDITION-1 ...)
c  0 Goal PUSH *1
++++++++++++++++++++++++++++++
c  2 *1 INDUCT
   1 |  Subgoal *1/2 preprocess
   2 |  |  Subgoal *1/2' simp
   7 |  |  |  Subgoal *1/2.2 simp
   1 |  |  |  |  Subgoal *1/2.2.6 preprocess
     |  |  |  |  |  <1 subgoal>
     |  |  |  |  <5 more subgoals>
     |  |  |  <1 more subgoal>
     |  <1 more subgoal>
#>\>
By the simple :rewrite rule FRAME-1->RESULT-OF-FRAME-1 we reduce the
conjecture to

Subgoal *1/2.2.6'
(IMPLIES
 (AND
    (EQUAL (ELEMENT-EQ 0 (+ -2 N) A)
           (FRAME-1->RESULT (REP-1 (+ -2 N)
                                   (ENVIR-1 1 A)
                                   '((I . 1) (RESULT . 1) (LOOP-BREAK)))))
    (INTEGER-LISTP A)
    (INTEGERP N)
    (<= 0 N)
    (< 0 N)
    (<= N (LEN A))
    (NOT (EQUAL 0 (+ -1 N)))
    (EQUAL (NTH (+ -2 N) A)
           (NTH (+ -1 N) A))
    (< 0 (+ -1 N))
    (NOT (FRAME-1->LOOP-BREAK (REP-1 (+ -2 N)
                                     (ENVIR-1 1 A)
                                     '((I . 1) (RESULT . 1) (LOOP-BREAK))))))
 (EQUAL (ELEMENT-EQ 0 (+ -2 N) A)
        (IFIX (FRAME-1->RESULT (REP-1 (+ -2 N)
                                      (ENVIR-1 1 A)
                                      '((I . 1)
                                        (RESULT . 1)
                                        (LOOP-BREAK))))))).
#<\<0( DEFTHM VERIFICATION-CONDITION-1 ...)
c  0 Goal PUSH *1
++++++++++++++++++++++++++++++
c  2 *1 INDUCT
   1 |  Subgoal *1/2 preprocess
   2 |  |  Subgoal *1/2' simp
   7 |  |  |  Subgoal *1/2.2 simp
     |  |  |  |  <5 more subgoals>
     |  |  |  <1 more subgoal>
     |  <1 more subgoal>
#>\>
But simplification reduces this to T, using the :definition IFIX, primitive
type reasoning and the :type-prescription rule ELEMENT-EQ.

Subgoal *1/2.2.5
(IMPLIES
  (AND (EQUAL (ELEMENT-EQ 0 (+ -2 N) A)
              (FRAME-1->RESULT (REP-1 (+ -2 N)
                                      (ENVIR-1 1 A)
                                      '((I . 1) (RESULT . 1) (LOOP-BREAK)))))
       (INTEGER-LISTP A)
       (INTEGERP N)
       (<= 0 N)
       (< 0 N)
       (<= N (LEN A))
       (NOT (EQUAL 0 (+ -1 N)))
       (NOT (EQUAL (NTH (+ -2 N) A)
                   (NTH (+ -1 N) A)))
       (< 0 (+ -1 N))
       (FRAME-1->LOOP-BREAK (REP-1 (+ -2 N)
                                   (ENVIR-1 1 A)
                                   '((I . 1) (RESULT . 1) (LOOP-BREAK)))))
  (EQUAL 0
         (FRAME-1->RESULT (REP-1 (+ -2 N)
                                 (ENVIR-1 1 A)
                                 '((I . 1) (RESULT . 1) (LOOP-BREAK)))))).
#<\<0( DEFTHM VERIFICATION-CONDITION-1 ...)
c  0 Goal PUSH *1
++++++++++++++++++++++++++++++
c  2 *1 INDUCT
   1 |  Subgoal *1/2 preprocess
   2 |  |  Subgoal *1/2' simp
   7 |  |  |  Subgoal *1/2.2 simp
   1 |  |  |  |  Subgoal *1/2.2.5 simp
     |  |  |  |  |  <1 subgoal>
     |  |  |  |  <4 more subgoals>
     |  |  |  <1 more subgoal>
     |  <1 more subgoal>
#>\>
This simplifies, using the :executable-counterpart of EQUAL, linear
arithmetic, primitive type reasoning and the :type-prescription rules
ELEMENT-EQ and FRAME-1->RESULT$INLINE, to

Subgoal *1/2.2.5'
(IMPLIES
   (AND (EQUAL (FRAME-1->RESULT (REP-1 (+ -2 N)
                                       (ENVIR-1 1 A)
                                       '((I . 1) (RESULT . 1) (LOOP-BREAK))))
               1)
        (EQUAL (ELEMENT-EQ 0 (+ -2 N) A) 1)
        (INTEGER-LISTP A)
        (INTEGERP N)
        (<= 0 N)
        (< 0 N)
        (<= N (LEN A))
        (NOT (EQUAL 0 (+ -1 N)))
        (NOT (EQUAL (NTH (+ -2 N) A)
                    (NTH (+ -1 N) A)))
        (< 0 (+ -1 N)))
   (NOT (FRAME-1->LOOP-BREAK (REP-1 (+ -2 N)
                                    (ENVIR-1 1 A)
                                    '((I . 1) (RESULT . 1) (LOOP-BREAK)))))).
#<\<0( DEFTHM VERIFICATION-CONDITION-1 ...)
c  0 Goal PUSH *1
++++++++++++++++++++++++++++++
c  2 *1 INDUCT
   1 |  Subgoal *1/2 preprocess
   2 |  |  Subgoal *1/2' simp
   7 |  |  |  Subgoal *1/2.2 simp
   1 |  |  |  |  Subgoal *1/2.2.5 simp
   1 |  |  |  |  |  Subgoal *1/2.2.5' simp
     |  |  |  |  |  |  <1 subgoal>
     |  |  |  |  <4 more subgoals>
     |  |  |  <1 more subgoal>
     |  <1 more subgoal>
#>\>
This simplifies, using primitive type reasoning, to

Subgoal *1/2.2.5''
(IMPLIES
   (AND (EQUAL (FRAME-1->RESULT (REP-1 (+ -2 N)
                                       (ENVIR-1 1 A)
                                       '((I . 1) (RESULT . 1) (LOOP-BREAK))))
               1)
        (EQUAL (ELEMENT-EQ 0 (+ -2 N) A) 1)
        (INTEGER-LISTP A)
        (INTEGERP N)
        (<= 0 N)
        (< 0 N)
        (<= N (LEN A))
        (NOT (EQUAL (NTH (+ -2 N) A)
                    (NTH (+ -1 N) A)))
        (< 0 (+ -1 N)))
   (NOT (FRAME-1->LOOP-BREAK (REP-1 (+ -2 N)
                                    (ENVIR-1 1 A)
                                    '((I . 1) (RESULT . 1) (LOOP-BREAK)))))).
#<\<0( DEFTHM VERIFICATION-CONDITION-1 ...)
c  0 Goal PUSH *1
++++++++++++++++++++++++++++++
c  2 *1 INDUCT
   1 |  Subgoal *1/2 preprocess
   2 |  |  Subgoal *1/2' simp
   7 |  |  |  Subgoal *1/2.2 simp
   1 |  |  |  |  Subgoal *1/2.2.5 simp
   1 |  |  |  |  |  Subgoal *1/2.2.5' simp
c  1 |  |  |  |  |  |  Subgoal *1/2.2.5'' GEN
     |  |  |  |  |  |  |  <1 subgoal>
     |  |  |  |  <4 more subgoals>
     |  |  |  <1 more subgoal>
     |  <1 more subgoal>
#>\>
We generalize this conjecture, replacing (+ -1 N) by I, (ENVIR-1 1 A)
by L and (+ -2 N) by J and restricting the types of the new variables
I, L and J to be those of the terms they replace, as established by
primitive type reasoning and ENVIR-1.  This produces

Subgoal *1/2.2.5'''
(IMPLIES
 (AND (INTEGERP I)
      (< 0 I)
      (CONSP L)
      (TRUE-LISTP L)
      (INTEGERP J)
      (EQUAL (FRAME-1->RESULT (REP-1 J
                                     L '((I . 1) (RESULT . 1) (LOOP-BREAK))))
             1)
      (EQUAL (ELEMENT-EQ 0 J A) 1)
      (INTEGER-LISTP A)
      (INTEGERP N)
      (<= 0 N)
      (< 0 N)
      (<= N (LEN A))
      (NOT (EQUAL (NTH J A) (NTH I A))))
 (NOT (FRAME-1->LOOP-BREAK (REP-1 J L
                                  '((I . 1) (RESULT . 1) (LOOP-BREAK)))))).
#<\<0( DEFTHM VERIFICATION-CONDITION-1 ...)
c  0 Goal PUSH *1
++++++++++++++++++++++++++++++
c  2 *1 INDUCT
   1 |  Subgoal *1/2 preprocess
   2 |  |  Subgoal *1/2' simp
   7 |  |  |  Subgoal *1/2.2 simp
   1 |  |  |  |  Subgoal *1/2.2.5 simp
   1 |  |  |  |  |  Subgoal *1/2.2.5' simp
c  1 |  |  |  |  |  |  Subgoal *1/2.2.5'' GEN
   1 |  |  |  |  |  |  |  Subgoal *1/2.2.5''' simp
     |  |  |  |  |  |  |  |  <1 subgoal>
     |  |  |  |  <4 more subgoals>
     |  |  |  <1 more subgoal>
     |  <1 more subgoal>
#>\>
This simplifies, using the :rewrite rule CONSP-UNDER-IFF-WHEN-TRUE-LISTP,
to

Subgoal *1/2.2.5'4'
(IMPLIES
 (AND (INTEGERP I)
      (< 0 I)
      L (TRUE-LISTP L)
      (INTEGERP J)
      (EQUAL (FRAME-1->RESULT (REP-1 J
                                     L '((I . 1) (RESULT . 1) (LOOP-BREAK))))
             1)
      (EQUAL (ELEMENT-EQ 0 J A) 1)
      (INTEGER-LISTP A)
      (INTEGERP N)
      (<= 0 N)
      (< 0 N)
      (<= N (LEN A))
      (NOT (EQUAL (NTH J A) (NTH I A))))
 (NOT (FRAME-1->LOOP-BREAK (REP-1 J L
                                  '((I . 1) (RESULT . 1) (LOOP-BREAK)))))).
#<\<0( DEFTHM VERIFICATION-CONDITION-1 ...)
c  0 Goal PUSH *1
++++++++++++++++++++++++++++++
c  2 *1 INDUCT
   1 |  Subgoal *1/2 preprocess
   2 |  |  Subgoal *1/2' simp
   7 |  |  |  Subgoal *1/2.2 simp
   1 |  |  |  |  Subgoal *1/2.2.5 simp
   1 |  |  |  |  |  Subgoal *1/2.2.5' simp
c  1 |  |  |  |  |  |  Subgoal *1/2.2.5'' GEN
   1 |  |  |  |  |  |  |  Subgoal *1/2.2.5''' simp
c  0 |  |  |  |  |  |  |  |  Subgoal *1/2.2.5'4' PUSH *1.1
     |  |  |  |  <4 more subgoals>
     |  |  |  <1 more subgoal>
     |  <1 more subgoal>
#>\>
Name the formula above *1.1.

Subgoal *1/2.2.4
(IMPLIES
 (AND
     (EQUAL (ELEMENT-EQ 0 (+ -2 N) A)
            (FRAME-1->RESULT (REP-1 (+ -2 N)
                                    (ENVIR-1 1 A)
                                    '((I . 1) (RESULT . 1) (LOOP-BREAK)))))
     (INTEGER-LISTP A)
     (INTEGERP N)
     (<= 0 N)
     (< 0 N)
     (<= N (LEN A))
     (NOT (EQUAL 0 (+ -1 N)))
     (NOT (EQUAL (NTH (+ -2 N) A)
                 (NTH (+ -1 N) A)))
     (< 0 (+ -1 N))
     (NOT (FRAME-1->LOOP-BREAK (REP-1 (+ -2 N)
                                      (ENVIR-1 1 A)
                                      '((I . 1) (RESULT . 1) (LOOP-BREAK)))))
     (FRAME-1->LOOP-BREAK
          (FRAME-1 (FRAME-1->I (REP-1 (+ -2 N)
                                      (ENVIR-1 1 A)
                                      '((I . 1) (RESULT . 1) (LOOP-BREAK))))
                   0 T)))
 (EQUAL
      0
      (FRAME-1->RESULT
           (FRAME-1 (FRAME-1->I (REP-1 (+ -2 N)
                                       (ENVIR-1 1 A)
                                       '((I . 1) (RESULT . 1) (LOOP-BREAK))))
                    0 T)))).
#<\<0( DEFTHM VERIFICATION-CONDITION-1 ...)
c  0 Goal PUSH *1
++++++++++++++++++++++++++++++
c  2 *1 INDUCT
   1 |  Subgoal *1/2 preprocess
   2 |  |  Subgoal *1/2' simp
   7 |  |  |  Subgoal *1/2.2 simp
   1 |  |  |  |  Subgoal *1/2.2.5 simp
   1 |  |  |  |  |  Subgoal *1/2.2.5' simp
c  1 |  |  |  |  |  |  Subgoal *1/2.2.5'' GEN
   1 |  |  |  |  |  |  |  Subgoal *1/2.2.5''' simp
c  0 |  |  |  |  |  |  |  |  Subgoal *1/2.2.5'4' PUSH *1.1
     |  |  |  |  <3 more subgoals>
     |  |  |  <1 more subgoal>
     |  <1 more subgoal>
#>\>
But we reduce the conjecture to T, by the :executable-counterparts
of BOOL-FIX$INLINE, EQUAL, IF and IFIX and the simple :rewrite rules
FRAME-1->LOOP-BREAK-OF-FRAME-1 and FRAME-1->RESULT-OF-FRAME-1.

Subgoal *1/2.2.3
(IMPLIES
 (AND
  (EQUAL (ELEMENT-EQ 0 (+ -2 N) A)
         (FRAME-1->RESULT (REP-1 (+ -2 N)
                                 (ENVIR-1 1 A)
                                 '((I . 1) (RESULT . 1) (LOOP-BREAK)))))
  (INTEGER-LISTP A)
  (INTEGERP N)
  (<= 0 N)
  (< 0 N)
  (<= N (LEN A))
  (NOT (EQUAL 0 (+ -1 N)))
  (NOT (EQUAL (NTH (+ -2 N) A)
              (NTH (+ -1 N) A)))
  (< 0 (+ -1 N))
  (NOT (FRAME-1->LOOP-BREAK (REP-1 (+ -2 N)
                                   (ENVIR-1 1 A)
                                   '((I . 1) (RESULT . 1) (LOOP-BREAK)))))
  (NOT
      (FRAME-1->LOOP-BREAK
           (FRAME-1 (FRAME-1->I (REP-1 (+ -2 N)
                                       (ENVIR-1 1 A)
                                       '((I . 1) (RESULT . 1) (LOOP-BREAK))))
                    0 T))))
 (EQUAL
  0
  (FRAME-1->RESULT
   (FRAME-1
    (+
      1
      (FRAME-1->I
           (FRAME-1 (FRAME-1->I (REP-1 (+ -2 N)
                                       (ENVIR-1 1 A)
                                       '((I . 1) (RESULT . 1) (LOOP-BREAK))))
                    0 T)))
    (FRAME-1->RESULT
         (FRAME-1 (FRAME-1->I (REP-1 (+ -2 N)
                                     (ENVIR-1 1 A)
                                     '((I . 1) (RESULT . 1) (LOOP-BREAK))))
                  0 T))
    NIL)))).
#<\<0( DEFTHM VERIFICATION-CONDITION-1 ...)
c  0 Goal PUSH *1
++++++++++++++++++++++++++++++
c  2 *1 INDUCT
   1 |  Subgoal *1/2 preprocess
   2 |  |  Subgoal *1/2' simp
   7 |  |  |  Subgoal *1/2.2 simp
   1 |  |  |  |  Subgoal *1/2.2.5 simp
   1 |  |  |  |  |  Subgoal *1/2.2.5' simp
c  1 |  |  |  |  |  |  Subgoal *1/2.2.5'' GEN
   1 |  |  |  |  |  |  |  Subgoal *1/2.2.5''' simp
c  0 |  |  |  |  |  |  |  |  Subgoal *1/2.2.5'4' PUSH *1.1
     |  |  |  |  <2 more subgoals>
     |  |  |  <1 more subgoal>
     |  <1 more subgoal>
#>\>
But we reduce the conjecture to T, by the :executable-counterparts
of BOOL-FIX$INLINE, EQUAL, IF and IFIX and the simple :rewrite rules
FRAME-1->I-OF-FRAME-1, FRAME-1->LOOP-BREAK-OF-FRAME-1 and 
FRAME-1->RESULT-OF-FRAME-1.

Subgoal *1/2.2.2
(IMPLIES
  (AND (EQUAL (ELEMENT-EQ 0 (+ -2 N) A)
              (FRAME-1->RESULT (REP-1 (+ -2 N)
                                      (ENVIR-1 1 A)
                                      '((I . 1) (RESULT . 1) (LOOP-BREAK)))))
       (INTEGER-LISTP A)
       (INTEGERP N)
       (<= 0 N)
       (< 0 N)
       (<= N (LEN A))
       (NOT (EQUAL 0 (+ -1 N)))
       (NOT (EQUAL (NTH (+ -2 N) A)
                   (NTH (+ -1 N) A)))
       (<= (+ -1 N) 0))
  (EQUAL 0
         (FRAME-1->RESULT '((I . 1) (RESULT . 1) (LOOP-BREAK))))).
#<\<0( DEFTHM VERIFICATION-CONDITION-1 ...)
c  0 Goal PUSH *1
++++++++++++++++++++++++++++++
c  2 *1 INDUCT
   1 |  Subgoal *1/2 preprocess
   2 |  |  Subgoal *1/2' simp
   7 |  |  |  Subgoal *1/2.2 simp
   1 |  |  |  |  Subgoal *1/2.2.5 simp
   1 |  |  |  |  |  Subgoal *1/2.2.5' simp
c  1 |  |  |  |  |  |  Subgoal *1/2.2.5'' GEN
   1 |  |  |  |  |  |  |  Subgoal *1/2.2.5''' simp
c  0 |  |  |  |  |  |  |  |  Subgoal *1/2.2.5'4' PUSH *1.1
   1 |  |  |  |  Subgoal *1/2.2.2 preprocess
     |  |  |  |  |  <1 subgoal>
     |  |  |  |  <1 more subgoal>
     |  |  |  <1 more subgoal>
     |  <1 more subgoal>
#>\>
By the :executable-counterparts of EQUAL and FRAME-1->RESULT$INLINE
we reduce the conjecture to

Subgoal *1/2.2.2'
(IMPLIES
  (AND (EQUAL (ELEMENT-EQ 0 (+ -2 N) A)
              (FRAME-1->RESULT (REP-1 (+ -2 N)
                                      (ENVIR-1 1 A)
                                      '((I . 1) (RESULT . 1) (LOOP-BREAK)))))
       (INTEGER-LISTP A)
       (INTEGERP N)
       (<= 0 N)
       (< 0 N)
       (<= N (LEN A))
       (NOT (EQUAL 0 (+ -1 N)))
       (NOT (EQUAL (NTH (+ -2 N) A)
                   (NTH (+ -1 N) A))))
  (< 0 (+ -1 N))).
#<\<0( DEFTHM VERIFICATION-CONDITION-1 ...)
c  0 Goal PUSH *1
++++++++++++++++++++++++++++++
c  2 *1 INDUCT
   1 |  Subgoal *1/2 preprocess
   2 |  |  Subgoal *1/2' simp
   7 |  |  |  Subgoal *1/2.2 simp
   1 |  |  |  |  Subgoal *1/2.2.5 simp
   1 |  |  |  |  |  Subgoal *1/2.2.5' simp
c  1 |  |  |  |  |  |  Subgoal *1/2.2.5'' GEN
   1 |  |  |  |  |  |  |  Subgoal *1/2.2.5''' simp
c  0 |  |  |  |  |  |  |  |  Subgoal *1/2.2.5'4' PUSH *1.1
     |  |  |  |  <1 more subgoal>
     |  |  |  <1 more subgoal>
     |  <1 more subgoal>
#>\>
But we reduce the conjecture to T, by primitive type reasoning.

Subgoal *1/2.2.1
(IMPLIES
  (AND (EQUAL (ELEMENT-EQ 0 (+ -2 N) A)
              (FRAME-1->RESULT (REP-1 (+ -2 N)
                                      (ENVIR-1 1 A)
                                      '((I . 1) (RESULT . 1) (LOOP-BREAK)))))
       (INTEGER-LISTP A)
       (INTEGERP N)
       (<= 0 N)
       (< 0 N)
       (<= N (LEN A))
       (NOT (EQUAL 0 (+ -1 N)))
       (EQUAL (NTH (+ -2 N) A)
              (NTH (+ -1 N) A))
       (<= (+ -1 N) 0))
  (EQUAL (ELEMENT-EQ 0 (+ -2 N) A)
         (FRAME-1->RESULT '((I . 1) (RESULT . 1) (LOOP-BREAK))))).
#<\<0( DEFTHM VERIFICATION-CONDITION-1 ...)
c  0 Goal PUSH *1
++++++++++++++++++++++++++++++
c  2 *1 INDUCT
   1 |  Subgoal *1/2 preprocess
   2 |  |  Subgoal *1/2' simp
   7 |  |  |  Subgoal *1/2.2 simp
   1 |  |  |  |  Subgoal *1/2.2.5 simp
   1 |  |  |  |  |  Subgoal *1/2.2.5' simp
c  1 |  |  |  |  |  |  Subgoal *1/2.2.5'' GEN
   1 |  |  |  |  |  |  |  Subgoal *1/2.2.5''' simp
c  0 |  |  |  |  |  |  |  |  Subgoal *1/2.2.5'4' PUSH *1.1
   1 |  |  |  |  Subgoal *1/2.2.1 preprocess
     |  |  |  |  |  <1 subgoal>
     |  |  |  <1 more subgoal>
     |  <1 more subgoal>
#>\>
By the :executable-counterpart of FRAME-1->RESULT$INLINE we reduce
the conjecture to

Subgoal *1/2.2.1'
(IMPLIES
  (AND (EQUAL (ELEMENT-EQ 0 (+ -2 N) A)
              (FRAME-1->RESULT (REP-1 (+ -2 N)
                                      (ENVIR-1 1 A)
                                      '((I . 1) (RESULT . 1) (LOOP-BREAK)))))
       (INTEGER-LISTP A)
       (INTEGERP N)
       (<= 0 N)
       (< 0 N)
       (<= N (LEN A))
       (NOT (EQUAL 0 (+ -1 N)))
       (EQUAL (NTH (+ -2 N) A)
              (NTH (+ -1 N) A))
       (<= (+ -1 N) 0))
  (EQUAL (ELEMENT-EQ 0 (+ -2 N) A) 1)).
#<\<0( DEFTHM VERIFICATION-CONDITION-1 ...)
c  0 Goal PUSH *1
++++++++++++++++++++++++++++++
c  2 *1 INDUCT
   1 |  Subgoal *1/2 preprocess
   2 |  |  Subgoal *1/2' simp
   7 |  |  |  Subgoal *1/2.2 simp
   1 |  |  |  |  Subgoal *1/2.2.5 simp
   1 |  |  |  |  |  Subgoal *1/2.2.5' simp
c  1 |  |  |  |  |  |  Subgoal *1/2.2.5'' GEN
   1 |  |  |  |  |  |  |  Subgoal *1/2.2.5''' simp
c  0 |  |  |  |  |  |  |  |  Subgoal *1/2.2.5'4' PUSH *1.1
     |  |  |  <1 more subgoal>
     |  <1 more subgoal>
#>\>
But we reduce the conjecture to T, by primitive type reasoning.

Subgoal *1/2.1
(IMPLIES
     (AND (< (LEN A) (+ -1 N))
          (INTEGER-LISTP A)
          (INTEGERP N)
          (<= 0 N)
          (< 0 N)
          (<= N (LEN A)))
     (EQUAL (ELEMENT-EQ 0 (+ -1 N) A)
            (FRAME-1->RESULT (REP-1 (+ -1 N)
                                    (ENVIR-1 1 A)
                                    '((I . 1) (RESULT . 1) (LOOP-BREAK)))))).
#<\<0( DEFTHM VERIFICATION-CONDITION-1 ...)
c  0 Goal PUSH *1
++++++++++++++++++++++++++++++
c  2 *1 INDUCT
   1 |  Subgoal *1/2 preprocess
   2 |  |  Subgoal *1/2' simp
   7 |  |  |  Subgoal *1/2.2 simp
   1 |  |  |  |  Subgoal *1/2.2.5 simp
   1 |  |  |  |  |  Subgoal *1/2.2.5' simp
c  1 |  |  |  |  |  |  Subgoal *1/2.2.5'' GEN
   1 |  |  |  |  |  |  |  Subgoal *1/2.2.5''' simp
c  0 |  |  |  |  |  |  |  |  Subgoal *1/2.2.5'4' PUSH *1.1
     |  <1 more subgoal>
#>\>
But we reduce the conjecture to T, by the :executable-counterpart of
TAU-SYSTEM.

Subgoal *1/1
(IMPLIES (ZP N)
         (IMPLIES (AND (INTEGER-LISTP A)
                       (NATP N)
                       (< 0 N)
                       (<= N (LENGTH A)))
                  (= (ELEMENT-EQ 0 (+ -1 N) A)
                     (FRAME-1->RESULT (REP-1 (+ -1 N)
                                             (ENVIR-1-INIT 1 A)
                                             (FRAME-1-INIT 1 1)))))).
#<\<0( DEFTHM VERIFICATION-CONDITION-1 ...)
c  0 Goal PUSH *1
++++++++++++++++++++++++++++++
c  2 *1 INDUCT
   1 |  Subgoal *1/2 preprocess
   2 |  |  Subgoal *1/2' simp
   7 |  |  |  Subgoal *1/2.2 simp
   1 |  |  |  |  Subgoal *1/2.2.5 simp
   1 |  |  |  |  |  Subgoal *1/2.2.5' simp
c  1 |  |  |  |  |  |  Subgoal *1/2.2.5'' GEN
   1 |  |  |  |  |  |  |  Subgoal *1/2.2.5''' simp
c  0 |  |  |  |  |  |  |  |  Subgoal *1/2.2.5'4' PUSH *1.1
#>\>
But we reduce the conjecture to T, by the :compound-recognizer rules
NATP-COMPOUND-RECOGNIZER and ZP-COMPOUND-RECOGNIZER and primitive type
reasoning.

So we now return to *1.1, which is

(IMPLIES
 (AND (INTEGERP I)
      (< 0 I)
      L (TRUE-LISTP L)
      (INTEGERP J)
      (EQUAL (FRAME-1->RESULT (REP-1 J
                                     L '((I . 1) (RESULT . 1) (LOOP-BREAK))))
             1)
      (EQUAL (ELEMENT-EQ 0 J A) 1)
      (INTEGER-LISTP A)
      (INTEGERP N)
      (<= 0 N)
      (< 0 N)
      (<= N (LEN A))
      (NOT (EQUAL (NTH J A) (NTH I A))))
 (NOT (FRAME-1->LOOP-BREAK (REP-1 J L
                                  '((I . 1) (RESULT . 1) (LOOP-BREAK)))))).

Perhaps we can prove *1.1 by induction.  Six induction schemes are
suggested by this conjecture.  Subsumption reduces that number to five.
These merge into three derived induction schemes.  However, one of
these is flawed and so we are left with two viable candidates.  By
considering those suggested by the largest number of non-primitive
recursive functions, we narrow the field to one.  

We will induct according to a scheme suggested by 
(REP-1 J L '((I . 1) (RESULT . 1) (LOOP-BREAK))).  This suggestion
was produced using the :induction rule REP-1.  If we let (:P A I J L N)
denote *1.1 above then the induction scheme we'll use is
(AND
 (IMPLIES
  (AND
   (NOT (ZP (NFIX J)))
   (NOT (FRAME-1->LOOP-BREAK
             (REP-1 (+ -1 (NFIX J))
                    (ENVIR-1-FIX L)
                    (FRAME-1-FIX '((I . 1) (RESULT . 1) (LOOP-BREAK))))))
   (NOT
    (FRAME-1->LOOP-BREAK
     (IF
      (NOT (EQUAL (NTH (+ -1 (+ -1 (NFIX J))
                          (ENVIR-1->LOOP-COUNTER-SHIFT (ENVIR-1-FIX L)))
                       (ENVIR-1->A (ENVIR-1-FIX L)))
                  (NTH (+ (+ -1 (NFIX J))
                          (ENVIR-1->LOOP-COUNTER-SHIFT (ENVIR-1-FIX L)))
                       (ENVIR-1->A (ENVIR-1-FIX L)))))
      (LET*
       ((FR-1
         (LET
            ((CHANGE-FRAME-1
                  (REP-1 (+ -1 (NFIX J))
                         (ENVIR-1-FIX L)
                         (FRAME-1-FIX '((I . 1) (RESULT . 1) (LOOP-BREAK)))))
             (FRAME-1->RESULT 0))
            (FRAME-1 (FRAME-1->I CHANGE-FRAME-1)
                     FRAME-1->RESULT
                     (FRAME-1->LOOP-BREAK CHANGE-FRAME-1))))
        (FR-1 (LET ((CHANGE-FRAME-1 FR-1)
                    (FRAME-1->LOOP-BREAK T))
                   (FRAME-1 (FRAME-1->I CHANGE-FRAME-1)
                            (FRAME-1->RESULT CHANGE-FRAME-1)
                            FRAME-1->LOOP-BREAK))))
       (COND (T FR-1)
             ((FRAME-1->LOOP-BREAK FR-1) FR-1)
             (T FR-1)))
      (REP-1 (+ -1 (NFIX J))
             (ENVIR-1-FIX L)
             (FRAME-1-FIX '((I . 1) (RESULT . 1) (LOOP-BREAK)))))))
   (NOT
    (FRAME-1->LOOP-BREAK
     (IF
      (NOT (EQUAL (NTH (+ -1 (+ -1 (NFIX J))
                          (ENVIR-1->LOOP-COUNTER-SHIFT (ENVIR-1-FIX L)))
                       (ENVIR-1->A (ENVIR-1-FIX L)))
                  (NTH (+ (+ -1 (NFIX J))
                          (ENVIR-1->LOOP-COUNTER-SHIFT (ENVIR-1-FIX L)))
                       (ENVIR-1->A (ENVIR-1-FIX L)))))
      (LET*
       ((FR-1
         (LET
            ((CHANGE-FRAME-1
                  (REP-1 (+ -1 (NFIX J))
                         (ENVIR-1-FIX L)
                         (FRAME-1-FIX '((I . 1) (RESULT . 1) (LOOP-BREAK)))))
             (FRAME-1->RESULT 0))
            (FRAME-1 (FRAME-1->I CHANGE-FRAME-1)
                     FRAME-1->RESULT
                     (FRAME-1->LOOP-BREAK CHANGE-FRAME-1))))
        (FR-1 (LET ((CHANGE-FRAME-1 FR-1)
                    (FRAME-1->LOOP-BREAK T))
                   (FRAME-1 (FRAME-1->I CHANGE-FRAME-1)
                            (FRAME-1->RESULT CHANGE-FRAME-1)
                            FRAME-1->LOOP-BREAK))))
       (COND (T FR-1)
             ((FRAME-1->LOOP-BREAK FR-1) FR-1)
             (T FR-1)))
      (REP-1 (+ -1 (NFIX J))
             (ENVIR-1-FIX L)
             (FRAME-1-FIX '((I . 1) (RESULT . 1) (LOOP-BREAK)))))))
   (:P A I (+ -1 (NFIX J))
       (ENVIR-1-FIX L)
       N))
  (:P A I J L N))
 (IMPLIES
  (AND
   (NOT (ZP (NFIX J)))
   (NOT (FRAME-1->LOOP-BREAK
             (REP-1 (+ -1 (NFIX J))
                    (ENVIR-1-FIX L)
                    (FRAME-1-FIX '((I . 1) (RESULT . 1) (LOOP-BREAK))))))
   (FRAME-1->LOOP-BREAK
    (IF
     (NOT (EQUAL (NTH (+ -1 (+ -1 (NFIX J))
                         (ENVIR-1->LOOP-COUNTER-SHIFT (ENVIR-1-FIX L)))
                      (ENVIR-1->A (ENVIR-1-FIX L)))
                 (NTH (+ (+ -1 (NFIX J))
                         (ENVIR-1->LOOP-COUNTER-SHIFT (ENVIR-1-FIX L)))
                      (ENVIR-1->A (ENVIR-1-FIX L)))))
     (LET*
      ((FR-1
        (LET
            ((CHANGE-FRAME-1
                  (REP-1 (+ -1 (NFIX J))
                         (ENVIR-1-FIX L)
                         (FRAME-1-FIX '((I . 1) (RESULT . 1) (LOOP-BREAK)))))
             (FRAME-1->RESULT 0))
            (FRAME-1 (FRAME-1->I CHANGE-FRAME-1)
                     FRAME-1->RESULT
                     (FRAME-1->LOOP-BREAK CHANGE-FRAME-1))))
       (FR-1 (LET ((CHANGE-FRAME-1 FR-1)
                   (FRAME-1->LOOP-BREAK T))
                  (FRAME-1 (FRAME-1->I CHANGE-FRAME-1)
                           (FRAME-1->RESULT CHANGE-FRAME-1)
                           FRAME-1->LOOP-BREAK))))
      (COND (T FR-1)
            ((FRAME-1->LOOP-BREAK FR-1) FR-1)
            (T FR-1)))
     (REP-1 (+ -1 (NFIX J))
            (ENVIR-1-FIX L)
            (FRAME-1-FIX '((I . 1) (RESULT . 1) (LOOP-BREAK))))))
   (:P A I (+ -1 (NFIX J))
       (ENVIR-1-FIX L)
       N))
  (:P A I J L N))
 (IMPLIES
      (AND (NOT (ZP (NFIX J)))
           (FRAME-1->LOOP-BREAK
                (REP-1 (+ -1 (NFIX J))
                       (ENVIR-1-FIX L)
                       (FRAME-1-FIX '((I . 1) (RESULT . 1) (LOOP-BREAK)))))
           (:P A I (+ -1 (NFIX J))
               (ENVIR-1-FIX L)
               N))
      (:P A I J L N))
 (IMPLIES (ZP (NFIX J)) (:P A I J L N))).
This induction is justified by the same argument used to admit REP-1.
Note, however, that the unmeasured variable L is being instantiated.
When applied to the goal at hand the above induction scheme produces
22 nontautological subgoals.

Subgoal *1.1/22
(IMPLIES
 (AND
  (NOT (ZP (NFIX J)))
  (NOT (FRAME-1->LOOP-BREAK
            (REP-1 (+ -1 (NFIX J))
                   (ENVIR-1-FIX L)
                   (FRAME-1-FIX '((I . 1) (RESULT . 1) (LOOP-BREAK))))))
  (NOT
   (FRAME-1->LOOP-BREAK
    (IF
     (NOT (EQUAL (NTH (+ -1 (+ -1 (NFIX J))
                         (ENVIR-1->LOOP-COUNTER-SHIFT (ENVIR-1-FIX L)))
                      (ENVIR-1->A (ENVIR-1-FIX L)))
                 (NTH (+ (+ -1 (NFIX J))
                         (ENVIR-1->LOOP-COUNTER-SHIFT (ENVIR-1-FIX L)))
                      (ENVIR-1->A (ENVIR-1-FIX L)))))
     (LET*
      ((FR-1
        (LET
            ((CHANGE-FRAME-1
                  (REP-1 (+ -1 (NFIX J))
                         (ENVIR-1-FIX L)
                         (FRAME-1-FIX '((I . 1) (RESULT . 1) (LOOP-BREAK)))))
             (FRAME-1->RESULT 0))
            (FRAME-1 (FRAME-1->I CHANGE-FRAME-1)
                     FRAME-1->RESULT
                     (FRAME-1->LOOP-BREAK CHANGE-FRAME-1))))
       (FR-1 (LET ((CHANGE-FRAME-1 FR-1)
                   (FRAME-1->LOOP-BREAK T))
                  (FRAME-1 (FRAME-1->I CHANGE-FRAME-1)
                           (FRAME-1->RESULT CHANGE-FRAME-1)
                           FRAME-1->LOOP-BREAK))))
      (COND (T FR-1)
            ((FRAME-1->LOOP-BREAK FR-1) FR-1)
            (T FR-1)))
     (REP-1 (+ -1 (NFIX J))
            (ENVIR-1-FIX L)
            (FRAME-1-FIX '((I . 1) (RESULT . 1) (LOOP-BREAK)))))))
  (NOT
   (FRAME-1->LOOP-BREAK
    (IF
     (NOT (EQUAL (NTH (+ -1 (+ -1 (NFIX J))
                         (ENVIR-1->LOOP-COUNTER-SHIFT (ENVIR-1-FIX L)))
                      (ENVIR-1->A (ENVIR-1-FIX L)))
                 (NTH (+ (+ -1 (NFIX J))
                         (ENVIR-1->LOOP-COUNTER-SHIFT (ENVIR-1-FIX L)))
                      (ENVIR-1->A (ENVIR-1-FIX L)))))
     (LET*
      ((FR-1
        (LET
            ((CHANGE-FRAME-1
                  (REP-1 (+ -1 (NFIX J))
                         (ENVIR-1-FIX L)
                         (FRAME-1-FIX '((I . 1) (RESULT . 1) (LOOP-BREAK)))))
             (FRAME-1->RESULT 0))
            (FRAME-1 (FRAME-1->I CHANGE-FRAME-1)
                     FRAME-1->RESULT
                     (FRAME-1->LOOP-BREAK CHANGE-FRAME-1))))
       (FR-1 (LET ((CHANGE-FRAME-1 FR-1)
                   (FRAME-1->LOOP-BREAK T))
                  (FRAME-1 (FRAME-1->I CHANGE-FRAME-1)
                           (FRAME-1->RESULT CHANGE-FRAME-1)
                           FRAME-1->LOOP-BREAK))))
      (COND (T FR-1)
            ((FRAME-1->LOOP-BREAK FR-1) FR-1)
            (T FR-1)))
     (REP-1 (+ -1 (NFIX J))
            (ENVIR-1-FIX L)
            (FRAME-1-FIX '((I . 1) (RESULT . 1) (LOOP-BREAK)))))))
  (NOT (FRAME-1->LOOP-BREAK (REP-1 (+ -1 (NFIX J))
                                   (ENVIR-1-FIX L)
                                   '((I . 1) (RESULT . 1) (LOOP-BREAK)))))
  (INTEGERP I)
  (< 0 I)
  L (TRUE-LISTP L)
  (INTEGERP J)
  (EQUAL (FRAME-1->RESULT (REP-1 J
                                 L '((I . 1) (RESULT . 1) (LOOP-BREAK))))
         1)
  (EQUAL (ELEMENT-EQ 0 J A) 1)
  (INTEGER-LISTP A)
  (INTEGERP N)
  (<= 0 N)
  (< 0 N)
  (<= N (LEN A))
  (NOT (EQUAL (NTH J A) (NTH I A))))
 (NOT (FRAME-1->LOOP-BREAK (REP-1 J L
                                  '((I . 1) (RESULT . 1) (LOOP-BREAK)))))).
#<\<0( DEFTHM VERIFICATION-CONDITION-1 ...)
c  0 Goal PUSH *1
++++++++++++++++++++++++++++++
c  2 *1 INDUCT
   1 |  Subgoal *1/2 preprocess
   2 |  |  Subgoal *1/2' simp
   7 |  |  |  Subgoal *1/2.2 simp
   1 |  |  |  |  Subgoal *1/2.2.5 simp
   1 |  |  |  |  |  Subgoal *1/2.2.5' simp
c  1 |  |  |  |  |  |  Subgoal *1/2.2.5'' GEN
   1 |  |  |  |  |  |  |  Subgoal *1/2.2.5''' simp
c  0 |  |  |  |  |  |  |  |  Subgoal *1/2.2.5'4' PUSH *1.1
++++++++++++++++++++++++++++++
c 22 *1.1 INDUCT
   1 |  Subgoal *1.1/22 preprocess
     |  |  <1 subgoal>
     |  <21 more subgoals>
#>\>
By the :congruence rules ENVIR-1->A$INLINE-ENVIR-1-EQUIV-CONGRUENCE-ON-X,
ENVIR-1->LOOP-COUNTER-SHIFT$INLINE-ENVIR-1-EQUIV-CONGRUENCE-ON-X and
NAT-EQUIV-IMPLIES-EQUAL-ZP-1, the :executable-counterpart of 
FRAME-1-FIX$INLINE and the simple :rewrite rules ASSOCIATIVITY-OF-+,
ENVIR-1-FIX-UNDER-ENVIR-1-EQUIV and NFIX-UNDER-NAT-EQUIV we reduce
the conjecture to

Subgoal *1.1/22'
(IMPLIES
 (AND
  (NOT (ZP J))
  (NOT (FRAME-1->LOOP-BREAK (REP-1 (+ -1 (NFIX J))
                                   (ENVIR-1-FIX L)
                                   '((I . 1) (RESULT . 1) (LOOP-BREAK)))))
  (NOT
   (FRAME-1->LOOP-BREAK
    (IF
     (NOT (EQUAL (NTH (+ -1 -1 (NFIX J)
                         (ENVIR-1->LOOP-COUNTER-SHIFT L))
                      (ENVIR-1->A L))
                 (NTH (+ -1 (NFIX J)
                         (ENVIR-1->LOOP-COUNTER-SHIFT L))
                      (ENVIR-1->A L))))
     (LET
      ((CHANGE-FRAME-1
          (LET ((CHANGE-FRAME-1 (REP-1 (+ -1 (NFIX J))
                                       (ENVIR-1-FIX L)
                                       '((I . 1) (RESULT . 1) (LOOP-BREAK))))
                (FRAME-1->RESULT 0))
               (FRAME-1 (FRAME-1->I CHANGE-FRAME-1)
                        FRAME-1->RESULT
                        (FRAME-1->LOOP-BREAK CHANGE-FRAME-1))))
       (FRAME-1->LOOP-BREAK T))
      (FRAME-1 (FRAME-1->I CHANGE-FRAME-1)
               (FRAME-1->RESULT CHANGE-FRAME-1)
               FRAME-1->LOOP-BREAK))
     (REP-1 (+ -1 (NFIX J))
            (ENVIR-1-FIX L)
            '((I . 1) (RESULT . 1) (LOOP-BREAK))))))
  (INTEGERP I)
  (< 0 I)
  L (TRUE-LISTP L)
  (INTEGERP J)
  (EQUAL (FRAME-1->RESULT (REP-1 J
                                 L '((I . 1) (RESULT . 1) (LOOP-BREAK))))
         1)
  (EQUAL (ELEMENT-EQ 0 J A) 1)
  (INTEGER-LISTP A)
  (INTEGERP N)
  (<= 0 N)
  (< 0 N)
  (<= N (LEN A))
  (NOT (EQUAL (NTH J A) (NTH I A))))
 (NOT (FRAME-1->LOOP-BREAK (REP-1 J L
                                  '((I . 1) (RESULT . 1) (LOOP-BREAK)))))).
#<\<0( DEFTHM VERIFICATION-CONDITION-1 ...)
c  0 Goal PUSH *1
++++++++++++++++++++++++++++++
c  2 *1 INDUCT
   1 |  Subgoal *1/2 preprocess
   2 |  |  Subgoal *1/2' simp
   7 |  |  |  Subgoal *1/2.2 simp
   1 |  |  |  |  Subgoal *1/2.2.5 simp
   1 |  |  |  |  |  Subgoal *1/2.2.5' simp
c  1 |  |  |  |  |  |  Subgoal *1/2.2.5'' GEN
   1 |  |  |  |  |  |  |  Subgoal *1/2.2.5''' simp
c  0 |  |  |  |  |  |  |  |  Subgoal *1/2.2.5'4' PUSH *1.1
++++++++++++++++++++++++++++++
c 22 *1.1 INDUCT
   1 |  Subgoal *1.1/22 preprocess
   3 |  |  Subgoal *1.1/22' simp
     |  |  |  <3 subgoals>
     |  <21 more subgoals>
#>\>
This simplifies, using the :compound-recognizer rule ZP-COMPOUND-RECOGNIZER,
the :congruence rules FRAME-1-IFF-CONGRUENCE-ON-LOOP-BREAK, 
FRAME-1-INT-EQUIV-CONGRUENCE-ON-I and IFF-IMPLIES-EQUAL-BOOL-FIX-1,
the :definitions NFIX, NOT (if-intro), REP-1 (if-intro) and SYNP, the
:executable-counterparts of BINARY-+, BOOL-FIX$INLINE, FRAME-1-FIX$INLINE
and IFIX, primitive type reasoning, the :rewrite rules COMMUTATIVITY-2-OF-+,
COMMUTATIVITY-OF-+, ENVIR-1->A$INLINE-OF-ENVIR-1-FIX-X, 
ENVIR-1->LOOP-COUNTER-SHIFT$INLINE-OF-ENVIR-1-FIX-X, FOLD-CONSTS-IN-+,
FRAME-1->I-OF-FRAME-1, FRAME-1->LOOP-BREAK-OF-FRAME-1, 
FRAME-1->RESULT-OF-FRAME-1 and IFIX-UNDER-INT-EQUIV and the :type-
prescription rule FRAME-1->LOOP-BREAK$INLINE, to the following three
conjectures.

Subgoal *1.1/22.3
(IMPLIES
 (AND
     (NOT (ZP J))
     (NOT (FRAME-1->LOOP-BREAK (REP-1 (+ -1 (NFIX J))
                                      (ENVIR-1-FIX L)
                                      '((I . 1) (RESULT . 1) (LOOP-BREAK)))))
     (EQUAL (NTH (+ -2 J (ENVIR-1->LOOP-COUNTER-SHIFT L))
                 (ENVIR-1->A L))
            (NTH (+ -1 J (ENVIR-1->LOOP-COUNTER-SHIFT L))
                 (ENVIR-1->A L)))
     (INTEGERP I)
     (< 0 I)
     L (TRUE-LISTP L)
     (FRAME-1->LOOP-BREAK (REP-1 (+ -1 J)
                                 (ENVIR-1-FIX L)
                                 '((I . 1) (RESULT . 1) (LOOP-BREAK))))
     (EQUAL (FRAME-1->RESULT (REP-1 (+ -1 J)
                                    (ENVIR-1-FIX L)
                                    '((I . 1) (RESULT . 1) (LOOP-BREAK))))
            1)
     (EQUAL (ELEMENT-EQ 0 J A) 1)
     (INTEGER-LISTP A)
     (INTEGERP N)
     (<= 0 N)
     (< 0 N)
     (<= N (LEN A)))
 (EQUAL (NTH J A) (NTH I A))).
#<\<0( DEFTHM VERIFICATION-CONDITION-1 ...)
c  0 Goal PUSH *1
++++++++++++++++++++++++++++++
c  2 *1 INDUCT
   1 |  Subgoal *1/2 preprocess
   2 |  |  Subgoal *1/2' simp
   7 |  |  |  Subgoal *1/2.2 simp
   1 |  |  |  |  Subgoal *1/2.2.5 simp
   1 |  |  |  |  |  Subgoal *1/2.2.5' simp
c  1 |  |  |  |  |  |  Subgoal *1/2.2.5'' GEN
   1 |  |  |  |  |  |  |  Subgoal *1/2.2.5''' simp
c  0 |  |  |  |  |  |  |  |  Subgoal *1/2.2.5'4' PUSH *1.1
++++++++++++++++++++++++++++++
c 22 *1.1 INDUCT
   1 |  Subgoal *1.1/22 preprocess
   3 |  |  Subgoal *1.1/22' simp
     |  |  |  <2 more subgoals>
     |  <21 more subgoals>
#>\>
But simplification reduces this to T, using the :compound-recognizer
rule ZP-COMPOUND-RECOGNIZER, the :definition NFIX, primitive type reasoning
and the :type-prescription rule FRAME-1->LOOP-BREAK$INLINE.

Subgoal *1.1/22.2
(IMPLIES
 (AND
  (NOT (ZP J))
  (NOT (FRAME-1->LOOP-BREAK (REP-1 (+ -1 (NFIX J))
                                   (ENVIR-1-FIX L)
                                   '((I . 1) (RESULT . 1) (LOOP-BREAK)))))
  (NOT
      (FRAME-1->LOOP-BREAK
           (FRAME-1 (FRAME-1->I (REP-1 (+ -1 (NFIX J))
                                       (ENVIR-1-FIX L)
                                       '((I . 1) (RESULT . 1) (LOOP-BREAK))))
                    0 T)))
  (INTEGERP I)
  (< 0 I)
  L (TRUE-LISTP L)
  (FRAME-1->LOOP-BREAK (REP-1 (+ -1 J)
                              (ENVIR-1-FIX L)
                              '((I . 1) (RESULT . 1) (LOOP-BREAK))))
  (EQUAL (FRAME-1->RESULT (REP-1 (+ -1 J)
                                 (ENVIR-1-FIX L)
                                 '((I . 1) (RESULT . 1) (LOOP-BREAK))))
         1)
  (EQUAL (ELEMENT-EQ 0 J A) 1)
  (INTEGER-LISTP A)
  (INTEGERP N)
  (<= 0 N)
  (< 0 N)
  (<= N (LEN A)))
 (EQUAL (NTH J A) (NTH I A))).
#<\<0( DEFTHM VERIFICATION-CONDITION-1 ...)
c  0 Goal PUSH *1
++++++++++++++++++++++++++++++
c  2 *1 INDUCT
   1 |  Subgoal *1/2 preprocess
   2 |  |  Subgoal *1/2' simp
   7 |  |  |  Subgoal *1/2.2 simp
   1 |  |  |  |  Subgoal *1/2.2.5 simp
   1 |  |  |  |  |  Subgoal *1/2.2.5' simp
c  1 |  |  |  |  |  |  Subgoal *1/2.2.5'' GEN
   1 |  |  |  |  |  |  |  Subgoal *1/2.2.5''' simp
c  0 |  |  |  |  |  |  |  |  Subgoal *1/2.2.5'4' PUSH *1.1
++++++++++++++++++++++++++++++
c 22 *1.1 INDUCT
   1 |  Subgoal *1.1/22 preprocess
   3 |  |  Subgoal *1.1/22' simp
     |  |  |  <1 more subgoal>
     |  <21 more subgoals>
#>\>
But we reduce the conjecture to T, by the :executable-counterpart of
BOOL-FIX$INLINE and the simple :rewrite rule FRAME-1->LOOP-BREAK-OF-FRAME-1.

Subgoal *1.1/22.1
(IMPLIES
 (AND
  (NOT (ZP J))
  (NOT (FRAME-1->LOOP-BREAK (REP-1 (+ -1 (NFIX J))
                                   (ENVIR-1-FIX L)
                                   '((I . 1) (RESULT . 1) (LOOP-BREAK)))))
  (NOT
      (FRAME-1->LOOP-BREAK
           (FRAME-1 (FRAME-1->I (REP-1 (+ -1 (NFIX J))
                                       (ENVIR-1-FIX L)
                                       '((I . 1) (RESULT . 1) (LOOP-BREAK))))
                    0 T)))
  (INTEGERP I)
  (< 0 I)
  L (TRUE-LISTP L)
  (NOT (FRAME-1->LOOP-BREAK (REP-1 (+ -1 J)
                                   (ENVIR-1-FIX L)
                                   '((I . 1) (RESULT . 1) (LOOP-BREAK)))))
  (NOT (EQUAL (NTH (+ -2 J (ENVIR-1->LOOP-COUNTER-SHIFT L))
                   (ENVIR-1->A L))
              (NTH (+ -1 J (ENVIR-1->LOOP-COUNTER-SHIFT L))
                   (ENVIR-1->A L))))
  (EQUAL
   (FRAME-1->RESULT
    (LET
     ((FR-1
           (FRAME-1 (FRAME-1->I (REP-1 (+ -1 J)
                                       (ENVIR-1-FIX L)
                                       '((I . 1) (RESULT . 1) (LOOP-BREAK))))
                    0 T)))
     (IF (FRAME-1->LOOP-BREAK FR-1)
         FR-1
         (LET ((FR-1 (LET ((CHANGE-FRAME-1 FR-1)
                           (FRAME-1->I (+ (FRAME-1->I FR-1) 1)))
                          (FRAME-1 FRAME-1->I
                                   (FRAME-1->RESULT CHANGE-FRAME-1)
                                   (FRAME-1->LOOP-BREAK CHANGE-FRAME-1)))))
              FR-1))))
   1)
  (EQUAL (ELEMENT-EQ 0 J A) 1)
  (INTEGER-LISTP A)
  (INTEGERP N)
  (<= 0 N)
  (< 0 N)
  (<= N (LEN A)))
 (EQUAL (NTH J A) (NTH I A))).
#<\<0( DEFTHM VERIFICATION-CONDITION-1 ...)
c  0 Goal PUSH *1
++++++++++++++++++++++++++++++
c  2 *1 INDUCT
   1 |  Subgoal *1/2 preprocess
   2 |  |  Subgoal *1/2' simp
   7 |  |  |  Subgoal *1/2.2 simp
   1 |  |  |  |  Subgoal *1/2.2.5 simp
   1 |  |  |  |  |  Subgoal *1/2.2.5' simp
c  1 |  |  |  |  |  |  Subgoal *1/2.2.5'' GEN
   1 |  |  |  |  |  |  |  Subgoal *1/2.2.5''' simp
c  0 |  |  |  |  |  |  |  |  Subgoal *1/2.2.5'4' PUSH *1.1
++++++++++++++++++++++++++++++
c 22 *1.1 INDUCT
     |  <21 more subgoals>
#>\>
But we reduce the conjecture to T, by the :executable-counterpart of
BOOL-FIX$INLINE and the simple :rewrite rule FRAME-1->LOOP-BREAK-OF-FRAME-1.

Subgoal *1.1/21
(IMPLIES
 (AND
  (NOT (ZP (NFIX J)))
  (NOT (FRAME-1->LOOP-BREAK
            (REP-1 (+ -1 (NFIX J))
                   (ENVIR-1-FIX L)
                   (FRAME-1-FIX '((I . 1) (RESULT . 1) (LOOP-BREAK))))))
  (NOT
   (FRAME-1->LOOP-BREAK
    (IF
     (NOT (EQUAL (NTH (+ -1 (+ -1 (NFIX J))
                         (ENVIR-1->LOOP-COUNTER-SHIFT (ENVIR-1-FIX L)))
                      (ENVIR-1->A (ENVIR-1-FIX L)))
                 (NTH (+ (+ -1 (NFIX J))
                         (ENVIR-1->LOOP-COUNTER-SHIFT (ENVIR-1-FIX L)))
                      (ENVIR-1->A (ENVIR-1-FIX L)))))
     (LET*
      ((FR-1
        (LET
            ((CHANGE-FRAME-1
                  (REP-1 (+ -1 (NFIX J))
                         (ENVIR-1-FIX L)
                         (FRAME-1-FIX '((I . 1) (RESULT . 1) (LOOP-BREAK)))))
             (FRAME-1->RESULT 0))
            (FRAME-1 (FRAME-1->I CHANGE-FRAME-1)
                     FRAME-1->RESULT
                     (FRAME-1->LOOP-BREAK CHANGE-FRAME-1))))
       (FR-1 (LET ((CHANGE-FRAME-1 FR-1)
                   (FRAME-1->LOOP-BREAK T))
                  (FRAME-1 (FRAME-1->I CHANGE-FRAME-1)
                           (FRAME-1->RESULT CHANGE-FRAME-1)
                           FRAME-1->LOOP-BREAK))))
      (COND (T FR-1)
            ((FRAME-1->LOOP-BREAK FR-1) FR-1)
            (T FR-1)))
     (REP-1 (+ -1 (NFIX J))
            (ENVIR-1-FIX L)
            (FRAME-1-FIX '((I . 1) (RESULT . 1) (LOOP-BREAK)))))))
  (NOT
   (FRAME-1->LOOP-BREAK
    (IF
     (NOT (EQUAL (NTH (+ -1 (+ -1 (NFIX J))
                         (ENVIR-1->LOOP-COUNTER-SHIFT (ENVIR-1-FIX L)))
                      (ENVIR-1->A (ENVIR-1-FIX L)))
                 (NTH (+ (+ -1 (NFIX J))
                         (ENVIR-1->LOOP-COUNTER-SHIFT (ENVIR-1-FIX L)))
                      (ENVIR-1->A (ENVIR-1-FIX L)))))
     (LET*
      ((FR-1
        (LET
            ((CHANGE-FRAME-1
                  (REP-1 (+ -1 (NFIX J))
                         (ENVIR-1-FIX L)
                         (FRAME-1-FIX '((I . 1) (RESULT . 1) (LOOP-BREAK)))))
             (FRAME-1->RESULT 0))
            (FRAME-1 (FRAME-1->I CHANGE-FRAME-1)
                     FRAME-1->RESULT
                     (FRAME-1->LOOP-BREAK CHANGE-FRAME-1))))
       (FR-1 (LET ((CHANGE-FRAME-1 FR-1)
                   (FRAME-1->LOOP-BREAK T))
                  (FRAME-1 (FRAME-1->I CHANGE-FRAME-1)
                           (FRAME-1->RESULT CHANGE-FRAME-1)
                           FRAME-1->LOOP-BREAK))))
      (COND (T FR-1)
            ((FRAME-1->LOOP-BREAK FR-1) FR-1)
            (T FR-1)))
     (REP-1 (+ -1 (NFIX J))
            (ENVIR-1-FIX L)
            (FRAME-1-FIX '((I . 1) (RESULT . 1) (LOOP-BREAK)))))))
  (EQUAL (NTH (+ -1 (NFIX J)) A)
         (NTH I A))
  (INTEGERP I)
  (< 0 I)
  L (TRUE-LISTP L)
  (INTEGERP J)
  (EQUAL (FRAME-1->RESULT (REP-1 J
                                 L '((I . 1) (RESULT . 1) (LOOP-BREAK))))
         1)
  (EQUAL (ELEMENT-EQ 0 J A) 1)
  (INTEGER-LISTP A)
  (INTEGERP N)
  (<= 0 N)
  (< 0 N)
  (<= N (LEN A))
  (NOT (EQUAL (NTH J A) (NTH I A))))
 (NOT (FRAME-1->LOOP-BREAK (REP-1 J L
                                  '((I . 1) (RESULT . 1) (LOOP-BREAK)))))).
#<\<0( DEFTHM VERIFICATION-CONDITION-1 ...)
c  0 Goal PUSH *1
++++++++++++++++++++++++++++++
c  2 *1 INDUCT
   1 |  Subgoal *1/2 preprocess
   2 |  |  Subgoal *1/2' simp
   7 |  |  |  Subgoal *1/2.2 simp
   1 |  |  |  |  Subgoal *1/2.2.5 simp
   1 |  |  |  |  |  Subgoal *1/2.2.5' simp
c  1 |  |  |  |  |  |  Subgoal *1/2.2.5'' GEN
   1 |  |  |  |  |  |  |  Subgoal *1/2.2.5''' simp
c  0 |  |  |  |  |  |  |  |  Subgoal *1/2.2.5'4' PUSH *1.1
++++++++++++++++++++++++++++++
c 22 *1.1 INDUCT
   1 |  Subgoal *1.1/21 preprocess
     |  |  <1 subgoal>
     |  <20 more subgoals>
#>\>
By the :congruence rules ENVIR-1->A$INLINE-ENVIR-1-EQUIV-CONGRUENCE-ON-X,
ENVIR-1->LOOP-COUNTER-SHIFT$INLINE-ENVIR-1-EQUIV-CONGRUENCE-ON-X and
NAT-EQUIV-IMPLIES-EQUAL-ZP-1, the :executable-counterpart of 
FRAME-1-FIX$INLINE and the simple :rewrite rules ASSOCIATIVITY-OF-+,
ENVIR-1-FIX-UNDER-ENVIR-1-EQUIV and NFIX-UNDER-NAT-EQUIV we reduce
the conjecture to

Subgoal *1.1/21'
(IMPLIES
 (AND
  (NOT (ZP J))
  (NOT (FRAME-1->LOOP-BREAK (REP-1 (+ -1 (NFIX J))
                                   (ENVIR-1-FIX L)
                                   '((I . 1) (RESULT . 1) (LOOP-BREAK)))))
  (NOT
   (FRAME-1->LOOP-BREAK
    (IF
     (NOT (EQUAL (NTH (+ -1 -1 (NFIX J)
                         (ENVIR-1->LOOP-COUNTER-SHIFT L))
                      (ENVIR-1->A L))
                 (NTH (+ -1 (NFIX J)
                         (ENVIR-1->LOOP-COUNTER-SHIFT L))
                      (ENVIR-1->A L))))
     (LET
      ((CHANGE-FRAME-1
          (LET ((CHANGE-FRAME-1 (REP-1 (+ -1 (NFIX J))
                                       (ENVIR-1-FIX L)
                                       '((I . 1) (RESULT . 1) (LOOP-BREAK))))
                (FRAME-1->RESULT 0))
               (FRAME-1 (FRAME-1->I CHANGE-FRAME-1)
                        FRAME-1->RESULT
                        (FRAME-1->LOOP-BREAK CHANGE-FRAME-1))))
       (FRAME-1->LOOP-BREAK T))
      (FRAME-1 (FRAME-1->I CHANGE-FRAME-1)
               (FRAME-1->RESULT CHANGE-FRAME-1)
               FRAME-1->LOOP-BREAK))
     (REP-1 (+ -1 (NFIX J))
            (ENVIR-1-FIX L)
            '((I . 1) (RESULT . 1) (LOOP-BREAK))))))
  (EQUAL (NTH (+ -1 (NFIX J)) A)
         (NTH I A))
  (INTEGERP I)
  (< 0 I)
  L (TRUE-LISTP L)
  (INTEGERP J)
  (EQUAL (FRAME-1->RESULT (REP-1 J
                                 L '((I . 1) (RESULT . 1) (LOOP-BREAK))))
         1)
  (EQUAL (ELEMENT-EQ 0 J A) 1)
  (INTEGER-LISTP A)
  (INTEGERP N)
  (<= 0 N)
  (< 0 N)
  (<= N (LEN A))
  (NOT (EQUAL (NTH J A) (NTH I A))))
 (NOT (FRAME-1->LOOP-BREAK (REP-1 J L
                                  '((I . 1) (RESULT . 1) (LOOP-BREAK)))))).
#<\<0( DEFTHM VERIFICATION-CONDITION-1 ...)
c  0 Goal PUSH *1
++++++++++++++++++++++++++++++
c  2 *1 INDUCT
   1 |  Subgoal *1/2 preprocess
   2 |  |  Subgoal *1/2' simp
   7 |  |  |  Subgoal *1/2.2 simp
   1 |  |  |  |  Subgoal *1/2.2.5 simp
   1 |  |  |  |  |  Subgoal *1/2.2.5' simp
c  1 |  |  |  |  |  |  Subgoal *1/2.2.5'' GEN
   1 |  |  |  |  |  |  |  Subgoal *1/2.2.5''' simp
c  0 |  |  |  |  |  |  |  |  Subgoal *1/2.2.5'4' PUSH *1.1
++++++++++++++++++++++++++++++
c 22 *1.1 INDUCT
     |  <20 more subgoals>
#>\>
But simplification reduces this to T, using the :compound-recognizer
rules NATP-COMPOUND-RECOGNIZER and ZP-COMPOUND-RECOGNIZER, the :congruence
rules FRAME-1-IFF-CONGRUENCE-ON-LOOP-BREAK and 
FRAME-1-INT-EQUIV-CONGRUENCE-ON-I, the :definitions ELEMENT-EQ, NFIX,
NOT, REP-1 and SYNP, the :executable-counterparts of BINARY-+, EQUAL,
FRAME-1-FIX$INLINE, IFIX and NATP, primitive type reasoning and the
:rewrite rules COMMUTATIVITY-2-OF-+, COMMUTATIVITY-OF-+, 
ENVIR-1->A$INLINE-OF-ENVIR-1-FIX-X, 
ENVIR-1->LOOP-COUNTER-SHIFT$INLINE-OF-ENVIR-1-FIX-X, FOLD-CONSTS-IN-+,
FRAME-1->I-OF-FRAME-1, FRAME-1->RESULT-OF-FRAME-1 and IFIX-UNDER-INT-EQUIV.

Subgoal *1.1/20
(IMPLIES
 (AND
  (NOT (ZP (NFIX J)))
  (NOT (FRAME-1->LOOP-BREAK
            (REP-1 (+ -1 (NFIX J))
                   (ENVIR-1-FIX L)
                   (FRAME-1-FIX '((I . 1) (RESULT . 1) (LOOP-BREAK))))))
  (NOT
   (FRAME-1->LOOP-BREAK
    (IF
     (NOT (EQUAL (NTH (+ -1 (+ -1 (NFIX J))
                         (ENVIR-1->LOOP-COUNTER-SHIFT (ENVIR-1-FIX L)))
                      (ENVIR-1->A (ENVIR-1-FIX L)))
                 (NTH (+ (+ -1 (NFIX J))
                         (ENVIR-1->LOOP-COUNTER-SHIFT (ENVIR-1-FIX L)))
                      (ENVIR-1->A (ENVIR-1-FIX L)))))
     (LET*
      ((FR-1
        (LET
            ((CHANGE-FRAME-1
                  (REP-1 (+ -1 (NFIX J))
                         (ENVIR-1-FIX L)
                         (FRAME-1-FIX '((I . 1) (RESULT . 1) (LOOP-BREAK)))))
             (FRAME-1->RESULT 0))
            (FRAME-1 (FRAME-1->I CHANGE-FRAME-1)
                     FRAME-1->RESULT
                     (FRAME-1->LOOP-BREAK CHANGE-FRAME-1))))
       (FR-1 (LET ((CHANGE-FRAME-1 FR-1)
                   (FRAME-1->LOOP-BREAK T))
                  (FRAME-1 (FRAME-1->I CHANGE-FRAME-1)
                           (FRAME-1->RESULT CHANGE-FRAME-1)
                           FRAME-1->LOOP-BREAK))))
      (COND (T FR-1)
            ((FRAME-1->LOOP-BREAK FR-1) FR-1)
            (T FR-1)))
     (REP-1 (+ -1 (NFIX J))
            (ENVIR-1-FIX L)
            (FRAME-1-FIX '((I . 1) (RESULT . 1) (LOOP-BREAK)))))))
  (NOT
   (FRAME-1->LOOP-BREAK
    (IF
     (NOT (EQUAL (NTH (+ -1 (+ -1 (NFIX J))
                         (ENVIR-1->LOOP-COUNTER-SHIFT (ENVIR-1-FIX L)))
                      (ENVIR-1->A (ENVIR-1-FIX L)))
                 (NTH (+ (+ -1 (NFIX J))
                         (ENVIR-1->LOOP-COUNTER-SHIFT (ENVIR-1-FIX L)))
                      (ENVIR-1->A (ENVIR-1-FIX L)))))
     (LET*
      ((FR-1
        (LET
            ((CHANGE-FRAME-1
                  (REP-1 (+ -1 (NFIX J))
                         (ENVIR-1-FIX L)
                         (FRAME-1-FIX '((I . 1) (RESULT . 1) (LOOP-BREAK)))))
             (FRAME-1->RESULT 0))
            (FRAME-1 (FRAME-1->I CHANGE-FRAME-1)
                     FRAME-1->RESULT
                     (FRAME-1->LOOP-BREAK CHANGE-FRAME-1))))
       (FR-1 (LET ((CHANGE-FRAME-1 FR-1)
                   (FRAME-1->LOOP-BREAK T))
                  (FRAME-1 (FRAME-1->I CHANGE-FRAME-1)
                           (FRAME-1->RESULT CHANGE-FRAME-1)
                           FRAME-1->LOOP-BREAK))))
      (COND (T FR-1)
            ((FRAME-1->LOOP-BREAK FR-1) FR-1)
            (T FR-1)))
     (REP-1 (+ -1 (NFIX J))
            (ENVIR-1-FIX L)
            (FRAME-1-FIX '((I . 1) (RESULT . 1) (LOOP-BREAK)))))))
  (NOT (EQUAL (ELEMENT-EQ 0 (+ -1 (NFIX J)) A)
              1))
  (INTEGERP I)
  (< 0 I)
  L (TRUE-LISTP L)
  (INTEGERP J)
  (EQUAL (FRAME-1->RESULT (REP-1 J
                                 L '((I . 1) (RESULT . 1) (LOOP-BREAK))))
         1)
  (EQUAL (ELEMENT-EQ 0 J A) 1)
  (INTEGER-LISTP A)
  (INTEGERP N)
  (<= 0 N)
  (< 0 N)
  (<= N (LEN A))
  (NOT (EQUAL (NTH J A) (NTH I A))))
 (NOT (FRAME-1->LOOP-BREAK (REP-1 J L
                                  '((I . 1) (RESULT . 1) (LOOP-BREAK)))))).
#<\<0( DEFTHM VERIFICATION-CONDITION-1 ...)
c  0 Goal PUSH *1
++++++++++++++++++++++++++++++
c  2 *1 INDUCT
   1 |  Subgoal *1/2 preprocess
   2 |  |  Subgoal *1/2' simp
   7 |  |  |  Subgoal *1/2.2 simp
   1 |  |  |  |  Subgoal *1/2.2.5 simp
   1 |  |  |  |  |  Subgoal *1/2.2.5' simp
c  1 |  |  |  |  |  |  Subgoal *1/2.2.5'' GEN
   1 |  |  |  |  |  |  |  Subgoal *1/2.2.5''' simp
c  0 |  |  |  |  |  |  |  |  Subgoal *1/2.2.5'4' PUSH *1.1
++++++++++++++++++++++++++++++
c 22 *1.1 INDUCT
   1 |  Subgoal *1.1/20 preprocess
     |  |  <1 subgoal>
     |  <19 more subgoals>
#>\>
By the :congruence rules ENVIR-1->A$INLINE-ENVIR-1-EQUIV-CONGRUENCE-ON-X,
ENVIR-1->LOOP-COUNTER-SHIFT$INLINE-ENVIR-1-EQUIV-CONGRUENCE-ON-X and
NAT-EQUIV-IMPLIES-EQUAL-ZP-1, the :executable-counterpart of 
FRAME-1-FIX$INLINE and the simple :rewrite rules ASSOCIATIVITY-OF-+,
ENVIR-1-FIX-UNDER-ENVIR-1-EQUIV and NFIX-UNDER-NAT-EQUIV we reduce
the conjecture to

Subgoal *1.1/20'
(IMPLIES
 (AND
  (NOT (ZP J))
  (NOT (FRAME-1->LOOP-BREAK (REP-1 (+ -1 (NFIX J))
                                   (ENVIR-1-FIX L)
                                   '((I . 1) (RESULT . 1) (LOOP-BREAK)))))
  (NOT
   (FRAME-1->LOOP-BREAK
    (IF
     (NOT (EQUAL (NTH (+ -1 -1 (NFIX J)
                         (ENVIR-1->LOOP-COUNTER-SHIFT L))
                      (ENVIR-1->A L))
                 (NTH (+ -1 (NFIX J)
                         (ENVIR-1->LOOP-COUNTER-SHIFT L))
                      (ENVIR-1->A L))))
     (LET
      ((CHANGE-FRAME-1
          (LET ((CHANGE-FRAME-1 (REP-1 (+ -1 (NFIX J))
                                       (ENVIR-1-FIX L)
                                       '((I . 1) (RESULT . 1) (LOOP-BREAK))))
                (FRAME-1->RESULT 0))
               (FRAME-1 (FRAME-1->I CHANGE-FRAME-1)
                        FRAME-1->RESULT
                        (FRAME-1->LOOP-BREAK CHANGE-FRAME-1))))
       (FRAME-1->LOOP-BREAK T))
      (FRAME-1 (FRAME-1->I CHANGE-FRAME-1)
               (FRAME-1->RESULT CHANGE-FRAME-1)
               FRAME-1->LOOP-BREAK))
     (REP-1 (+ -1 (NFIX J))
            (ENVIR-1-FIX L)
            '((I . 1) (RESULT . 1) (LOOP-BREAK))))))
  (NOT (EQUAL (ELEMENT-EQ 0 (+ -1 (NFIX J)) A)
              1))
  (INTEGERP I)
  (< 0 I)
  L (TRUE-LISTP L)
  (INTEGERP J)
  (EQUAL (FRAME-1->RESULT (REP-1 J
                                 L '((I . 1) (RESULT . 1) (LOOP-BREAK))))
         1)
  (EQUAL (ELEMENT-EQ 0 J A) 1)
  (INTEGER-LISTP A)
  (INTEGERP N)
  (<= 0 N)
  (< 0 N)
  (<= N (LEN A))
  (NOT (EQUAL (NTH J A) (NTH I A))))
 (NOT (FRAME-1->LOOP-BREAK (REP-1 J L
                                  '((I . 1) (RESULT . 1) (LOOP-BREAK)))))).
#<\<0( DEFTHM VERIFICATION-CONDITION-1 ...)
c  0 Goal PUSH *1
++++++++++++++++++++++++++++++
c  2 *1 INDUCT
   1 |  Subgoal *1/2 preprocess
   2 |  |  Subgoal *1/2' simp
   7 |  |  |  Subgoal *1/2.2 simp
   1 |  |  |  |  Subgoal *1/2.2.5 simp
   1 |  |  |  |  |  Subgoal *1/2.2.5' simp
c  1 |  |  |  |  |  |  Subgoal *1/2.2.5'' GEN
   1 |  |  |  |  |  |  |  Subgoal *1/2.2.5''' simp
c  0 |  |  |  |  |  |  |  |  Subgoal *1/2.2.5'4' PUSH *1.1
++++++++++++++++++++++++++++++
c 22 *1.1 INDUCT
   1 |  Subgoal *1.1/20 preprocess
   1 |  |  Subgoal *1.1/20' simp
     |  |  |  <1 subgoal>
     |  <19 more subgoals>
#>\>
This simplifies, using the :executable-counterpart of EQUAL, linear
arithmetic and the :type-prescription rule ELEMENT-EQ, to

Subgoal *1.1/20''
(IMPLIES
 (AND
  (EQUAL (ELEMENT-EQ 0 (+ -1 (NFIX J)) A)
         0)
  (NOT (ZP J))
  (NOT (FRAME-1->LOOP-BREAK (REP-1 (+ -1 (NFIX J))
                                   (ENVIR-1-FIX L)
                                   '((I . 1) (RESULT . 1) (LOOP-BREAK)))))
  (NOT
   (FRAME-1->LOOP-BREAK
    (IF
     (NOT (EQUAL (NTH (+ -1 -1 (NFIX J)
                         (ENVIR-1->LOOP-COUNTER-SHIFT L))
                      (ENVIR-1->A L))
                 (NTH (+ -1 (NFIX J)
                         (ENVIR-1->LOOP-COUNTER-SHIFT L))
                      (ENVIR-1->A L))))
     (LET
      ((CHANGE-FRAME-1
          (LET ((CHANGE-FRAME-1 (REP-1 (+ -1 (NFIX J))
                                       (ENVIR-1-FIX L)
                                       '((I . 1) (RESULT . 1) (LOOP-BREAK))))
                (FRAME-1->RESULT 0))
               (FRAME-1 (FRAME-1->I CHANGE-FRAME-1)
                        FRAME-1->RESULT
                        (FRAME-1->LOOP-BREAK CHANGE-FRAME-1))))
       (FRAME-1->LOOP-BREAK T))
      (FRAME-1 (FRAME-1->I CHANGE-FRAME-1)
               (FRAME-1->RESULT CHANGE-FRAME-1)
               FRAME-1->LOOP-BREAK))
     (REP-1 (+ -1 (NFIX J))
            (ENVIR-1-FIX L)
            '((I . 1) (RESULT . 1) (LOOP-BREAK))))))
  (INTEGERP I)
  (< 0 I)
  L (TRUE-LISTP L)
  (INTEGERP J)
  (EQUAL (FRAME-1->RESULT (REP-1 J
                                 L '((I . 1) (RESULT . 1) (LOOP-BREAK))))
         1)
  (EQUAL (ELEMENT-EQ 0 J A) 1)
  (INTEGER-LISTP A)
  (INTEGERP N)
  (<= 0 N)
  (< 0 N)
  (<= N (LEN A))
  (NOT (EQUAL (NTH J A) (NTH I A))))
 (NOT (FRAME-1->LOOP-BREAK (REP-1 J L
                                  '((I . 1) (RESULT . 1) (LOOP-BREAK)))))).
#<\<0( DEFTHM VERIFICATION-CONDITION-1 ...)
c  0 Goal PUSH *1
++++++++++++++++++++++++++++++
c  2 *1 INDUCT
   1 |  Subgoal *1/2 preprocess
   2 |  |  Subgoal *1/2' simp
   7 |  |  |  Subgoal *1/2.2 simp
   1 |  |  |  |  Subgoal *1/2.2.5 simp
   1 |  |  |  |  |  Subgoal *1/2.2.5' simp
c  1 |  |  |  |  |  |  Subgoal *1/2.2.5'' GEN
   1 |  |  |  |  |  |  |  Subgoal *1/2.2.5''' simp
c  0 |  |  |  |  |  |  |  |  Subgoal *1/2.2.5'4' PUSH *1.1
++++++++++++++++++++++++++++++
c 22 *1.1 INDUCT
     |  <19 more subgoals>
#>\>
But simplification reduces this to T, using the :compound-recognizer
rules NATP-COMPOUND-RECOGNIZER and ZP-COMPOUND-RECOGNIZER, the :congruence
rules FRAME-1-IFF-CONGRUENCE-ON-LOOP-BREAK and 
FRAME-1-INT-EQUIV-CONGRUENCE-ON-I, the :definitions ELEMENT-EQ, NFIX,
NOT, REP-1 and SYNP, the :executable-counterparts of BINARY-+, EQUAL,
FRAME-1-FIX$INLINE, IFIX and NATP, primitive type reasoning and the
:rewrite rules COMMUTATIVITY-2-OF-+, COMMUTATIVITY-OF-+, 
ENVIR-1->A$INLINE-OF-ENVIR-1-FIX-X, 
ENVIR-1->LOOP-COUNTER-SHIFT$INLINE-OF-ENVIR-1-FIX-X, FOLD-CONSTS-IN-+,
FRAME-1->I-OF-FRAME-1, FRAME-1->RESULT-OF-FRAME-1 and IFIX-UNDER-INT-EQUIV.

Subgoal *1.1/19
(IMPLIES
 (AND
  (NOT (ZP (NFIX J)))
  (NOT (FRAME-1->LOOP-BREAK
            (REP-1 (+ -1 (NFIX J))
                   (ENVIR-1-FIX L)
                   (FRAME-1-FIX '((I . 1) (RESULT . 1) (LOOP-BREAK))))))
  (NOT
   (FRAME-1->LOOP-BREAK
    (IF
     (NOT (EQUAL (NTH (+ -1 (+ -1 (NFIX J))
                         (ENVIR-1->LOOP-COUNTER-SHIFT (ENVIR-1-FIX L)))
                      (ENVIR-1->A (ENVIR-1-FIX L)))
                 (NTH (+ (+ -1 (NFIX J))
                         (ENVIR-1->LOOP-COUNTER-SHIFT (ENVIR-1-FIX L)))
                      (ENVIR-1->A (ENVIR-1-FIX L)))))
     (LET*
      ((FR-1
        (LET
            ((CHANGE-FRAME-1
                  (REP-1 (+ -1 (NFIX J))
                         (ENVIR-1-FIX L)
                         (FRAME-1-FIX '((I . 1) (RESULT . 1) (LOOP-BREAK)))))
             (FRAME-1->RESULT 0))
            (FRAME-1 (FRAME-1->I CHANGE-FRAME-1)
                     FRAME-1->RESULT
                     (FRAME-1->LOOP-BREAK CHANGE-FRAME-1))))
       (FR-1 (LET ((CHANGE-FRAME-1 FR-1)
                   (FRAME-1->LOOP-BREAK T))
                  (FRAME-1 (FRAME-1->I CHANGE-FRAME-1)
                           (FRAME-1->RESULT CHANGE-FRAME-1)
                           FRAME-1->LOOP-BREAK))))
      (COND (T FR-1)
            ((FRAME-1->LOOP-BREAK FR-1) FR-1)
            (T FR-1)))
     (REP-1 (+ -1 (NFIX J))
            (ENVIR-1-FIX L)
            (FRAME-1-FIX '((I . 1) (RESULT . 1) (LOOP-BREAK)))))))
  (NOT
   (FRAME-1->LOOP-BREAK
    (IF
     (NOT (EQUAL (NTH (+ -1 (+ -1 (NFIX J))
                         (ENVIR-1->LOOP-COUNTER-SHIFT (ENVIR-1-FIX L)))
                      (ENVIR-1->A (ENVIR-1-FIX L)))
                 (NTH (+ (+ -1 (NFIX J))
                         (ENVIR-1->LOOP-COUNTER-SHIFT (ENVIR-1-FIX L)))
                      (ENVIR-1->A (ENVIR-1-FIX L)))))
     (LET*
      ((FR-1
        (LET
            ((CHANGE-FRAME-1
                  (REP-1 (+ -1 (NFIX J))
                         (ENVIR-1-FIX L)
                         (FRAME-1-FIX '((I . 1) (RESULT . 1) (LOOP-BREAK)))))
             (FRAME-1->RESULT 0))
            (FRAME-1 (FRAME-1->I CHANGE-FRAME-1)
                     FRAME-1->RESULT
                     (FRAME-1->LOOP-BREAK CHANGE-FRAME-1))))
       (FR-1 (LET ((CHANGE-FRAME-1 FR-1)
                   (FRAME-1->LOOP-BREAK T))
                  (FRAME-1 (FRAME-1->I CHANGE-FRAME-1)
                           (FRAME-1->RESULT CHANGE-FRAME-1)
                           FRAME-1->LOOP-BREAK))))
      (COND (T FR-1)
            ((FRAME-1->LOOP-BREAK FR-1) FR-1)
            (T FR-1)))
     (REP-1 (+ -1 (NFIX J))
            (ENVIR-1-FIX L)
            (FRAME-1-FIX '((I . 1) (RESULT . 1) (LOOP-BREAK)))))))
  (NOT (EQUAL (FRAME-1->RESULT (REP-1 (+ -1 (NFIX J))
                                      (ENVIR-1-FIX L)
                                      '((I . 1) (RESULT . 1) (LOOP-BREAK))))
              1))
  (INTEGERP I)
  (< 0 I)
  L (TRUE-LISTP L)
  (INTEGERP J)
  (EQUAL (FRAME-1->RESULT (REP-1 J
                                 L '((I . 1) (RESULT . 1) (LOOP-BREAK))))
         1)
  (EQUAL (ELEMENT-EQ 0 J A) 1)
  (INTEGER-LISTP A)
  (INTEGERP N)
  (<= 0 N)
  (< 0 N)
  (<= N (LEN A))
  (NOT (EQUAL (NTH J A) (NTH I A))))
 (NOT (FRAME-1->LOOP-BREAK (REP-1 J L
                                  '((I . 1) (RESULT . 1) (LOOP-BREAK)))))).
#<\<0( DEFTHM VERIFICATION-CONDITION-1 ...)
c  0 Goal PUSH *1
++++++++++++++++++++++++++++++
c  2 *1 INDUCT
   1 |  Subgoal *1/2 preprocess
   2 |  |  Subgoal *1/2' simp
   7 |  |  |  Subgoal *1/2.2 simp
   1 |  |  |  |  Subgoal *1/2.2.5 simp
   1 |  |  |  |  |  Subgoal *1/2.2.5' simp
c  1 |  |  |  |  |  |  Subgoal *1/2.2.5'' GEN
   1 |  |  |  |  |  |  |  Subgoal *1/2.2.5''' simp
c  0 |  |  |  |  |  |  |  |  Subgoal *1/2.2.5'4' PUSH *1.1
++++++++++++++++++++++++++++++
c 22 *1.1 INDUCT
   1 |  Subgoal *1.1/19 preprocess
     |  |  <1 subgoal>
     |  <18 more subgoals>
#>\>
By the :congruence rules ENVIR-1->A$INLINE-ENVIR-1-EQUIV-CONGRUENCE-ON-X,
ENVIR-1->LOOP-COUNTER-SHIFT$INLINE-ENVIR-1-EQUIV-CONGRUENCE-ON-X and
NAT-EQUIV-IMPLIES-EQUAL-ZP-1, the :executable-counterpart of 
FRAME-1-FIX$INLINE and the simple :rewrite rules ASSOCIATIVITY-OF-+,
ENVIR-1-FIX-UNDER-ENVIR-1-EQUIV and NFIX-UNDER-NAT-EQUIV we reduce
the conjecture to

Subgoal *1.1/19'
(IMPLIES
 (AND
  (NOT (ZP J))
  (NOT (FRAME-1->LOOP-BREAK (REP-1 (+ -1 (NFIX J))
                                   (ENVIR-1-FIX L)
                                   '((I . 1) (RESULT . 1) (LOOP-BREAK)))))
  (NOT
   (FRAME-1->LOOP-BREAK
    (IF
     (NOT (EQUAL (NTH (+ -1 -1 (NFIX J)
                         (ENVIR-1->LOOP-COUNTER-SHIFT L))
                      (ENVIR-1->A L))
                 (NTH (+ -1 (NFIX J)
                         (ENVIR-1->LOOP-COUNTER-SHIFT L))
                      (ENVIR-1->A L))))
     (LET
      ((CHANGE-FRAME-1
          (LET ((CHANGE-FRAME-1 (REP-1 (+ -1 (NFIX J))
                                       (ENVIR-1-FIX L)
                                       '((I . 1) (RESULT . 1) (LOOP-BREAK))))
                (FRAME-1->RESULT 0))
               (FRAME-1 (FRAME-1->I CHANGE-FRAME-1)
                        FRAME-1->RESULT
                        (FRAME-1->LOOP-BREAK CHANGE-FRAME-1))))
       (FRAME-1->LOOP-BREAK T))
      (FRAME-1 (FRAME-1->I CHANGE-FRAME-1)
               (FRAME-1->RESULT CHANGE-FRAME-1)
               FRAME-1->LOOP-BREAK))
     (REP-1 (+ -1 (NFIX J))
            (ENVIR-1-FIX L)
            '((I . 1) (RESULT . 1) (LOOP-BREAK))))))
  (NOT (EQUAL (FRAME-1->RESULT (REP-1 (+ -1 (NFIX J))
                                      (ENVIR-1-FIX L)
                                      '((I . 1) (RESULT . 1) (LOOP-BREAK))))
              1))
  (INTEGERP I)
  (< 0 I)
  L (TRUE-LISTP L)
  (INTEGERP J)
  (EQUAL (FRAME-1->RESULT (REP-1 J
                                 L '((I . 1) (RESULT . 1) (LOOP-BREAK))))
         1)
  (EQUAL (ELEMENT-EQ 0 J A) 1)
  (INTEGER-LISTP A)
  (INTEGERP N)
  (<= 0 N)
  (< 0 N)
  (<= N (LEN A))
  (NOT (EQUAL (NTH J A) (NTH I A))))
 (NOT (FRAME-1->LOOP-BREAK (REP-1 J L
                                  '((I . 1) (RESULT . 1) (LOOP-BREAK)))))).
#<\<0( DEFTHM VERIFICATION-CONDITION-1 ...)
c  0 Goal PUSH *1
++++++++++++++++++++++++++++++
c  2 *1 INDUCT
   1 |  Subgoal *1/2 preprocess
   2 |  |  Subgoal *1/2' simp
   7 |  |  |  Subgoal *1/2.2 simp
   1 |  |  |  |  Subgoal *1/2.2.5 simp
   1 |  |  |  |  |  Subgoal *1/2.2.5' simp
c  1 |  |  |  |  |  |  Subgoal *1/2.2.5'' GEN
   1 |  |  |  |  |  |  |  Subgoal *1/2.2.5''' simp
c  0 |  |  |  |  |  |  |  |  Subgoal *1/2.2.5'4' PUSH *1.1
++++++++++++++++++++++++++++++
c 22 *1.1 INDUCT
   1 |  Subgoal *1.1/19 preprocess
   3 |  |  Subgoal *1.1/19' simp
     |  |  |  <3 subgoals>
     |  <18 more subgoals>
#>\>
This simplifies, using the :compound-recognizer rule ZP-COMPOUND-RECOGNIZER,
the :congruence rules FRAME-1-IFF-CONGRUENCE-ON-LOOP-BREAK, 
FRAME-1-INT-EQUIV-CONGRUENCE-ON-I and IFF-IMPLIES-EQUAL-BOOL-FIX-1,
the :definitions NFIX, NOT (if-intro), REP-1 (if-intro) and SYNP, the
:executable-counterparts of BINARY-+, BOOL-FIX$INLINE, FRAME-1-FIX$INLINE
and IFIX, primitive type reasoning, the :rewrite rules COMMUTATIVITY-2-OF-+,
COMMUTATIVITY-OF-+, ENVIR-1->A$INLINE-OF-ENVIR-1-FIX-X, 
ENVIR-1->LOOP-COUNTER-SHIFT$INLINE-OF-ENVIR-1-FIX-X, FOLD-CONSTS-IN-+,
FRAME-1->I-OF-FRAME-1, FRAME-1->LOOP-BREAK-OF-FRAME-1, 
FRAME-1->RESULT-OF-FRAME-1 and IFIX-UNDER-INT-EQUIV and the :type-
prescription rule FRAME-1->LOOP-BREAK$INLINE, to the following three
conjectures.

Subgoal *1.1/19.3
(IMPLIES
 (AND
   (NOT (ZP J))
   (NOT (FRAME-1->LOOP-BREAK (REP-1 (+ -1 (NFIX J))
                                    (ENVIR-1-FIX L)
                                    '((I . 1) (RESULT . 1) (LOOP-BREAK)))))
   (EQUAL (NTH (+ -2 J (ENVIR-1->LOOP-COUNTER-SHIFT L))
               (ENVIR-1->A L))
          (NTH (+ -1 J (ENVIR-1->LOOP-COUNTER-SHIFT L))
               (ENVIR-1->A L)))
   (NOT (EQUAL (FRAME-1->RESULT (REP-1 (+ -1 (NFIX J))
                                       (ENVIR-1-FIX L)
                                       '((I . 1) (RESULT . 1) (LOOP-BREAK))))
               1))
   (INTEGERP I)
   (< 0 I)
   L (TRUE-LISTP L)
   (FRAME-1->LOOP-BREAK (REP-1 (+ -1 J)
                               (ENVIR-1-FIX L)
                               '((I . 1) (RESULT . 1) (LOOP-BREAK))))
   (EQUAL (FRAME-1->RESULT (REP-1 (+ -1 J)
                                  (ENVIR-1-FIX L)
                                  '((I . 1) (RESULT . 1) (LOOP-BREAK))))
          1)
   (EQUAL (ELEMENT-EQ 0 J A) 1)
   (INTEGER-LISTP A)
   (INTEGERP N)
   (<= 0 N)
   (< 0 N)
   (<= N (LEN A)))
 (EQUAL (NTH J A) (NTH I A))).
#<\<0( DEFTHM VERIFICATION-CONDITION-1 ...)
c  0 Goal PUSH *1
++++++++++++++++++++++++++++++
c  2 *1 INDUCT
   1 |  Subgoal *1/2 preprocess
   2 |  |  Subgoal *1/2' simp
   7 |  |  |  Subgoal *1/2.2 simp
   1 |  |  |  |  Subgoal *1/2.2.5 simp
   1 |  |  |  |  |  Subgoal *1/2.2.5' simp
c  1 |  |  |  |  |  |  Subgoal *1/2.2.5'' GEN
   1 |  |  |  |  |  |  |  Subgoal *1/2.2.5''' simp
c  0 |  |  |  |  |  |  |  |  Subgoal *1/2.2.5'4' PUSH *1.1
++++++++++++++++++++++++++++++
c 22 *1.1 INDUCT
   1 |  Subgoal *1.1/19 preprocess
   3 |  |  Subgoal *1.1/19' simp
     |  |  |  <2 more subgoals>
     |  <18 more subgoals>
#>\>
But simplification reduces this to T, using the :compound-recognizer
rule ZP-COMPOUND-RECOGNIZER, the :definition NFIX, primitive type reasoning
and the :type-prescription rule FRAME-1->LOOP-BREAK$INLINE.

Subgoal *1.1/19.2
(IMPLIES
 (AND
  (NOT (ZP J))
  (NOT (FRAME-1->LOOP-BREAK (REP-1 (+ -1 (NFIX J))
                                   (ENVIR-1-FIX L)
                                   '((I . 1) (RESULT . 1) (LOOP-BREAK)))))
  (NOT
      (FRAME-1->LOOP-BREAK
           (FRAME-1 (FRAME-1->I (REP-1 (+ -1 (NFIX J))
                                       (ENVIR-1-FIX L)
                                       '((I . 1) (RESULT . 1) (LOOP-BREAK))))
                    0 T)))
  (NOT (EQUAL (FRAME-1->RESULT (REP-1 (+ -1 (NFIX J))
                                      (ENVIR-1-FIX L)
                                      '((I . 1) (RESULT . 1) (LOOP-BREAK))))
              1))
  (INTEGERP I)
  (< 0 I)
  L (TRUE-LISTP L)
  (FRAME-1->LOOP-BREAK (REP-1 (+ -1 J)
                              (ENVIR-1-FIX L)
                              '((I . 1) (RESULT . 1) (LOOP-BREAK))))
  (EQUAL (FRAME-1->RESULT (REP-1 (+ -1 J)
                                 (ENVIR-1-FIX L)
                                 '((I . 1) (RESULT . 1) (LOOP-BREAK))))
         1)
  (EQUAL (ELEMENT-EQ 0 J A) 1)
  (INTEGER-LISTP A)
  (INTEGERP N)
  (<= 0 N)
  (< 0 N)
  (<= N (LEN A)))
 (EQUAL (NTH J A) (NTH I A))).
#<\<0( DEFTHM VERIFICATION-CONDITION-1 ...)
c  0 Goal PUSH *1
++++++++++++++++++++++++++++++
c  2 *1 INDUCT
   1 |  Subgoal *1/2 preprocess
   2 |  |  Subgoal *1/2' simp
   7 |  |  |  Subgoal *1/2.2 simp
   1 |  |  |  |  Subgoal *1/2.2.5 simp
   1 |  |  |  |  |  Subgoal *1/2.2.5' simp
c  1 |  |  |  |  |  |  Subgoal *1/2.2.5'' GEN
   1 |  |  |  |  |  |  |  Subgoal *1/2.2.5''' simp
c  0 |  |  |  |  |  |  |  |  Subgoal *1/2.2.5'4' PUSH *1.1
++++++++++++++++++++++++++++++
c 22 *1.1 INDUCT
   1 |  Subgoal *1.1/19 preprocess
   3 |  |  Subgoal *1.1/19' simp
     |  |  |  <1 more subgoal>
     |  <18 more subgoals>
#>\>
But we reduce the conjecture to T, by the :executable-counterpart of
BOOL-FIX$INLINE and the simple :rewrite rule FRAME-1->LOOP-BREAK-OF-FRAME-1.

Subgoal *1.1/19.1
(IMPLIES
 (AND
  (NOT (ZP J))
  (NOT (FRAME-1->LOOP-BREAK (REP-1 (+ -1 (NFIX J))
                                   (ENVIR-1-FIX L)
                                   '((I . 1) (RESULT . 1) (LOOP-BREAK)))))
  (NOT
      (FRAME-1->LOOP-BREAK
           (FRAME-1 (FRAME-1->I (REP-1 (+ -1 (NFIX J))
                                       (ENVIR-1-FIX L)
                                       '((I . 1) (RESULT . 1) (LOOP-BREAK))))
                    0 T)))
  (NOT (EQUAL (FRAME-1->RESULT (REP-1 (+ -1 (NFIX J))
                                      (ENVIR-1-FIX L)
                                      '((I . 1) (RESULT . 1) (LOOP-BREAK))))
              1))
  (INTEGERP I)
  (< 0 I)
  L (TRUE-LISTP L)
  (NOT (FRAME-1->LOOP-BREAK (REP-1 (+ -1 J)
                                   (ENVIR-1-FIX L)
                                   '((I . 1) (RESULT . 1) (LOOP-BREAK)))))
  (NOT (EQUAL (NTH (+ -2 J (ENVIR-1->LOOP-COUNTER-SHIFT L))
                   (ENVIR-1->A L))
              (NTH (+ -1 J (ENVIR-1->LOOP-COUNTER-SHIFT L))
                   (ENVIR-1->A L))))
  (EQUAL
   (FRAME-1->RESULT
    (LET
     ((FR-1
           (FRAME-1 (FRAME-1->I (REP-1 (+ -1 J)
                                       (ENVIR-1-FIX L)
                                       '((I . 1) (RESULT . 1) (LOOP-BREAK))))
                    0 T)))
     (IF (FRAME-1->LOOP-BREAK FR-1)
         FR-1
         (LET ((FR-1 (LET ((CHANGE-FRAME-1 FR-1)
                           (FRAME-1->I (+ (FRAME-1->I FR-1) 1)))
                          (FRAME-1 FRAME-1->I
                                   (FRAME-1->RESULT CHANGE-FRAME-1)
                                   (FRAME-1->LOOP-BREAK CHANGE-FRAME-1)))))
              FR-1))))
   1)
  (EQUAL (ELEMENT-EQ 0 J A) 1)
  (INTEGER-LISTP A)
  (INTEGERP N)
  (<= 0 N)
  (< 0 N)
  (<= N (LEN A)))
 (EQUAL (NTH J A) (NTH I A))).
#<\<0( DEFTHM VERIFICATION-CONDITION-1 ...)
c  0 Goal PUSH *1
++++++++++++++++++++++++++++++
c  2 *1 INDUCT
   1 |  Subgoal *1/2 preprocess
   2 |  |  Subgoal *1/2' simp
   7 |  |  |  Subgoal *1/2.2 simp
   1 |  |  |  |  Subgoal *1/2.2.5 simp
   1 |  |  |  |  |  Subgoal *1/2.2.5' simp
c  1 |  |  |  |  |  |  Subgoal *1/2.2.5'' GEN
   1 |  |  |  |  |  |  |  Subgoal *1/2.2.5''' simp
c  0 |  |  |  |  |  |  |  |  Subgoal *1/2.2.5'4' PUSH *1.1
++++++++++++++++++++++++++++++
c 22 *1.1 INDUCT
     |  <18 more subgoals>
#>\>
But we reduce the conjecture to T, by the :executable-counterpart of
BOOL-FIX$INLINE and the simple :rewrite rule FRAME-1->LOOP-BREAK-OF-FRAME-1.

Subgoal *1.1/18
(IMPLIES
 (AND
  (NOT (ZP (NFIX J)))
  (NOT (FRAME-1->LOOP-BREAK
            (REP-1 (+ -1 (NFIX J))
                   (ENVIR-1-FIX L)
                   (FRAME-1-FIX '((I . 1) (RESULT . 1) (LOOP-BREAK))))))
  (NOT
   (FRAME-1->LOOP-BREAK
    (IF
     (NOT (EQUAL (NTH (+ -1 (+ -1 (NFIX J))
                         (ENVIR-1->LOOP-COUNTER-SHIFT (ENVIR-1-FIX L)))
                      (ENVIR-1->A (ENVIR-1-FIX L)))
                 (NTH (+ (+ -1 (NFIX J))
                         (ENVIR-1->LOOP-COUNTER-SHIFT (ENVIR-1-FIX L)))
                      (ENVIR-1->A (ENVIR-1-FIX L)))))
     (LET*
      ((FR-1
        (LET
            ((CHANGE-FRAME-1
                  (REP-1 (+ -1 (NFIX J))
                         (ENVIR-1-FIX L)
                         (FRAME-1-FIX '((I . 1) (RESULT . 1) (LOOP-BREAK)))))
             (FRAME-1->RESULT 0))
            (FRAME-1 (FRAME-1->I CHANGE-FRAME-1)
                     FRAME-1->RESULT
                     (FRAME-1->LOOP-BREAK CHANGE-FRAME-1))))
       (FR-1 (LET ((CHANGE-FRAME-1 FR-1)
                   (FRAME-1->LOOP-BREAK T))
                  (FRAME-1 (FRAME-1->I CHANGE-FRAME-1)
                           (FRAME-1->RESULT CHANGE-FRAME-1)
                           FRAME-1->LOOP-BREAK))))
      (COND (T FR-1)
            ((FRAME-1->LOOP-BREAK FR-1) FR-1)
            (T FR-1)))
     (REP-1 (+ -1 (NFIX J))
            (ENVIR-1-FIX L)
            (FRAME-1-FIX '((I . 1) (RESULT . 1) (LOOP-BREAK)))))))
  (NOT
   (FRAME-1->LOOP-BREAK
    (IF
     (NOT (EQUAL (NTH (+ -1 (+ -1 (NFIX J))
                         (ENVIR-1->LOOP-COUNTER-SHIFT (ENVIR-1-FIX L)))
                      (ENVIR-1->A (ENVIR-1-FIX L)))
                 (NTH (+ (+ -1 (NFIX J))
                         (ENVIR-1->LOOP-COUNTER-SHIFT (ENVIR-1-FIX L)))
                      (ENVIR-1->A (ENVIR-1-FIX L)))))
     (LET*
      ((FR-1
        (LET
            ((CHANGE-FRAME-1
                  (REP-1 (+ -1 (NFIX J))
                         (ENVIR-1-FIX L)
                         (FRAME-1-FIX '((I . 1) (RESULT . 1) (LOOP-BREAK)))))
             (FRAME-1->RESULT 0))
            (FRAME-1 (FRAME-1->I CHANGE-FRAME-1)
                     FRAME-1->RESULT
                     (FRAME-1->LOOP-BREAK CHANGE-FRAME-1))))
       (FR-1 (LET ((CHANGE-FRAME-1 FR-1)
                   (FRAME-1->LOOP-BREAK T))
                  (FRAME-1 (FRAME-1->I CHANGE-FRAME-1)
                           (FRAME-1->RESULT CHANGE-FRAME-1)
                           FRAME-1->LOOP-BREAK))))
      (COND (T FR-1)
            ((FRAME-1->LOOP-BREAK FR-1) FR-1)
            (T FR-1)))
     (REP-1 (+ -1 (NFIX J))
            (ENVIR-1-FIX L)
            (FRAME-1-FIX '((I . 1) (RESULT . 1) (LOOP-BREAK)))))))
  (NOT (INTEGERP (+ -1 (NFIX J))))
  (INTEGERP I)
  (< 0 I)
  L (TRUE-LISTP L)
  (INTEGERP J)
  (EQUAL (FRAME-1->RESULT (REP-1 J
                                 L '((I . 1) (RESULT . 1) (LOOP-BREAK))))
         1)
  (EQUAL (ELEMENT-EQ 0 J A) 1)
  (INTEGER-LISTP A)
  (INTEGERP N)
  (<= 0 N)
  (< 0 N)
  (<= N (LEN A))
  (NOT (EQUAL (NTH J A) (NTH I A))))
 (NOT (FRAME-1->LOOP-BREAK (REP-1 J L
                                  '((I . 1) (RESULT . 1) (LOOP-BREAK)))))).
#<\<0( DEFTHM VERIFICATION-CONDITION-1 ...)
c  0 Goal PUSH *1
++++++++++++++++++++++++++++++
c  2 *1 INDUCT
   1 |  Subgoal *1/2 preprocess
   2 |  |  Subgoal *1/2' simp
   7 |  |  |  Subgoal *1/2.2 simp
   1 |  |  |  |  Subgoal *1/2.2.5 simp
   1 |  |  |  |  |  Subgoal *1/2.2.5' simp
c  1 |  |  |  |  |  |  Subgoal *1/2.2.5'' GEN
   1 |  |  |  |  |  |  |  Subgoal *1/2.2.5''' simp
c  0 |  |  |  |  |  |  |  |  Subgoal *1/2.2.5'4' PUSH *1.1
++++++++++++++++++++++++++++++
c 22 *1.1 INDUCT
     |  <17 more subgoals>
#>\>
But we reduce the conjecture to T, by the :compound-recognizer rule
ZP-COMPOUND-RECOGNIZER and the :type-prescription rule NFIX.

Subgoal *1.1/17
(IMPLIES
 (AND
  (NOT (ZP (NFIX J)))
  (NOT (FRAME-1->LOOP-BREAK
            (REP-1 (+ -1 (NFIX J))
                   (ENVIR-1-FIX L)
                   (FRAME-1-FIX '((I . 1) (RESULT . 1) (LOOP-BREAK))))))
  (NOT
   (FRAME-1->LOOP-BREAK
    (IF
     (NOT (EQUAL (NTH (+ -1 (+ -1 (NFIX J))
                         (ENVIR-1->LOOP-COUNTER-SHIFT (ENVIR-1-FIX L)))
                      (ENVIR-1->A (ENVIR-1-FIX L)))
                 (NTH (+ (+ -1 (NFIX J))
                         (ENVIR-1->LOOP-COUNTER-SHIFT (ENVIR-1-FIX L)))
                      (ENVIR-1->A (ENVIR-1-FIX L)))))
     (LET*
      ((FR-1
        (LET
            ((CHANGE-FRAME-1
                  (REP-1 (+ -1 (NFIX J))
                         (ENVIR-1-FIX L)
                         (FRAME-1-FIX '((I . 1) (RESULT . 1) (LOOP-BREAK)))))
             (FRAME-1->RESULT 0))
            (FRAME-1 (FRAME-1->I CHANGE-FRAME-1)
                     FRAME-1->RESULT
                     (FRAME-1->LOOP-BREAK CHANGE-FRAME-1))))
       (FR-1 (LET ((CHANGE-FRAME-1 FR-1)
                   (FRAME-1->LOOP-BREAK T))
                  (FRAME-1 (FRAME-1->I CHANGE-FRAME-1)
                           (FRAME-1->RESULT CHANGE-FRAME-1)
                           FRAME-1->LOOP-BREAK))))
      (COND (T FR-1)
            ((FRAME-1->LOOP-BREAK FR-1) FR-1)
            (T FR-1)))
     (REP-1 (+ -1 (NFIX J))
            (ENVIR-1-FIX L)
            (FRAME-1-FIX '((I . 1) (RESULT . 1) (LOOP-BREAK)))))))
  (NOT
   (FRAME-1->LOOP-BREAK
    (IF
     (NOT (EQUAL (NTH (+ -1 (+ -1 (NFIX J))
                         (ENVIR-1->LOOP-COUNTER-SHIFT (ENVIR-1-FIX L)))
                      (ENVIR-1->A (ENVIR-1-FIX L)))
                 (NTH (+ (+ -1 (NFIX J))
                         (ENVIR-1->LOOP-COUNTER-SHIFT (ENVIR-1-FIX L)))
                      (ENVIR-1->A (ENVIR-1-FIX L)))))
     (LET*
      ((FR-1
        (LET
            ((CHANGE-FRAME-1
                  (REP-1 (+ -1 (NFIX J))
                         (ENVIR-1-FIX L)
                         (FRAME-1-FIX '((I . 1) (RESULT . 1) (LOOP-BREAK)))))
             (FRAME-1->RESULT 0))
            (FRAME-1 (FRAME-1->I CHANGE-FRAME-1)
                     FRAME-1->RESULT
                     (FRAME-1->LOOP-BREAK CHANGE-FRAME-1))))
       (FR-1 (LET ((CHANGE-FRAME-1 FR-1)
                   (FRAME-1->LOOP-BREAK T))
                  (FRAME-1 (FRAME-1->I CHANGE-FRAME-1)
                           (FRAME-1->RESULT CHANGE-FRAME-1)
                           FRAME-1->LOOP-BREAK))))
      (COND (T FR-1)
            ((FRAME-1->LOOP-BREAK FR-1) FR-1)
            (T FR-1)))
     (REP-1 (+ -1 (NFIX J))
            (ENVIR-1-FIX L)
            (FRAME-1-FIX '((I . 1) (RESULT . 1) (LOOP-BREAK)))))))
  (NOT (TRUE-LISTP (ENVIR-1-FIX L)))
  (INTEGERP I)
  (< 0 I)
  L (TRUE-LISTP L)
  (INTEGERP J)
  (EQUAL (FRAME-1->RESULT (REP-1 J
                                 L '((I . 1) (RESULT . 1) (LOOP-BREAK))))
         1)
  (EQUAL (ELEMENT-EQ 0 J A) 1)
  (INTEGER-LISTP A)
  (INTEGERP N)
  (<= 0 N)
  (< 0 N)
  (<= N (LEN A))
  (NOT (EQUAL (NTH J A) (NTH I A))))
 (NOT (FRAME-1->LOOP-BREAK (REP-1 J L
                                  '((I . 1) (RESULT . 1) (LOOP-BREAK)))))).
#<\<0( DEFTHM VERIFICATION-CONDITION-1 ...)
c  0 Goal PUSH *1
++++++++++++++++++++++++++++++
c  2 *1 INDUCT
   1 |  Subgoal *1/2 preprocess
   2 |  |  Subgoal *1/2' simp
   7 |  |  |  Subgoal *1/2.2 simp
   1 |  |  |  |  Subgoal *1/2.2.5 simp
   1 |  |  |  |  |  Subgoal *1/2.2.5' simp
c  1 |  |  |  |  |  |  Subgoal *1/2.2.5'' GEN
   1 |  |  |  |  |  |  |  Subgoal *1/2.2.5''' simp
c  0 |  |  |  |  |  |  |  |  Subgoal *1/2.2.5'4' PUSH *1.1
++++++++++++++++++++++++++++++
c 22 *1.1 INDUCT
     |  <16 more subgoals>
#>\>
But we reduce the conjecture to T, by the :type-prescription rule 
ENVIR-1-FIX$INLINE.

Subgoal *1.1/16
(IMPLIES
 (AND
  (NOT (ZP (NFIX J)))
  (NOT (FRAME-1->LOOP-BREAK
            (REP-1 (+ -1 (NFIX J))
                   (ENVIR-1-FIX L)
                   (FRAME-1-FIX '((I . 1) (RESULT . 1) (LOOP-BREAK))))))
  (NOT
   (FRAME-1->LOOP-BREAK
    (IF
     (NOT (EQUAL (NTH (+ -1 (+ -1 (NFIX J))
                         (ENVIR-1->LOOP-COUNTER-SHIFT (ENVIR-1-FIX L)))
                      (ENVIR-1->A (ENVIR-1-FIX L)))
                 (NTH (+ (+ -1 (NFIX J))
                         (ENVIR-1->LOOP-COUNTER-SHIFT (ENVIR-1-FIX L)))
                      (ENVIR-1->A (ENVIR-1-FIX L)))))
     (LET*
      ((FR-1
        (LET
            ((CHANGE-FRAME-1
                  (REP-1 (+ -1 (NFIX J))
                         (ENVIR-1-FIX L)
                         (FRAME-1-FIX '((I . 1) (RESULT . 1) (LOOP-BREAK)))))
             (FRAME-1->RESULT 0))
            (FRAME-1 (FRAME-1->I CHANGE-FRAME-1)
                     FRAME-1->RESULT
                     (FRAME-1->LOOP-BREAK CHANGE-FRAME-1))))
       (FR-1 (LET ((CHANGE-FRAME-1 FR-1)
                   (FRAME-1->LOOP-BREAK T))
                  (FRAME-1 (FRAME-1->I CHANGE-FRAME-1)
                           (FRAME-1->RESULT CHANGE-FRAME-1)
                           FRAME-1->LOOP-BREAK))))
      (COND (T FR-1)
            ((FRAME-1->LOOP-BREAK FR-1) FR-1)
            (T FR-1)))
     (REP-1 (+ -1 (NFIX J))
            (ENVIR-1-FIX L)
            (FRAME-1-FIX '((I . 1) (RESULT . 1) (LOOP-BREAK)))))))
  (NOT
   (FRAME-1->LOOP-BREAK
    (IF
     (NOT (EQUAL (NTH (+ -1 (+ -1 (NFIX J))
                         (ENVIR-1->LOOP-COUNTER-SHIFT (ENVIR-1-FIX L)))
                      (ENVIR-1->A (ENVIR-1-FIX L)))
                 (NTH (+ (+ -1 (NFIX J))
                         (ENVIR-1->LOOP-COUNTER-SHIFT (ENVIR-1-FIX L)))
                      (ENVIR-1->A (ENVIR-1-FIX L)))))
     (LET*
      ((FR-1
        (LET
            ((CHANGE-FRAME-1
                  (REP-1 (+ -1 (NFIX J))
                         (ENVIR-1-FIX L)
                         (FRAME-1-FIX '((I . 1) (RESULT . 1) (LOOP-BREAK)))))
             (FRAME-1->RESULT 0))
            (FRAME-1 (FRAME-1->I CHANGE-FRAME-1)
                     FRAME-1->RESULT
                     (FRAME-1->LOOP-BREAK CHANGE-FRAME-1))))
       (FR-1 (LET ((CHANGE-FRAME-1 FR-1)
                   (FRAME-1->LOOP-BREAK T))
                  (FRAME-1 (FRAME-1->I CHANGE-FRAME-1)
                           (FRAME-1->RESULT CHANGE-FRAME-1)
                           FRAME-1->LOOP-BREAK))))
      (COND (T FR-1)
            ((FRAME-1->LOOP-BREAK FR-1) FR-1)
            (T FR-1)))
     (REP-1 (+ -1 (NFIX J))
            (ENVIR-1-FIX L)
            (FRAME-1-FIX '((I . 1) (RESULT . 1) (LOOP-BREAK)))))))
  (NOT (ENVIR-1-FIX L))
  (INTEGERP I)
  (< 0 I)
  L (TRUE-LISTP L)
  (INTEGERP J)
  (EQUAL (FRAME-1->RESULT (REP-1 J
                                 L '((I . 1) (RESULT . 1) (LOOP-BREAK))))
         1)
  (EQUAL (ELEMENT-EQ 0 J A) 1)
  (INTEGER-LISTP A)
  (INTEGERP N)
  (<= 0 N)
  (< 0 N)
  (<= N (LEN A))
  (NOT (EQUAL (NTH J A) (NTH I A))))
 (NOT (FRAME-1->LOOP-BREAK (REP-1 J L
                                  '((I . 1) (RESULT . 1) (LOOP-BREAK)))))).
#<\<0( DEFTHM VERIFICATION-CONDITION-1 ...)
c  0 Goal PUSH *1
++++++++++++++++++++++++++++++
c  2 *1 INDUCT
   1 |  Subgoal *1/2 preprocess
   2 |  |  Subgoal *1/2' simp
   7 |  |  |  Subgoal *1/2.2 simp
   1 |  |  |  |  Subgoal *1/2.2.5 simp
   1 |  |  |  |  |  Subgoal *1/2.2.5' simp
c  1 |  |  |  |  |  |  Subgoal *1/2.2.5'' GEN
   1 |  |  |  |  |  |  |  Subgoal *1/2.2.5''' simp
c  0 |  |  |  |  |  |  |  |  Subgoal *1/2.2.5'4' PUSH *1.1
++++++++++++++++++++++++++++++
c 22 *1.1 INDUCT
     |  <15 more subgoals>
#>\>
But we reduce the conjecture to T, by the :type-prescription rule 
ENVIR-1-FIX$INLINE.

Subgoal *1.1/15
(IMPLIES
 (AND
  (NOT (ZP (NFIX J)))
  (NOT (FRAME-1->LOOP-BREAK
            (REP-1 (+ -1 (NFIX J))
                   (ENVIR-1-FIX L)
                   (FRAME-1-FIX '((I . 1) (RESULT . 1) (LOOP-BREAK))))))
  (FRAME-1->LOOP-BREAK
   (IF
    (NOT (EQUAL (NTH (+ -1 (+ -1 (NFIX J))
                        (ENVIR-1->LOOP-COUNTER-SHIFT (ENVIR-1-FIX L)))
                     (ENVIR-1->A (ENVIR-1-FIX L)))
                (NTH (+ (+ -1 (NFIX J))
                        (ENVIR-1->LOOP-COUNTER-SHIFT (ENVIR-1-FIX L)))
                     (ENVIR-1->A (ENVIR-1-FIX L)))))
    (LET*
     ((FR-1
       (LET ((CHANGE-FRAME-1
                  (REP-1 (+ -1 (NFIX J))
                         (ENVIR-1-FIX L)
                         (FRAME-1-FIX '((I . 1) (RESULT . 1) (LOOP-BREAK)))))
             (FRAME-1->RESULT 0))
            (FRAME-1 (FRAME-1->I CHANGE-FRAME-1)
                     FRAME-1->RESULT
                     (FRAME-1->LOOP-BREAK CHANGE-FRAME-1))))
      (FR-1 (LET ((CHANGE-FRAME-1 FR-1)
                  (FRAME-1->LOOP-BREAK T))
                 (FRAME-1 (FRAME-1->I CHANGE-FRAME-1)
                          (FRAME-1->RESULT CHANGE-FRAME-1)
                          FRAME-1->LOOP-BREAK))))
     (COND (T FR-1)
           ((FRAME-1->LOOP-BREAK FR-1) FR-1)
           (T FR-1)))
    (REP-1 (+ -1 (NFIX J))
           (ENVIR-1-FIX L)
           (FRAME-1-FIX '((I . 1) (RESULT . 1) (LOOP-BREAK))))))
  (NOT (FRAME-1->LOOP-BREAK (REP-1 (+ -1 (NFIX J))
                                   (ENVIR-1-FIX L)
                                   '((I . 1) (RESULT . 1) (LOOP-BREAK)))))
  (INTEGERP I)
  (< 0 I)
  L (TRUE-LISTP L)
  (INTEGERP J)
  (EQUAL (FRAME-1->RESULT (REP-1 J
                                 L '((I . 1) (RESULT . 1) (LOOP-BREAK))))
         1)
  (EQUAL (ELEMENT-EQ 0 J A) 1)
  (INTEGER-LISTP A)
  (INTEGERP N)
  (<= 0 N)
  (< 0 N)
  (<= N (LEN A))
  (NOT (EQUAL (NTH J A) (NTH I A))))
 (NOT (FRAME-1->LOOP-BREAK (REP-1 J L
                                  '((I . 1) (RESULT . 1) (LOOP-BREAK)))))).
#<\<0( DEFTHM VERIFICATION-CONDITION-1 ...)
c  0 Goal PUSH *1
++++++++++++++++++++++++++++++
c  2 *1 INDUCT
   1 |  Subgoal *1/2 preprocess
   2 |  |  Subgoal *1/2' simp
   7 |  |  |  Subgoal *1/2.2 simp
   1 |  |  |  |  Subgoal *1/2.2.5 simp
   1 |  |  |  |  |  Subgoal *1/2.2.5' simp
c  1 |  |  |  |  |  |  Subgoal *1/2.2.5'' GEN
   1 |  |  |  |  |  |  |  Subgoal *1/2.2.5''' simp
c  0 |  |  |  |  |  |  |  |  Subgoal *1/2.2.5'4' PUSH *1.1
++++++++++++++++++++++++++++++
c 22 *1.1 INDUCT
   1 |  Subgoal *1.1/15 preprocess
     |  |  <1 subgoal>
     |  <14 more subgoals>
#>\>
By the :congruence rules ENVIR-1->A$INLINE-ENVIR-1-EQUIV-CONGRUENCE-ON-X,
ENVIR-1->LOOP-COUNTER-SHIFT$INLINE-ENVIR-1-EQUIV-CONGRUENCE-ON-X and
NAT-EQUIV-IMPLIES-EQUAL-ZP-1, the :executable-counterpart of 
FRAME-1-FIX$INLINE and the simple :rewrite rules ASSOCIATIVITY-OF-+,
ENVIR-1-FIX-UNDER-ENVIR-1-EQUIV and NFIX-UNDER-NAT-EQUIV we reduce
the conjecture to

Subgoal *1.1/15'
(IMPLIES
 (AND
  (NOT (ZP J))
  (NOT (FRAME-1->LOOP-BREAK (REP-1 (+ -1 (NFIX J))
                                   (ENVIR-1-FIX L)
                                   '((I . 1) (RESULT . 1) (LOOP-BREAK)))))
  (FRAME-1->LOOP-BREAK
   (IF
    (NOT (EQUAL (NTH (+ -1 -1 (NFIX J)
                        (ENVIR-1->LOOP-COUNTER-SHIFT L))
                     (ENVIR-1->A L))
                (NTH (+ -1 (NFIX J)
                        (ENVIR-1->LOOP-COUNTER-SHIFT L))
                     (ENVIR-1->A L))))
    (LET
     ((CHANGE-FRAME-1
          (LET ((CHANGE-FRAME-1 (REP-1 (+ -1 (NFIX J))
                                       (ENVIR-1-FIX L)
                                       '((I . 1) (RESULT . 1) (LOOP-BREAK))))
                (FRAME-1->RESULT 0))
               (FRAME-1 (FRAME-1->I CHANGE-FRAME-1)
                        FRAME-1->RESULT
                        (FRAME-1->LOOP-BREAK CHANGE-FRAME-1))))
      (FRAME-1->LOOP-BREAK T))
     (FRAME-1 (FRAME-1->I CHANGE-FRAME-1)
              (FRAME-1->RESULT CHANGE-FRAME-1)
              FRAME-1->LOOP-BREAK))
    (REP-1 (+ -1 (NFIX J))
           (ENVIR-1-FIX L)
           '((I . 1) (RESULT . 1) (LOOP-BREAK)))))
  (INTEGERP I)
  (< 0 I)
  L (TRUE-LISTP L)
  (INTEGERP J)
  (EQUAL (FRAME-1->RESULT (REP-1 J
                                 L '((I . 1) (RESULT . 1) (LOOP-BREAK))))
         1)
  (EQUAL (ELEMENT-EQ 0 J A) 1)
  (INTEGER-LISTP A)
  (INTEGERP N)
  (<= 0 N)
  (< 0 N)
  (<= N (LEN A))
  (NOT (EQUAL (NTH J A) (NTH I A))))
 (NOT (FRAME-1->LOOP-BREAK (REP-1 J L
                                  '((I . 1) (RESULT . 1) (LOOP-BREAK)))))).
#<\<0( DEFTHM VERIFICATION-CONDITION-1 ...)
c  0 Goal PUSH *1
++++++++++++++++++++++++++++++
c  2 *1 INDUCT
   1 |  Subgoal *1/2 preprocess
   2 |  |  Subgoal *1/2' simp
   7 |  |  |  Subgoal *1/2.2 simp
   1 |  |  |  |  Subgoal *1/2.2.5 simp
   1 |  |  |  |  |  Subgoal *1/2.2.5' simp
c  1 |  |  |  |  |  |  Subgoal *1/2.2.5'' GEN
   1 |  |  |  |  |  |  |  Subgoal *1/2.2.5''' simp
c  0 |  |  |  |  |  |  |  |  Subgoal *1/2.2.5'4' PUSH *1.1
++++++++++++++++++++++++++++++
c 22 *1.1 INDUCT
   1 |  Subgoal *1.1/15 preprocess
   2 |  |  Subgoal *1.1/15' simp
     |  |  |  <2 subgoals>
     |  <14 more subgoals>
#>\>
This simplifies, using the :compound-recognizer rule ZP-COMPOUND-RECOGNIZER,
the :congruence rules FRAME-1-IFF-CONGRUENCE-ON-LOOP-BREAK, 
FRAME-1-INT-EQUIV-CONGRUENCE-ON-I and IFF-IMPLIES-EQUAL-BOOL-FIX-1,
the :definitions NFIX, NOT (if-intro), REP-1 (if-intro) and SYNP, the
:executable-counterparts of BINARY-+, BOOL-FIX$INLINE, FRAME-1-FIX$INLINE
and IFIX, primitive type reasoning, the :rewrite rules COMMUTATIVITY-2-OF-+,
COMMUTATIVITY-OF-+, ENVIR-1->A$INLINE-OF-ENVIR-1-FIX-X, 
ENVIR-1->LOOP-COUNTER-SHIFT$INLINE-OF-ENVIR-1-FIX-X, FOLD-CONSTS-IN-+,
FRAME-1->I-OF-FRAME-1, FRAME-1->LOOP-BREAK-OF-FRAME-1, 
FRAME-1->RESULT-OF-FRAME-1 and IFIX-UNDER-INT-EQUIV and the :type-
prescription rule FRAME-1->LOOP-BREAK$INLINE, to the following two
conjectures.

Subgoal *1.1/15.2
(IMPLIES
 (AND
     (NOT (ZP J))
     (NOT (FRAME-1->LOOP-BREAK (REP-1 (+ -1 (NFIX J))
                                      (ENVIR-1-FIX L)
                                      '((I . 1) (RESULT . 1) (LOOP-BREAK)))))
     (NOT (EQUAL (NTH (+ -2 J (ENVIR-1->LOOP-COUNTER-SHIFT L))
                      (ENVIR-1->A L))
                 (NTH (+ -1 J (ENVIR-1->LOOP-COUNTER-SHIFT L))
                      (ENVIR-1->A L))))
     (FRAME-1->LOOP-BREAK
          (FRAME-1 (FRAME-1->I (REP-1 (+ -1 (NFIX J))
                                      (ENVIR-1-FIX L)
                                      '((I . 1) (RESULT . 1) (LOOP-BREAK))))
                   0 T))
     (INTEGERP I)
     (< 0 I)
     L (TRUE-LISTP L)
     (FRAME-1->LOOP-BREAK (REP-1 (+ -1 J)
                                 (ENVIR-1-FIX L)
                                 '((I . 1) (RESULT . 1) (LOOP-BREAK))))
     (EQUAL (FRAME-1->RESULT (REP-1 (+ -1 J)
                                    (ENVIR-1-FIX L)
                                    '((I . 1) (RESULT . 1) (LOOP-BREAK))))
            1)
     (EQUAL (ELEMENT-EQ 0 J A) 1)
     (INTEGER-LISTP A)
     (INTEGERP N)
     (<= 0 N)
     (< 0 N)
     (<= N (LEN A)))
 (EQUAL (NTH J A) (NTH I A))).
#<\<0( DEFTHM VERIFICATION-CONDITION-1 ...)
c  0 Goal PUSH *1
++++++++++++++++++++++++++++++
c  2 *1 INDUCT
   1 |  Subgoal *1/2 preprocess
   2 |  |  Subgoal *1/2' simp
   7 |  |  |  Subgoal *1/2.2 simp
   1 |  |  |  |  Subgoal *1/2.2.5 simp
   1 |  |  |  |  |  Subgoal *1/2.2.5' simp
c  1 |  |  |  |  |  |  Subgoal *1/2.2.5'' GEN
   1 |  |  |  |  |  |  |  Subgoal *1/2.2.5''' simp
c  0 |  |  |  |  |  |  |  |  Subgoal *1/2.2.5'4' PUSH *1.1
++++++++++++++++++++++++++++++
c 22 *1.1 INDUCT
   1 |  Subgoal *1.1/15 preprocess
   2 |  |  Subgoal *1.1/15' simp
   1 |  |  |  Subgoal *1.1/15.2 preprocess
     |  |  |  |  <1 subgoal>
     |  |  |  <1 more subgoal>
     |  <14 more subgoals>
#>\>
By the :executable-counterpart of BOOL-FIX$INLINE and the simple :rewrite
rule FRAME-1->LOOP-BREAK-OF-FRAME-1 we reduce the conjecture to

Subgoal *1.1/15.2'
(IMPLIES
 (AND
     (NOT (ZP J))
     (NOT (FRAME-1->LOOP-BREAK (REP-1 (+ -1 (NFIX J))
                                      (ENVIR-1-FIX L)
                                      '((I . 1) (RESULT . 1) (LOOP-BREAK)))))
     (NOT (EQUAL (NTH (+ -2 J (ENVIR-1->LOOP-COUNTER-SHIFT L))
                      (ENVIR-1->A L))
                 (NTH (+ -1 J (ENVIR-1->LOOP-COUNTER-SHIFT L))
                      (ENVIR-1->A L))))
     (INTEGERP I)
     (< 0 I)
     L (TRUE-LISTP L)
     (FRAME-1->LOOP-BREAK (REP-1 (+ -1 J)
                                 (ENVIR-1-FIX L)
                                 '((I . 1) (RESULT . 1) (LOOP-BREAK))))
     (EQUAL (FRAME-1->RESULT (REP-1 (+ -1 J)
                                    (ENVIR-1-FIX L)
                                    '((I . 1) (RESULT . 1) (LOOP-BREAK))))
            1)
     (EQUAL (ELEMENT-EQ 0 J A) 1)
     (INTEGER-LISTP A)
     (INTEGERP N)
     (<= 0 N)
     (< 0 N)
     (<= N (LEN A)))
 (EQUAL (NTH J A) (NTH I A))).
#<\<0( DEFTHM VERIFICATION-CONDITION-1 ...)
c  0 Goal PUSH *1
++++++++++++++++++++++++++++++
c  2 *1 INDUCT
   1 |  Subgoal *1/2 preprocess
   2 |  |  Subgoal *1/2' simp
   7 |  |  |  Subgoal *1/2.2 simp
   1 |  |  |  |  Subgoal *1/2.2.5 simp
   1 |  |  |  |  |  Subgoal *1/2.2.5' simp
c  1 |  |  |  |  |  |  Subgoal *1/2.2.5'' GEN
   1 |  |  |  |  |  |  |  Subgoal *1/2.2.5''' simp
c  0 |  |  |  |  |  |  |  |  Subgoal *1/2.2.5'4' PUSH *1.1
++++++++++++++++++++++++++++++
c 22 *1.1 INDUCT
   1 |  Subgoal *1.1/15 preprocess
   2 |  |  Subgoal *1.1/15' simp
     |  |  |  <1 more subgoal>
     |  <14 more subgoals>
#>\>
But simplification reduces this to T, using the :compound-recognizer
rule ZP-COMPOUND-RECOGNIZER, the :definition NFIX, primitive type reasoning
and the :type-prescription rule FRAME-1->LOOP-BREAK$INLINE.

Subgoal *1.1/15.1
(IMPLIES
 (AND
  (NOT (ZP J))
  (NOT (FRAME-1->LOOP-BREAK (REP-1 (+ -1 (NFIX J))
                                   (ENVIR-1-FIX L)
                                   '((I . 1) (RESULT . 1) (LOOP-BREAK)))))
  (NOT (EQUAL (NTH (+ -2 J (ENVIR-1->LOOP-COUNTER-SHIFT L))
                   (ENVIR-1->A L))
              (NTH (+ -1 J (ENVIR-1->LOOP-COUNTER-SHIFT L))
                   (ENVIR-1->A L))))
  (FRAME-1->LOOP-BREAK
       (FRAME-1 (FRAME-1->I (REP-1 (+ -1 (NFIX J))
                                   (ENVIR-1-FIX L)
                                   '((I . 1) (RESULT . 1) (LOOP-BREAK))))
                0 T))
  (INTEGERP I)
  (< 0 I)
  L (TRUE-LISTP L)
  (NOT (FRAME-1->LOOP-BREAK (REP-1 (+ -1 J)
                                   (ENVIR-1-FIX L)
                                   '((I . 1) (RESULT . 1) (LOOP-BREAK)))))
  (EQUAL
      (FRAME-1->RESULT
           (FRAME-1 (FRAME-1->I (REP-1 (+ -1 J)
                                       (ENVIR-1-FIX L)
                                       '((I . 1) (RESULT . 1) (LOOP-BREAK))))
                    0 T))
      1)
  (EQUAL (ELEMENT-EQ 0 J A) 1)
  (INTEGER-LISTP A)
  (INTEGERP N)
  (<= 0 N)
  (< 0 N)
  (<= N (LEN A)))
 (EQUAL (NTH J A) (NTH I A))).
#<\<0( DEFTHM VERIFICATION-CONDITION-1 ...)
c  0 Goal PUSH *1
++++++++++++++++++++++++++++++
c  2 *1 INDUCT
   1 |  Subgoal *1/2 preprocess
   2 |  |  Subgoal *1/2' simp
   7 |  |  |  Subgoal *1/2.2 simp
   1 |  |  |  |  Subgoal *1/2.2.5 simp
   1 |  |  |  |  |  Subgoal *1/2.2.5' simp
c  1 |  |  |  |  |  |  Subgoal *1/2.2.5'' GEN
   1 |  |  |  |  |  |  |  Subgoal *1/2.2.5''' simp
c  0 |  |  |  |  |  |  |  |  Subgoal *1/2.2.5'4' PUSH *1.1
++++++++++++++++++++++++++++++
c 22 *1.1 INDUCT
     |  <14 more subgoals>
#>\>
But we reduce the conjecture to T, by the :executable-counterparts
of BOOL-FIX$INLINE, EQUAL, IF and IFIX and the simple :rewrite rules
FRAME-1->LOOP-BREAK-OF-FRAME-1 and FRAME-1->RESULT-OF-FRAME-1.

Subgoal *1.1/14
(IMPLIES
 (AND
  (NOT (ZP (NFIX J)))
  (NOT (FRAME-1->LOOP-BREAK
            (REP-1 (+ -1 (NFIX J))
                   (ENVIR-1-FIX L)
                   (FRAME-1-FIX '((I . 1) (RESULT . 1) (LOOP-BREAK))))))
  (FRAME-1->LOOP-BREAK
   (IF
    (NOT (EQUAL (NTH (+ -1 (+ -1 (NFIX J))
                        (ENVIR-1->LOOP-COUNTER-SHIFT (ENVIR-1-FIX L)))
                     (ENVIR-1->A (ENVIR-1-FIX L)))
                (NTH (+ (+ -1 (NFIX J))
                        (ENVIR-1->LOOP-COUNTER-SHIFT (ENVIR-1-FIX L)))
                     (ENVIR-1->A (ENVIR-1-FIX L)))))
    (LET*
     ((FR-1
       (LET ((CHANGE-FRAME-1
                  (REP-1 (+ -1 (NFIX J))
                         (ENVIR-1-FIX L)
                         (FRAME-1-FIX '((I . 1) (RESULT . 1) (LOOP-BREAK)))))
             (FRAME-1->RESULT 0))
            (FRAME-1 (FRAME-1->I CHANGE-FRAME-1)
                     FRAME-1->RESULT
                     (FRAME-1->LOOP-BREAK CHANGE-FRAME-1))))
      (FR-1 (LET ((CHANGE-FRAME-1 FR-1)
                  (FRAME-1->LOOP-BREAK T))
                 (FRAME-1 (FRAME-1->I CHANGE-FRAME-1)
                          (FRAME-1->RESULT CHANGE-FRAME-1)
                          FRAME-1->LOOP-BREAK))))
     (COND (T FR-1)
           ((FRAME-1->LOOP-BREAK FR-1) FR-1)
           (T FR-1)))
    (REP-1 (+ -1 (NFIX J))
           (ENVIR-1-FIX L)
           (FRAME-1-FIX '((I . 1) (RESULT . 1) (LOOP-BREAK))))))
  (EQUAL (NTH (+ -1 (NFIX J)) A)
         (NTH I A))
  (INTEGERP I)
  (< 0 I)
  L (TRUE-LISTP L)
  (INTEGERP J)
  (EQUAL (FRAME-1->RESULT (REP-1 J
                                 L '((I . 1) (RESULT . 1) (LOOP-BREAK))))
         1)
  (EQUAL (ELEMENT-EQ 0 J A) 1)
  (INTEGER-LISTP A)
  (INTEGERP N)
  (<= 0 N)
  (< 0 N)
  (<= N (LEN A))
  (NOT (EQUAL (NTH J A) (NTH I A))))
 (NOT (FRAME-1->LOOP-BREAK (REP-1 J L
                                  '((I . 1) (RESULT . 1) (LOOP-BREAK)))))).
#<\<0( DEFTHM VERIFICATION-CONDITION-1 ...)
c  0 Goal PUSH *1
++++++++++++++++++++++++++++++
c  2 *1 INDUCT
   1 |  Subgoal *1/2 preprocess
   2 |  |  Subgoal *1/2' simp
   7 |  |  |  Subgoal *1/2.2 simp
   1 |  |  |  |  Subgoal *1/2.2.5 simp
   1 |  |  |  |  |  Subgoal *1/2.2.5' simp
c  1 |  |  |  |  |  |  Subgoal *1/2.2.5'' GEN
   1 |  |  |  |  |  |  |  Subgoal *1/2.2.5''' simp
c  0 |  |  |  |  |  |  |  |  Subgoal *1/2.2.5'4' PUSH *1.1
++++++++++++++++++++++++++++++
c 22 *1.1 INDUCT
   1 |  Subgoal *1.1/14 preprocess
     |  |  <1 subgoal>
     |  <13 more subgoals>
#>\>
By the :congruence rules ENVIR-1->A$INLINE-ENVIR-1-EQUIV-CONGRUENCE-ON-X,
ENVIR-1->LOOP-COUNTER-SHIFT$INLINE-ENVIR-1-EQUIV-CONGRUENCE-ON-X and
NAT-EQUIV-IMPLIES-EQUAL-ZP-1, the :executable-counterpart of 
FRAME-1-FIX$INLINE and the simple :rewrite rules ASSOCIATIVITY-OF-+,
ENVIR-1-FIX-UNDER-ENVIR-1-EQUIV and NFIX-UNDER-NAT-EQUIV we reduce
the conjecture to

Subgoal *1.1/14'
(IMPLIES
 (AND
  (NOT (ZP J))
  (NOT (FRAME-1->LOOP-BREAK (REP-1 (+ -1 (NFIX J))
                                   (ENVIR-1-FIX L)
                                   '((I . 1) (RESULT . 1) (LOOP-BREAK)))))
  (FRAME-1->LOOP-BREAK
   (IF
    (NOT (EQUAL (NTH (+ -1 -1 (NFIX J)
                        (ENVIR-1->LOOP-COUNTER-SHIFT L))
                     (ENVIR-1->A L))
                (NTH (+ -1 (NFIX J)
                        (ENVIR-1->LOOP-COUNTER-SHIFT L))
                     (ENVIR-1->A L))))
    (LET
     ((CHANGE-FRAME-1
          (LET ((CHANGE-FRAME-1 (REP-1 (+ -1 (NFIX J))
                                       (ENVIR-1-FIX L)
                                       '((I . 1) (RESULT . 1) (LOOP-BREAK))))
                (FRAME-1->RESULT 0))
               (FRAME-1 (FRAME-1->I CHANGE-FRAME-1)
                        FRAME-1->RESULT
                        (FRAME-1->LOOP-BREAK CHANGE-FRAME-1))))
      (FRAME-1->LOOP-BREAK T))
     (FRAME-1 (FRAME-1->I CHANGE-FRAME-1)
              (FRAME-1->RESULT CHANGE-FRAME-1)
              FRAME-1->LOOP-BREAK))
    (REP-1 (+ -1 (NFIX J))
           (ENVIR-1-FIX L)
           '((I . 1) (RESULT . 1) (LOOP-BREAK)))))
  (EQUAL (NTH (+ -1 (NFIX J)) A)
         (NTH I A))
  (INTEGERP I)
  (< 0 I)
  L (TRUE-LISTP L)
  (INTEGERP J)
  (EQUAL (FRAME-1->RESULT (REP-1 J
                                 L '((I . 1) (RESULT . 1) (LOOP-BREAK))))
         1)
  (EQUAL (ELEMENT-EQ 0 J A) 1)
  (INTEGER-LISTP A)
  (INTEGERP N)
  (<= 0 N)
  (< 0 N)
  (<= N (LEN A))
  (NOT (EQUAL (NTH J A) (NTH I A))))
 (NOT (FRAME-1->LOOP-BREAK (REP-1 J L
                                  '((I . 1) (RESULT . 1) (LOOP-BREAK)))))).
#<\<0( DEFTHM VERIFICATION-CONDITION-1 ...)
c  0 Goal PUSH *1
++++++++++++++++++++++++++++++
c  2 *1 INDUCT
   1 |  Subgoal *1/2 preprocess
   2 |  |  Subgoal *1/2' simp
   7 |  |  |  Subgoal *1/2.2 simp
   1 |  |  |  |  Subgoal *1/2.2.5 simp
   1 |  |  |  |  |  Subgoal *1/2.2.5' simp
c  1 |  |  |  |  |  |  Subgoal *1/2.2.5'' GEN
   1 |  |  |  |  |  |  |  Subgoal *1/2.2.5''' simp
c  0 |  |  |  |  |  |  |  |  Subgoal *1/2.2.5'4' PUSH *1.1
++++++++++++++++++++++++++++++
c 22 *1.1 INDUCT
     |  <13 more subgoals>
#>\>
But simplification reduces this to T, using the :compound-recognizer
rules NATP-COMPOUND-RECOGNIZER and ZP-COMPOUND-RECOGNIZER, the :congruence
rules FRAME-1-IFF-CONGRUENCE-ON-LOOP-BREAK, 
FRAME-1-INT-EQUIV-CONGRUENCE-ON-I and IFF-IMPLIES-EQUAL-BOOL-FIX-1,
the :definitions ELEMENT-EQ, NFIX, NOT, REP-1 and SYNP, the :executable-
counterparts of BINARY-+, BOOL-FIX$INLINE, EQUAL, FRAME-1-FIX$INLINE,
IFIX and NATP, primitive type reasoning and the :rewrite rules 
COMMUTATIVITY-2-OF-+, COMMUTATIVITY-OF-+, ENVIR-1->A$INLINE-OF-ENVIR-1-FIX-X,
ENVIR-1->LOOP-COUNTER-SHIFT$INLINE-OF-ENVIR-1-FIX-X, FOLD-CONSTS-IN-+,
FRAME-1->I-OF-FRAME-1, FRAME-1->LOOP-BREAK-OF-FRAME-1, 
FRAME-1->RESULT-OF-FRAME-1 and IFIX-UNDER-INT-EQUIV.

Subgoal *1.1/13
(IMPLIES
 (AND
  (NOT (ZP (NFIX J)))
  (NOT (FRAME-1->LOOP-BREAK
            (REP-1 (+ -1 (NFIX J))
                   (ENVIR-1-FIX L)
                   (FRAME-1-FIX '((I . 1) (RESULT . 1) (LOOP-BREAK))))))
  (FRAME-1->LOOP-BREAK
   (IF
    (NOT (EQUAL (NTH (+ -1 (+ -1 (NFIX J))
                        (ENVIR-1->LOOP-COUNTER-SHIFT (ENVIR-1-FIX L)))
                     (ENVIR-1->A (ENVIR-1-FIX L)))
                (NTH (+ (+ -1 (NFIX J))
                        (ENVIR-1->LOOP-COUNTER-SHIFT (ENVIR-1-FIX L)))
                     (ENVIR-1->A (ENVIR-1-FIX L)))))
    (LET*
     ((FR-1
       (LET ((CHANGE-FRAME-1
                  (REP-1 (+ -1 (NFIX J))
                         (ENVIR-1-FIX L)
                         (FRAME-1-FIX '((I . 1) (RESULT . 1) (LOOP-BREAK)))))
             (FRAME-1->RESULT 0))
            (FRAME-1 (FRAME-1->I CHANGE-FRAME-1)
                     FRAME-1->RESULT
                     (FRAME-1->LOOP-BREAK CHANGE-FRAME-1))))
      (FR-1 (LET ((CHANGE-FRAME-1 FR-1)
                  (FRAME-1->LOOP-BREAK T))
                 (FRAME-1 (FRAME-1->I CHANGE-FRAME-1)
                          (FRAME-1->RESULT CHANGE-FRAME-1)
                          FRAME-1->LOOP-BREAK))))
     (COND (T FR-1)
           ((FRAME-1->LOOP-BREAK FR-1) FR-1)
           (T FR-1)))
    (REP-1 (+ -1 (NFIX J))
           (ENVIR-1-FIX L)
           (FRAME-1-FIX '((I . 1) (RESULT . 1) (LOOP-BREAK))))))
  (NOT (EQUAL (ELEMENT-EQ 0 (+ -1 (NFIX J)) A)
              1))
  (INTEGERP I)
  (< 0 I)
  L (TRUE-LISTP L)
  (INTEGERP J)
  (EQUAL (FRAME-1->RESULT (REP-1 J
                                 L '((I . 1) (RESULT . 1) (LOOP-BREAK))))
         1)
  (EQUAL (ELEMENT-EQ 0 J A) 1)
  (INTEGER-LISTP A)
  (INTEGERP N)
  (<= 0 N)
  (< 0 N)
  (<= N (LEN A))
  (NOT (EQUAL (NTH J A) (NTH I A))))
 (NOT (FRAME-1->LOOP-BREAK (REP-1 J L
                                  '((I . 1) (RESULT . 1) (LOOP-BREAK)))))).
#<\<0( DEFTHM VERIFICATION-CONDITION-1 ...)
c  0 Goal PUSH *1
++++++++++++++++++++++++++++++
c  2 *1 INDUCT
   1 |  Subgoal *1/2 preprocess
   2 |  |  Subgoal *1/2' simp
   7 |  |  |  Subgoal *1/2.2 simp
   1 |  |  |  |  Subgoal *1/2.2.5 simp
   1 |  |  |  |  |  Subgoal *1/2.2.5' simp
c  1 |  |  |  |  |  |  Subgoal *1/2.2.5'' GEN
   1 |  |  |  |  |  |  |  Subgoal *1/2.2.5''' simp
c  0 |  |  |  |  |  |  |  |  Subgoal *1/2.2.5'4' PUSH *1.1
++++++++++++++++++++++++++++++
c 22 *1.1 INDUCT
   1 |  Subgoal *1.1/13 preprocess
     |  |  <1 subgoal>
     |  <12 more subgoals>
#>\>
By the :congruence rules ENVIR-1->A$INLINE-ENVIR-1-EQUIV-CONGRUENCE-ON-X,
ENVIR-1->LOOP-COUNTER-SHIFT$INLINE-ENVIR-1-EQUIV-CONGRUENCE-ON-X and
NAT-EQUIV-IMPLIES-EQUAL-ZP-1, the :executable-counterpart of 
FRAME-1-FIX$INLINE and the simple :rewrite rules ASSOCIATIVITY-OF-+,
ENVIR-1-FIX-UNDER-ENVIR-1-EQUIV and NFIX-UNDER-NAT-EQUIV we reduce
the conjecture to

Subgoal *1.1/13'
(IMPLIES
 (AND
  (NOT (ZP J))
  (NOT (FRAME-1->LOOP-BREAK (REP-1 (+ -1 (NFIX J))
                                   (ENVIR-1-FIX L)
                                   '((I . 1) (RESULT . 1) (LOOP-BREAK)))))
  (FRAME-1->LOOP-BREAK
   (IF
    (NOT (EQUAL (NTH (+ -1 -1 (NFIX J)
                        (ENVIR-1->LOOP-COUNTER-SHIFT L))
                     (ENVIR-1->A L))
                (NTH (+ -1 (NFIX J)
                        (ENVIR-1->LOOP-COUNTER-SHIFT L))
                     (ENVIR-1->A L))))
    (LET
     ((CHANGE-FRAME-1
          (LET ((CHANGE-FRAME-1 (REP-1 (+ -1 (NFIX J))
                                       (ENVIR-1-FIX L)
                                       '((I . 1) (RESULT . 1) (LOOP-BREAK))))
                (FRAME-1->RESULT 0))
               (FRAME-1 (FRAME-1->I CHANGE-FRAME-1)
                        FRAME-1->RESULT
                        (FRAME-1->LOOP-BREAK CHANGE-FRAME-1))))
      (FRAME-1->LOOP-BREAK T))
     (FRAME-1 (FRAME-1->I CHANGE-FRAME-1)
              (FRAME-1->RESULT CHANGE-FRAME-1)
              FRAME-1->LOOP-BREAK))
    (REP-1 (+ -1 (NFIX J))
           (ENVIR-1-FIX L)
           '((I . 1) (RESULT . 1) (LOOP-BREAK)))))
  (NOT (EQUAL (ELEMENT-EQ 0 (+ -1 (NFIX J)) A)
              1))
  (INTEGERP I)
  (< 0 I)
  L (TRUE-LISTP L)
  (INTEGERP J)
  (EQUAL (FRAME-1->RESULT (REP-1 J
                                 L '((I . 1) (RESULT . 1) (LOOP-BREAK))))
         1)
  (EQUAL (ELEMENT-EQ 0 J A) 1)
  (INTEGER-LISTP A)
  (INTEGERP N)
  (<= 0 N)
  (< 0 N)
  (<= N (LEN A))
  (NOT (EQUAL (NTH J A) (NTH I A))))
 (NOT (FRAME-1->LOOP-BREAK (REP-1 J L
                                  '((I . 1) (RESULT . 1) (LOOP-BREAK)))))).
#<\<0( DEFTHM VERIFICATION-CONDITION-1 ...)
c  0 Goal PUSH *1
++++++++++++++++++++++++++++++
c  2 *1 INDUCT
   1 |  Subgoal *1/2 preprocess
   2 |  |  Subgoal *1/2' simp
   7 |  |  |  Subgoal *1/2.2 simp
   1 |  |  |  |  Subgoal *1/2.2.5 simp
   1 |  |  |  |  |  Subgoal *1/2.2.5' simp
c  1 |  |  |  |  |  |  Subgoal *1/2.2.5'' GEN
   1 |  |  |  |  |  |  |  Subgoal *1/2.2.5''' simp
c  0 |  |  |  |  |  |  |  |  Subgoal *1/2.2.5'4' PUSH *1.1
++++++++++++++++++++++++++++++
c 22 *1.1 INDUCT
   1 |  Subgoal *1.1/13 preprocess
   1 |  |  Subgoal *1.1/13' simp
     |  |  |  <1 subgoal>
     |  <12 more subgoals>
#>\>
This simplifies, using the :executable-counterpart of EQUAL, linear
arithmetic and the :type-prescription rule ELEMENT-EQ, to

Subgoal *1.1/13''
(IMPLIES
 (AND
  (EQUAL (ELEMENT-EQ 0 (+ -1 (NFIX J)) A)
         0)
  (NOT (ZP J))
  (NOT (FRAME-1->LOOP-BREAK (REP-1 (+ -1 (NFIX J))
                                   (ENVIR-1-FIX L)
                                   '((I . 1) (RESULT . 1) (LOOP-BREAK)))))
  (FRAME-1->LOOP-BREAK
   (IF
    (NOT (EQUAL (NTH (+ -1 -1 (NFIX J)
                        (ENVIR-1->LOOP-COUNTER-SHIFT L))
                     (ENVIR-1->A L))
                (NTH (+ -1 (NFIX J)
                        (ENVIR-1->LOOP-COUNTER-SHIFT L))
                     (ENVIR-1->A L))))
    (LET
     ((CHANGE-FRAME-1
          (LET ((CHANGE-FRAME-1 (REP-1 (+ -1 (NFIX J))
                                       (ENVIR-1-FIX L)
                                       '((I . 1) (RESULT . 1) (LOOP-BREAK))))
                (FRAME-1->RESULT 0))
               (FRAME-1 (FRAME-1->I CHANGE-FRAME-1)
                        FRAME-1->RESULT
                        (FRAME-1->LOOP-BREAK CHANGE-FRAME-1))))
      (FRAME-1->LOOP-BREAK T))
     (FRAME-1 (FRAME-1->I CHANGE-FRAME-1)
              (FRAME-1->RESULT CHANGE-FRAME-1)
              FRAME-1->LOOP-BREAK))
    (REP-1 (+ -1 (NFIX J))
           (ENVIR-1-FIX L)
           '((I . 1) (RESULT . 1) (LOOP-BREAK)))))
  (INTEGERP I)
  (< 0 I)
  L (TRUE-LISTP L)
  (INTEGERP J)
  (EQUAL (FRAME-1->RESULT (REP-1 J
                                 L '((I . 1) (RESULT . 1) (LOOP-BREAK))))
         1)
  (EQUAL (ELEMENT-EQ 0 J A) 1)
  (INTEGER-LISTP A)
  (INTEGERP N)
  (<= 0 N)
  (< 0 N)
  (<= N (LEN A))
  (NOT (EQUAL (NTH J A) (NTH I A))))
 (NOT (FRAME-1->LOOP-BREAK (REP-1 J L
                                  '((I . 1) (RESULT . 1) (LOOP-BREAK)))))).
#<\<0( DEFTHM VERIFICATION-CONDITION-1 ...)
c  0 Goal PUSH *1
++++++++++++++++++++++++++++++
c  2 *1 INDUCT
   1 |  Subgoal *1/2 preprocess
   2 |  |  Subgoal *1/2' simp
   7 |  |  |  Subgoal *1/2.2 simp
   1 |  |  |  |  Subgoal *1/2.2.5 simp
   1 |  |  |  |  |  Subgoal *1/2.2.5' simp
c  1 |  |  |  |  |  |  Subgoal *1/2.2.5'' GEN
   1 |  |  |  |  |  |  |  Subgoal *1/2.2.5''' simp
c  0 |  |  |  |  |  |  |  |  Subgoal *1/2.2.5'4' PUSH *1.1
++++++++++++++++++++++++++++++
c 22 *1.1 INDUCT
     |  <12 more subgoals>
#>\>
But simplification reduces this to T, using the :compound-recognizer
rules NATP-COMPOUND-RECOGNIZER and ZP-COMPOUND-RECOGNIZER, the :congruence
rules FRAME-1-IFF-CONGRUENCE-ON-LOOP-BREAK, 
FRAME-1-INT-EQUIV-CONGRUENCE-ON-I and IFF-IMPLIES-EQUAL-BOOL-FIX-1,
the :definitions ELEMENT-EQ, NFIX, NOT, REP-1 and SYNP, the :executable-
counterparts of BINARY-+, BOOL-FIX$INLINE, EQUAL, FRAME-1-FIX$INLINE,
IFIX and NATP, primitive type reasoning and the :rewrite rules 
COMMUTATIVITY-2-OF-+, COMMUTATIVITY-OF-+, ENVIR-1->A$INLINE-OF-ENVIR-1-FIX-X,
ENVIR-1->LOOP-COUNTER-SHIFT$INLINE-OF-ENVIR-1-FIX-X, FOLD-CONSTS-IN-+,
FRAME-1->I-OF-FRAME-1, FRAME-1->LOOP-BREAK-OF-FRAME-1, 
FRAME-1->RESULT-OF-FRAME-1 and IFIX-UNDER-INT-EQUIV.

Subgoal *1.1/12
(IMPLIES
 (AND
  (NOT (ZP (NFIX J)))
  (NOT (FRAME-1->LOOP-BREAK
            (REP-1 (+ -1 (NFIX J))
                   (ENVIR-1-FIX L)
                   (FRAME-1-FIX '((I . 1) (RESULT . 1) (LOOP-BREAK))))))
  (FRAME-1->LOOP-BREAK
   (IF
    (NOT (EQUAL (NTH (+ -1 (+ -1 (NFIX J))
                        (ENVIR-1->LOOP-COUNTER-SHIFT (ENVIR-1-FIX L)))
                     (ENVIR-1->A (ENVIR-1-FIX L)))
                (NTH (+ (+ -1 (NFIX J))
                        (ENVIR-1->LOOP-COUNTER-SHIFT (ENVIR-1-FIX L)))
                     (ENVIR-1->A (ENVIR-1-FIX L)))))
    (LET*
     ((FR-1
       (LET ((CHANGE-FRAME-1
                  (REP-1 (+ -1 (NFIX J))
                         (ENVIR-1-FIX L)
                         (FRAME-1-FIX '((I . 1) (RESULT . 1) (LOOP-BREAK)))))
             (FRAME-1->RESULT 0))
            (FRAME-1 (FRAME-1->I CHANGE-FRAME-1)
                     FRAME-1->RESULT
                     (FRAME-1->LOOP-BREAK CHANGE-FRAME-1))))
      (FR-1 (LET ((CHANGE-FRAME-1 FR-1)
                  (FRAME-1->LOOP-BREAK T))
                 (FRAME-1 (FRAME-1->I CHANGE-FRAME-1)
                          (FRAME-1->RESULT CHANGE-FRAME-1)
                          FRAME-1->LOOP-BREAK))))
     (COND (T FR-1)
           ((FRAME-1->LOOP-BREAK FR-1) FR-1)
           (T FR-1)))
    (REP-1 (+ -1 (NFIX J))
           (ENVIR-1-FIX L)
           (FRAME-1-FIX '((I . 1) (RESULT . 1) (LOOP-BREAK))))))
  (NOT (EQUAL (FRAME-1->RESULT (REP-1 (+ -1 (NFIX J))
                                      (ENVIR-1-FIX L)
                                      '((I . 1) (RESULT . 1) (LOOP-BREAK))))
              1))
  (INTEGERP I)
  (< 0 I)
  L (TRUE-LISTP L)
  (INTEGERP J)
  (EQUAL (FRAME-1->RESULT (REP-1 J
                                 L '((I . 1) (RESULT . 1) (LOOP-BREAK))))
         1)
  (EQUAL (ELEMENT-EQ 0 J A) 1)
  (INTEGER-LISTP A)
  (INTEGERP N)
  (<= 0 N)
  (< 0 N)
  (<= N (LEN A))
  (NOT (EQUAL (NTH J A) (NTH I A))))
 (NOT (FRAME-1->LOOP-BREAK (REP-1 J L
                                  '((I . 1) (RESULT . 1) (LOOP-BREAK)))))).
#<\<0( DEFTHM VERIFICATION-CONDITION-1 ...)
c  0 Goal PUSH *1
++++++++++++++++++++++++++++++
c  2 *1 INDUCT
   1 |  Subgoal *1/2 preprocess
   2 |  |  Subgoal *1/2' simp
   7 |  |  |  Subgoal *1/2.2 simp
   1 |  |  |  |  Subgoal *1/2.2.5 simp
   1 |  |  |  |  |  Subgoal *1/2.2.5' simp
c  1 |  |  |  |  |  |  Subgoal *1/2.2.5'' GEN
   1 |  |  |  |  |  |  |  Subgoal *1/2.2.5''' simp
c  0 |  |  |  |  |  |  |  |  Subgoal *1/2.2.5'4' PUSH *1.1
++++++++++++++++++++++++++++++
c 22 *1.1 INDUCT
   1 |  Subgoal *1.1/12 preprocess
     |  |  <1 subgoal>
     |  <11 more subgoals>
#>\>
By the :congruence rules ENVIR-1->A$INLINE-ENVIR-1-EQUIV-CONGRUENCE-ON-X,
ENVIR-1->LOOP-COUNTER-SHIFT$INLINE-ENVIR-1-EQUIV-CONGRUENCE-ON-X and
NAT-EQUIV-IMPLIES-EQUAL-ZP-1, the :executable-counterpart of 
FRAME-1-FIX$INLINE and the simple :rewrite rules ASSOCIATIVITY-OF-+,
ENVIR-1-FIX-UNDER-ENVIR-1-EQUIV and NFIX-UNDER-NAT-EQUIV we reduce
the conjecture to

Subgoal *1.1/12'
(IMPLIES
 (AND
  (NOT (ZP J))
  (NOT (FRAME-1->LOOP-BREAK (REP-1 (+ -1 (NFIX J))
                                   (ENVIR-1-FIX L)
                                   '((I . 1) (RESULT . 1) (LOOP-BREAK)))))
  (FRAME-1->LOOP-BREAK
   (IF
    (NOT (EQUAL (NTH (+ -1 -1 (NFIX J)
                        (ENVIR-1->LOOP-COUNTER-SHIFT L))
                     (ENVIR-1->A L))
                (NTH (+ -1 (NFIX J)
                        (ENVIR-1->LOOP-COUNTER-SHIFT L))
                     (ENVIR-1->A L))))
    (LET
     ((CHANGE-FRAME-1
          (LET ((CHANGE-FRAME-1 (REP-1 (+ -1 (NFIX J))
                                       (ENVIR-1-FIX L)
                                       '((I . 1) (RESULT . 1) (LOOP-BREAK))))
                (FRAME-1->RESULT 0))
               (FRAME-1 (FRAME-1->I CHANGE-FRAME-1)
                        FRAME-1->RESULT
                        (FRAME-1->LOOP-BREAK CHANGE-FRAME-1))))
      (FRAME-1->LOOP-BREAK T))
     (FRAME-1 (FRAME-1->I CHANGE-FRAME-1)
              (FRAME-1->RESULT CHANGE-FRAME-1)
              FRAME-1->LOOP-BREAK))
    (REP-1 (+ -1 (NFIX J))
           (ENVIR-1-FIX L)
           '((I . 1) (RESULT . 1) (LOOP-BREAK)))))
  (NOT (EQUAL (FRAME-1->RESULT (REP-1 (+ -1 (NFIX J))
                                      (ENVIR-1-FIX L)
                                      '((I . 1) (RESULT . 1) (LOOP-BREAK))))
              1))
  (INTEGERP I)
  (< 0 I)
  L (TRUE-LISTP L)
  (INTEGERP J)
  (EQUAL (FRAME-1->RESULT (REP-1 J
                                 L '((I . 1) (RESULT . 1) (LOOP-BREAK))))
         1)
  (EQUAL (ELEMENT-EQ 0 J A) 1)
  (INTEGER-LISTP A)
  (INTEGERP N)
  (<= 0 N)
  (< 0 N)
  (<= N (LEN A))
  (NOT (EQUAL (NTH J A) (NTH I A))))
 (NOT (FRAME-1->LOOP-BREAK (REP-1 J L
                                  '((I . 1) (RESULT . 1) (LOOP-BREAK)))))).
#<\<0( DEFTHM VERIFICATION-CONDITION-1 ...)
c  0 Goal PUSH *1
++++++++++++++++++++++++++++++
c  2 *1 INDUCT
   1 |  Subgoal *1/2 preprocess
   2 |  |  Subgoal *1/2' simp
   7 |  |  |  Subgoal *1/2.2 simp
   1 |  |  |  |  Subgoal *1/2.2.5 simp
   1 |  |  |  |  |  Subgoal *1/2.2.5' simp
c  1 |  |  |  |  |  |  Subgoal *1/2.2.5'' GEN
   1 |  |  |  |  |  |  |  Subgoal *1/2.2.5''' simp
c  0 |  |  |  |  |  |  |  |  Subgoal *1/2.2.5'4' PUSH *1.1
++++++++++++++++++++++++++++++
c 22 *1.1 INDUCT
   1 |  Subgoal *1.1/12 preprocess
   2 |  |  Subgoal *1.1/12' simp
     |  |  |  <2 subgoals>
     |  <11 more subgoals>
#>\>
This simplifies, using the :compound-recognizer rule ZP-COMPOUND-RECOGNIZER,
the :congruence rules FRAME-1-IFF-CONGRUENCE-ON-LOOP-BREAK, 
FRAME-1-INT-EQUIV-CONGRUENCE-ON-I and IFF-IMPLIES-EQUAL-BOOL-FIX-1,
the :definitions NFIX, NOT (if-intro), REP-1 (if-intro) and SYNP, the
:executable-counterparts of BINARY-+, BOOL-FIX$INLINE, FRAME-1-FIX$INLINE
and IFIX, primitive type reasoning, the :rewrite rules COMMUTATIVITY-2-OF-+,
COMMUTATIVITY-OF-+, ENVIR-1->A$INLINE-OF-ENVIR-1-FIX-X, 
ENVIR-1->LOOP-COUNTER-SHIFT$INLINE-OF-ENVIR-1-FIX-X, FOLD-CONSTS-IN-+,
FRAME-1->I-OF-FRAME-1, FRAME-1->LOOP-BREAK-OF-FRAME-1, 
FRAME-1->RESULT-OF-FRAME-1 and IFIX-UNDER-INT-EQUIV and the :type-
prescription rule FRAME-1->LOOP-BREAK$INLINE, to the following two
conjectures.

Subgoal *1.1/12.2
(IMPLIES
 (AND
   (NOT (ZP J))
   (NOT (FRAME-1->LOOP-BREAK (REP-1 (+ -1 (NFIX J))
                                    (ENVIR-1-FIX L)
                                    '((I . 1) (RESULT . 1) (LOOP-BREAK)))))
   (NOT (EQUAL (NTH (+ -2 J (ENVIR-1->LOOP-COUNTER-SHIFT L))
                    (ENVIR-1->A L))
               (NTH (+ -1 J (ENVIR-1->LOOP-COUNTER-SHIFT L))
                    (ENVIR-1->A L))))
   (FRAME-1->LOOP-BREAK
        (FRAME-1 (FRAME-1->I (REP-1 (+ -1 (NFIX J))
                                    (ENVIR-1-FIX L)
                                    '((I . 1) (RESULT . 1) (LOOP-BREAK))))
                 0 T))
   (NOT (EQUAL (FRAME-1->RESULT (REP-1 (+ -1 (NFIX J))
                                       (ENVIR-1-FIX L)
                                       '((I . 1) (RESULT . 1) (LOOP-BREAK))))
               1))
   (INTEGERP I)
   (< 0 I)
   L (TRUE-LISTP L)
   (FRAME-1->LOOP-BREAK (REP-1 (+ -1 J)
                               (ENVIR-1-FIX L)
                               '((I . 1) (RESULT . 1) (LOOP-BREAK))))
   (EQUAL (FRAME-1->RESULT (REP-1 (+ -1 J)
                                  (ENVIR-1-FIX L)
                                  '((I . 1) (RESULT . 1) (LOOP-BREAK))))
          1)
   (EQUAL (ELEMENT-EQ 0 J A) 1)
   (INTEGER-LISTP A)
   (INTEGERP N)
   (<= 0 N)
   (< 0 N)
   (<= N (LEN A)))
 (EQUAL (NTH J A) (NTH I A))).
#<\<0( DEFTHM VERIFICATION-CONDITION-1 ...)
c  0 Goal PUSH *1
++++++++++++++++++++++++++++++
c  2 *1 INDUCT
   1 |  Subgoal *1/2 preprocess
   2 |  |  Subgoal *1/2' simp
   7 |  |  |  Subgoal *1/2.2 simp
   1 |  |  |  |  Subgoal *1/2.2.5 simp
   1 |  |  |  |  |  Subgoal *1/2.2.5' simp
c  1 |  |  |  |  |  |  Subgoal *1/2.2.5'' GEN
   1 |  |  |  |  |  |  |  Subgoal *1/2.2.5''' simp
c  0 |  |  |  |  |  |  |  |  Subgoal *1/2.2.5'4' PUSH *1.1
++++++++++++++++++++++++++++++
c 22 *1.1 INDUCT
   1 |  Subgoal *1.1/12 preprocess
   2 |  |  Subgoal *1.1/12' simp
   1 |  |  |  Subgoal *1.1/12.2 preprocess
     |  |  |  |  <1 subgoal>
     |  |  |  <1 more subgoal>
     |  <11 more subgoals>
#>\>
By the :executable-counterpart of BOOL-FIX$INLINE and the simple :rewrite
rule FRAME-1->LOOP-BREAK-OF-FRAME-1 we reduce the conjecture to

Subgoal *1.1/12.2'
(IMPLIES
 (AND
   (NOT (ZP J))
   (NOT (FRAME-1->LOOP-BREAK (REP-1 (+ -1 (NFIX J))
                                    (ENVIR-1-FIX L)
                                    '((I . 1) (RESULT . 1) (LOOP-BREAK)))))
   (NOT (EQUAL (NTH (+ -2 J (ENVIR-1->LOOP-COUNTER-SHIFT L))
                    (ENVIR-1->A L))
               (NTH (+ -1 J (ENVIR-1->LOOP-COUNTER-SHIFT L))
                    (ENVIR-1->A L))))
   (NOT (EQUAL (FRAME-1->RESULT (REP-1 (+ -1 (NFIX J))
                                       (ENVIR-1-FIX L)
                                       '((I . 1) (RESULT . 1) (LOOP-BREAK))))
               1))
   (INTEGERP I)
   (< 0 I)
   L (TRUE-LISTP L)
   (FRAME-1->LOOP-BREAK (REP-1 (+ -1 J)
                               (ENVIR-1-FIX L)
                               '((I . 1) (RESULT . 1) (LOOP-BREAK))))
   (EQUAL (FRAME-1->RESULT (REP-1 (+ -1 J)
                                  (ENVIR-1-FIX L)
                                  '((I . 1) (RESULT . 1) (LOOP-BREAK))))
          1)
   (EQUAL (ELEMENT-EQ 0 J A) 1)
   (INTEGER-LISTP A)
   (INTEGERP N)
   (<= 0 N)
   (< 0 N)
   (<= N (LEN A)))
 (EQUAL (NTH J A) (NTH I A))).
#<\<0( DEFTHM VERIFICATION-CONDITION-1 ...)
c  0 Goal PUSH *1
++++++++++++++++++++++++++++++
c  2 *1 INDUCT
   1 |  Subgoal *1/2 preprocess
   2 |  |  Subgoal *1/2' simp
   7 |  |  |  Subgoal *1/2.2 simp
   1 |  |  |  |  Subgoal *1/2.2.5 simp
   1 |  |  |  |  |  Subgoal *1/2.2.5' simp
c  1 |  |  |  |  |  |  Subgoal *1/2.2.5'' GEN
   1 |  |  |  |  |  |  |  Subgoal *1/2.2.5''' simp
c  0 |  |  |  |  |  |  |  |  Subgoal *1/2.2.5'4' PUSH *1.1
++++++++++++++++++++++++++++++
c 22 *1.1 INDUCT
   1 |  Subgoal *1.1/12 preprocess
   2 |  |  Subgoal *1.1/12' simp
     |  |  |  <1 more subgoal>
     |  <11 more subgoals>
#>\>
But simplification reduces this to T, using the :compound-recognizer
rule ZP-COMPOUND-RECOGNIZER, the :definition NFIX, primitive type reasoning
and the :type-prescription rule FRAME-1->LOOP-BREAK$INLINE.

Subgoal *1.1/12.1
(IMPLIES
 (AND
  (NOT (ZP J))
  (NOT (FRAME-1->LOOP-BREAK (REP-1 (+ -1 (NFIX J))
                                   (ENVIR-1-FIX L)
                                   '((I . 1) (RESULT . 1) (LOOP-BREAK)))))
  (NOT (EQUAL (NTH (+ -2 J (ENVIR-1->LOOP-COUNTER-SHIFT L))
                   (ENVIR-1->A L))
              (NTH (+ -1 J (ENVIR-1->LOOP-COUNTER-SHIFT L))
                   (ENVIR-1->A L))))
  (FRAME-1->LOOP-BREAK
       (FRAME-1 (FRAME-1->I (REP-1 (+ -1 (NFIX J))
                                   (ENVIR-1-FIX L)
                                   '((I . 1) (RESULT . 1) (LOOP-BREAK))))
                0 T))
  (NOT (EQUAL (FRAME-1->RESULT (REP-1 (+ -1 (NFIX J))
                                      (ENVIR-1-FIX L)
                                      '((I . 1) (RESULT . 1) (LOOP-BREAK))))
              1))
  (INTEGERP I)
  (< 0 I)
  L (TRUE-LISTP L)
  (NOT (FRAME-1->LOOP-BREAK (REP-1 (+ -1 J)
                                   (ENVIR-1-FIX L)
                                   '((I . 1) (RESULT . 1) (LOOP-BREAK)))))
  (EQUAL
      (FRAME-1->RESULT
           (FRAME-1 (FRAME-1->I (REP-1 (+ -1 J)
                                       (ENVIR-1-FIX L)
                                       '((I . 1) (RESULT . 1) (LOOP-BREAK))))
                    0 T))
      1)
  (EQUAL (ELEMENT-EQ 0 J A) 1)
  (INTEGER-LISTP A)
  (INTEGERP N)
  (<= 0 N)
  (< 0 N)
  (<= N (LEN A)))
 (EQUAL (NTH J A) (NTH I A))).
#<\<0( DEFTHM VERIFICATION-CONDITION-1 ...)
c  0 Goal PUSH *1
++++++++++++++++++++++++++++++
c  2 *1 INDUCT
   1 |  Subgoal *1/2 preprocess
   2 |  |  Subgoal *1/2' simp
   7 |  |  |  Subgoal *1/2.2 simp
   1 |  |  |  |  Subgoal *1/2.2.5 simp
   1 |  |  |  |  |  Subgoal *1/2.2.5' simp
c  1 |  |  |  |  |  |  Subgoal *1/2.2.5'' GEN
   1 |  |  |  |  |  |  |  Subgoal *1/2.2.5''' simp
c  0 |  |  |  |  |  |  |  |  Subgoal *1/2.2.5'4' PUSH *1.1
++++++++++++++++++++++++++++++
c 22 *1.1 INDUCT
     |  <11 more subgoals>
#>\>
But we reduce the conjecture to T, by the :executable-counterparts
of BOOL-FIX$INLINE, EQUAL, IF and IFIX and the simple :rewrite rules
FRAME-1->LOOP-BREAK-OF-FRAME-1 and FRAME-1->RESULT-OF-FRAME-1.

Subgoal *1.1/11
(IMPLIES
 (AND
  (NOT (ZP (NFIX J)))
  (NOT (FRAME-1->LOOP-BREAK
            (REP-1 (+ -1 (NFIX J))
                   (ENVIR-1-FIX L)
                   (FRAME-1-FIX '((I . 1) (RESULT . 1) (LOOP-BREAK))))))
  (FRAME-1->LOOP-BREAK
   (IF
    (NOT (EQUAL (NTH (+ -1 (+ -1 (NFIX J))
                        (ENVIR-1->LOOP-COUNTER-SHIFT (ENVIR-1-FIX L)))
                     (ENVIR-1->A (ENVIR-1-FIX L)))
                (NTH (+ (+ -1 (NFIX J))
                        (ENVIR-1->LOOP-COUNTER-SHIFT (ENVIR-1-FIX L)))
                     (ENVIR-1->A (ENVIR-1-FIX L)))))
    (LET*
     ((FR-1
       (LET ((CHANGE-FRAME-1
                  (REP-1 (+ -1 (NFIX J))
                         (ENVIR-1-FIX L)
                         (FRAME-1-FIX '((I . 1) (RESULT . 1) (LOOP-BREAK)))))
             (FRAME-1->RESULT 0))
            (FRAME-1 (FRAME-1->I CHANGE-FRAME-1)
                     FRAME-1->RESULT
                     (FRAME-1->LOOP-BREAK CHANGE-FRAME-1))))
      (FR-1 (LET ((CHANGE-FRAME-1 FR-1)
                  (FRAME-1->LOOP-BREAK T))
                 (FRAME-1 (FRAME-1->I CHANGE-FRAME-1)
                          (FRAME-1->RESULT CHANGE-FRAME-1)
                          FRAME-1->LOOP-BREAK))))
     (COND (T FR-1)
           ((FRAME-1->LOOP-BREAK FR-1) FR-1)
           (T FR-1)))
    (REP-1 (+ -1 (NFIX J))
           (ENVIR-1-FIX L)
           (FRAME-1-FIX '((I . 1) (RESULT . 1) (LOOP-BREAK))))))
  (NOT (INTEGERP (+ -1 (NFIX J))))
  (INTEGERP I)
  (< 0 I)
  L (TRUE-LISTP L)
  (INTEGERP J)
  (EQUAL (FRAME-1->RESULT (REP-1 J
                                 L '((I . 1) (RESULT . 1) (LOOP-BREAK))))
         1)
  (EQUAL (ELEMENT-EQ 0 J A) 1)
  (INTEGER-LISTP A)
  (INTEGERP N)
  (<= 0 N)
  (< 0 N)
  (<= N (LEN A))
  (NOT (EQUAL (NTH J A) (NTH I A))))
 (NOT (FRAME-1->LOOP-BREAK (REP-1 J L
                                  '((I . 1) (RESULT . 1) (LOOP-BREAK)))))).
#<\<0( DEFTHM VERIFICATION-CONDITION-1 ...)
c  0 Goal PUSH *1
++++++++++++++++++++++++++++++
c  2 *1 INDUCT
   1 |  Subgoal *1/2 preprocess
   2 |  |  Subgoal *1/2' simp
   7 |  |  |  Subgoal *1/2.2 simp
   1 |  |  |  |  Subgoal *1/2.2.5 simp
   1 |  |  |  |  |  Subgoal *1/2.2.5' simp
c  1 |  |  |  |  |  |  Subgoal *1/2.2.5'' GEN
   1 |  |  |  |  |  |  |  Subgoal *1/2.2.5''' simp
c  0 |  |  |  |  |  |  |  |  Subgoal *1/2.2.5'4' PUSH *1.1
++++++++++++++++++++++++++++++
c 22 *1.1 INDUCT
     |  <10 more subgoals>
#>\>
But we reduce the conjecture to T, by the :compound-recognizer rule
ZP-COMPOUND-RECOGNIZER and the :type-prescription rule NFIX.

Subgoal *1.1/10
(IMPLIES
 (AND
  (NOT (ZP (NFIX J)))
  (NOT (FRAME-1->LOOP-BREAK
            (REP-1 (+ -1 (NFIX J))
                   (ENVIR-1-FIX L)
                   (FRAME-1-FIX '((I . 1) (RESULT . 1) (LOOP-BREAK))))))
  (FRAME-1->LOOP-BREAK
   (IF
    (NOT (EQUAL (NTH (+ -1 (+ -1 (NFIX J))
                        (ENVIR-1->LOOP-COUNTER-SHIFT (ENVIR-1-FIX L)))
                     (ENVIR-1->A (ENVIR-1-FIX L)))
                (NTH (+ (+ -1 (NFIX J))
                        (ENVIR-1->LOOP-COUNTER-SHIFT (ENVIR-1-FIX L)))
                     (ENVIR-1->A (ENVIR-1-FIX L)))))
    (LET*
     ((FR-1
       (LET ((CHANGE-FRAME-1
                  (REP-1 (+ -1 (NFIX J))
                         (ENVIR-1-FIX L)
                         (FRAME-1-FIX '((I . 1) (RESULT . 1) (LOOP-BREAK)))))
             (FRAME-1->RESULT 0))
            (FRAME-1 (FRAME-1->I CHANGE-FRAME-1)
                     FRAME-1->RESULT
                     (FRAME-1->LOOP-BREAK CHANGE-FRAME-1))))
      (FR-1 (LET ((CHANGE-FRAME-1 FR-1)
                  (FRAME-1->LOOP-BREAK T))
                 (FRAME-1 (FRAME-1->I CHANGE-FRAME-1)
                          (FRAME-1->RESULT CHANGE-FRAME-1)
                          FRAME-1->LOOP-BREAK))))
     (COND (T FR-1)
           ((FRAME-1->LOOP-BREAK FR-1) FR-1)
           (T FR-1)))
    (REP-1 (+ -1 (NFIX J))
           (ENVIR-1-FIX L)
           (FRAME-1-FIX '((I . 1) (RESULT . 1) (LOOP-BREAK))))))
  (NOT (TRUE-LISTP (ENVIR-1-FIX L)))
  (INTEGERP I)
  (< 0 I)
  L (TRUE-LISTP L)
  (INTEGERP J)
  (EQUAL (FRAME-1->RESULT (REP-1 J
                                 L '((I . 1) (RESULT . 1) (LOOP-BREAK))))
         1)
  (EQUAL (ELEMENT-EQ 0 J A) 1)
  (INTEGER-LISTP A)
  (INTEGERP N)
  (<= 0 N)
  (< 0 N)
  (<= N (LEN A))
  (NOT (EQUAL (NTH J A) (NTH I A))))
 (NOT (FRAME-1->LOOP-BREAK (REP-1 J L
                                  '((I . 1) (RESULT . 1) (LOOP-BREAK)))))).
#<\<0( DEFTHM VERIFICATION-CONDITION-1 ...)
c  0 Goal PUSH *1
++++++++++++++++++++++++++++++
c  2 *1 INDUCT
   1 |  Subgoal *1/2 preprocess
   2 |  |  Subgoal *1/2' simp
   7 |  |  |  Subgoal *1/2.2 simp
   1 |  |  |  |  Subgoal *1/2.2.5 simp
   1 |  |  |  |  |  Subgoal *1/2.2.5' simp
c  1 |  |  |  |  |  |  Subgoal *1/2.2.5'' GEN
   1 |  |  |  |  |  |  |  Subgoal *1/2.2.5''' simp
c  0 |  |  |  |  |  |  |  |  Subgoal *1/2.2.5'4' PUSH *1.1
++++++++++++++++++++++++++++++
c 22 *1.1 INDUCT
     |  <9 more subgoals>
#>\>
But we reduce the conjecture to T, by the :type-prescription rule 
ENVIR-1-FIX$INLINE.

Subgoal *1.1/9
(IMPLIES
 (AND
  (NOT (ZP (NFIX J)))
  (NOT (FRAME-1->LOOP-BREAK
            (REP-1 (+ -1 (NFIX J))
                   (ENVIR-1-FIX L)
                   (FRAME-1-FIX '((I . 1) (RESULT . 1) (LOOP-BREAK))))))
  (FRAME-1->LOOP-BREAK
   (IF
    (NOT (EQUAL (NTH (+ -1 (+ -1 (NFIX J))
                        (ENVIR-1->LOOP-COUNTER-SHIFT (ENVIR-1-FIX L)))
                     (ENVIR-1->A (ENVIR-1-FIX L)))
                (NTH (+ (+ -1 (NFIX J))
                        (ENVIR-1->LOOP-COUNTER-SHIFT (ENVIR-1-FIX L)))
                     (ENVIR-1->A (ENVIR-1-FIX L)))))
    (LET*
     ((FR-1
       (LET ((CHANGE-FRAME-1
                  (REP-1 (+ -1 (NFIX J))
                         (ENVIR-1-FIX L)
                         (FRAME-1-FIX '((I . 1) (RESULT . 1) (LOOP-BREAK)))))
             (FRAME-1->RESULT 0))
            (FRAME-1 (FRAME-1->I CHANGE-FRAME-1)
                     FRAME-1->RESULT
                     (FRAME-1->LOOP-BREAK CHANGE-FRAME-1))))
      (FR-1 (LET ((CHANGE-FRAME-1 FR-1)
                  (FRAME-1->LOOP-BREAK T))
                 (FRAME-1 (FRAME-1->I CHANGE-FRAME-1)
                          (FRAME-1->RESULT CHANGE-FRAME-1)
                          FRAME-1->LOOP-BREAK))))
     (COND (T FR-1)
           ((FRAME-1->LOOP-BREAK FR-1) FR-1)
           (T FR-1)))
    (REP-1 (+ -1 (NFIX J))
           (ENVIR-1-FIX L)
           (FRAME-1-FIX '((I . 1) (RESULT . 1) (LOOP-BREAK))))))
  (NOT (ENVIR-1-FIX L))
  (INTEGERP I)
  (< 0 I)
  L (TRUE-LISTP L)
  (INTEGERP J)
  (EQUAL (FRAME-1->RESULT (REP-1 J
                                 L '((I . 1) (RESULT . 1) (LOOP-BREAK))))
         1)
  (EQUAL (ELEMENT-EQ 0 J A) 1)
  (INTEGER-LISTP A)
  (INTEGERP N)
  (<= 0 N)
  (< 0 N)
  (<= N (LEN A))
  (NOT (EQUAL (NTH J A) (NTH I A))))
 (NOT (FRAME-1->LOOP-BREAK (REP-1 J L
                                  '((I . 1) (RESULT . 1) (LOOP-BREAK)))))).
#<\<0( DEFTHM VERIFICATION-CONDITION-1 ...)
c  0 Goal PUSH *1
++++++++++++++++++++++++++++++
c  2 *1 INDUCT
   1 |  Subgoal *1/2 preprocess
   2 |  |  Subgoal *1/2' simp
   7 |  |  |  Subgoal *1/2.2 simp
   1 |  |  |  |  Subgoal *1/2.2.5 simp
   1 |  |  |  |  |  Subgoal *1/2.2.5' simp
c  1 |  |  |  |  |  |  Subgoal *1/2.2.5'' GEN
   1 |  |  |  |  |  |  |  Subgoal *1/2.2.5''' simp
c  0 |  |  |  |  |  |  |  |  Subgoal *1/2.2.5'4' PUSH *1.1
++++++++++++++++++++++++++++++
c 22 *1.1 INDUCT
     |  <8 more subgoals>
#>\>
But we reduce the conjecture to T, by the :type-prescription rule 
ENVIR-1-FIX$INLINE.

Subgoal *1.1/8
(IMPLIES
 (AND
     (NOT (ZP (NFIX J)))
     (FRAME-1->LOOP-BREAK
          (REP-1 (+ -1 (NFIX J))
                 (ENVIR-1-FIX L)
                 (FRAME-1-FIX '((I . 1) (RESULT . 1) (LOOP-BREAK)))))
     (NOT (FRAME-1->LOOP-BREAK (REP-1 (+ -1 (NFIX J))
                                      (ENVIR-1-FIX L)
                                      '((I . 1) (RESULT . 1) (LOOP-BREAK)))))
     (INTEGERP I)
     (< 0 I)
     L (TRUE-LISTP L)
     (INTEGERP J)
     (EQUAL (FRAME-1->RESULT (REP-1 J
                                    L '((I . 1) (RESULT . 1) (LOOP-BREAK))))
            1)
     (EQUAL (ELEMENT-EQ 0 J A) 1)
     (INTEGER-LISTP A)
     (INTEGERP N)
     (<= 0 N)
     (< 0 N)
     (<= N (LEN A))
     (NOT (EQUAL (NTH J A) (NTH I A))))
 (NOT (FRAME-1->LOOP-BREAK (REP-1 J L
                                  '((I . 1) (RESULT . 1) (LOOP-BREAK)))))).
#<\<0( DEFTHM VERIFICATION-CONDITION-1 ...)
c  0 Goal PUSH *1
++++++++++++++++++++++++++++++
c  2 *1 INDUCT
   1 |  Subgoal *1/2 preprocess
   2 |  |  Subgoal *1/2' simp
   7 |  |  |  Subgoal *1/2.2 simp
   1 |  |  |  |  Subgoal *1/2.2.5 simp
   1 |  |  |  |  |  Subgoal *1/2.2.5' simp
c  1 |  |  |  |  |  |  Subgoal *1/2.2.5'' GEN
   1 |  |  |  |  |  |  |  Subgoal *1/2.2.5''' simp
c  0 |  |  |  |  |  |  |  |  Subgoal *1/2.2.5'4' PUSH *1.1
++++++++++++++++++++++++++++++
c 22 *1.1 INDUCT
     |  <7 more subgoals>
#>\>
But we reduce the conjecture to T, by the :congruence rule 
NAT-EQUIV-IMPLIES-EQUAL-ZP-1, the :executable-counterpart of 
FRAME-1-FIX$INLINE and the simple :rewrite rule NFIX-UNDER-NAT-EQUIV.

Subgoal *1.1/7
(IMPLIES
 (AND (NOT (ZP (NFIX J)))
      (FRAME-1->LOOP-BREAK
           (REP-1 (+ -1 (NFIX J))
                  (ENVIR-1-FIX L)
                  (FRAME-1-FIX '((I . 1) (RESULT . 1) (LOOP-BREAK)))))
      (EQUAL (NTH (+ -1 (NFIX J)) A)
             (NTH I A))
      (INTEGERP I)
      (< 0 I)
      L (TRUE-LISTP L)
      (INTEGERP J)
      (EQUAL (FRAME-1->RESULT (REP-1 J
                                     L '((I . 1) (RESULT . 1) (LOOP-BREAK))))
             1)
      (EQUAL (ELEMENT-EQ 0 J A) 1)
      (INTEGER-LISTP A)
      (INTEGERP N)
      (<= 0 N)
      (< 0 N)
      (<= N (LEN A))
      (NOT (EQUAL (NTH J A) (NTH I A))))
 (NOT (FRAME-1->LOOP-BREAK (REP-1 J L
                                  '((I . 1) (RESULT . 1) (LOOP-BREAK)))))).
#<\<0( DEFTHM VERIFICATION-CONDITION-1 ...)
c  0 Goal PUSH *1
++++++++++++++++++++++++++++++
c  2 *1 INDUCT
   1 |  Subgoal *1/2 preprocess
   2 |  |  Subgoal *1/2' simp
   7 |  |  |  Subgoal *1/2.2 simp
   1 |  |  |  |  Subgoal *1/2.2.5 simp
   1 |  |  |  |  |  Subgoal *1/2.2.5' simp
c  1 |  |  |  |  |  |  Subgoal *1/2.2.5'' GEN
   1 |  |  |  |  |  |  |  Subgoal *1/2.2.5''' simp
c  0 |  |  |  |  |  |  |  |  Subgoal *1/2.2.5'4' PUSH *1.1
++++++++++++++++++++++++++++++
c 22 *1.1 INDUCT
   1 |  Subgoal *1.1/7 preprocess
     |  |  <1 subgoal>
     |  <6 more subgoals>
#>\>
By the :congruence rule NAT-EQUIV-IMPLIES-EQUAL-ZP-1, the :executable-
counterpart of FRAME-1-FIX$INLINE and the simple :rewrite rule 
NFIX-UNDER-NAT-EQUIV we reduce the conjecture to

Subgoal *1.1/7'
(IMPLIES
 (AND (NOT (ZP J))
      (FRAME-1->LOOP-BREAK (REP-1 (+ -1 (NFIX J))
                                  (ENVIR-1-FIX L)
                                  '((I . 1) (RESULT . 1) (LOOP-BREAK))))
      (EQUAL (NTH (+ -1 (NFIX J)) A)
             (NTH I A))
      (INTEGERP I)
      (< 0 I)
      L (TRUE-LISTP L)
      (INTEGERP J)
      (EQUAL (FRAME-1->RESULT (REP-1 J
                                     L '((I . 1) (RESULT . 1) (LOOP-BREAK))))
             1)
      (EQUAL (ELEMENT-EQ 0 J A) 1)
      (INTEGER-LISTP A)
      (INTEGERP N)
      (<= 0 N)
      (< 0 N)
      (<= N (LEN A))
      (NOT (EQUAL (NTH J A) (NTH I A))))
 (NOT (FRAME-1->LOOP-BREAK (REP-1 J L
                                  '((I . 1) (RESULT . 1) (LOOP-BREAK)))))).
#<\<0( DEFTHM VERIFICATION-CONDITION-1 ...)
c  0 Goal PUSH *1
++++++++++++++++++++++++++++++
c  2 *1 INDUCT
   1 |  Subgoal *1/2 preprocess
   2 |  |  Subgoal *1/2' simp
   7 |  |  |  Subgoal *1/2.2 simp
   1 |  |  |  |  Subgoal *1/2.2.5 simp
   1 |  |  |  |  |  Subgoal *1/2.2.5' simp
c  1 |  |  |  |  |  |  Subgoal *1/2.2.5'' GEN
   1 |  |  |  |  |  |  |  Subgoal *1/2.2.5''' simp
c  0 |  |  |  |  |  |  |  |  Subgoal *1/2.2.5'4' PUSH *1.1
++++++++++++++++++++++++++++++
c 22 *1.1 INDUCT
     |  <6 more subgoals>
#>\>
But simplification reduces this to T, using the :compound-recognizer
rules NATP-COMPOUND-RECOGNIZER and ZP-COMPOUND-RECOGNIZER, the :congruence
rule FRAME-1-INT-EQUIV-CONGRUENCE-ON-I, the :definitions ELEMENT-EQ,
NFIX, REP-1 and SYNP, the :executable-counterparts of BINARY-+, EQUAL,
FRAME-1-FIX$INLINE, IFIX and NATP, primitive type reasoning and the
:rewrite rules COMMUTATIVITY-2-OF-+, COMMUTATIVITY-OF-+, 
ENVIR-1->A$INLINE-OF-ENVIR-1-FIX-X, 
ENVIR-1->LOOP-COUNTER-SHIFT$INLINE-OF-ENVIR-1-FIX-X, FOLD-CONSTS-IN-+,
FRAME-1->I-OF-FRAME-1, FRAME-1->RESULT-OF-FRAME-1 and IFIX-UNDER-INT-EQUIV.

Subgoal *1.1/6
(IMPLIES
 (AND (NOT (ZP (NFIX J)))
      (FRAME-1->LOOP-BREAK
           (REP-1 (+ -1 (NFIX J))
                  (ENVIR-1-FIX L)
                  (FRAME-1-FIX '((I . 1) (RESULT . 1) (LOOP-BREAK)))))
      (NOT (EQUAL (ELEMENT-EQ 0 (+ -1 (NFIX J)) A)
                  1))
      (INTEGERP I)
      (< 0 I)
      L (TRUE-LISTP L)
      (INTEGERP J)
      (EQUAL (FRAME-1->RESULT (REP-1 J
                                     L '((I . 1) (RESULT . 1) (LOOP-BREAK))))
             1)
      (EQUAL (ELEMENT-EQ 0 J A) 1)
      (INTEGER-LISTP A)
      (INTEGERP N)
      (<= 0 N)
      (< 0 N)
      (<= N (LEN A))
      (NOT (EQUAL (NTH J A) (NTH I A))))
 (NOT (FRAME-1->LOOP-BREAK (REP-1 J L
                                  '((I . 1) (RESULT . 1) (LOOP-BREAK)))))).
#<\<0( DEFTHM VERIFICATION-CONDITION-1 ...)
c  0 Goal PUSH *1
++++++++++++++++++++++++++++++
c  2 *1 INDUCT
   1 |  Subgoal *1/2 preprocess
   2 |  |  Subgoal *1/2' simp
   7 |  |  |  Subgoal *1/2.2 simp
   1 |  |  |  |  Subgoal *1/2.2.5 simp
   1 |  |  |  |  |  Subgoal *1/2.2.5' simp
c  1 |  |  |  |  |  |  Subgoal *1/2.2.5'' GEN
   1 |  |  |  |  |  |  |  Subgoal *1/2.2.5''' simp
c  0 |  |  |  |  |  |  |  |  Subgoal *1/2.2.5'4' PUSH *1.1
++++++++++++++++++++++++++++++
c 22 *1.1 INDUCT
   1 |  Subgoal *1.1/6 preprocess
     |  |  <1 subgoal>
     |  <5 more subgoals>
#>\>
By the :congruence rule NAT-EQUIV-IMPLIES-EQUAL-ZP-1, the :executable-
counterpart of FRAME-1-FIX$INLINE and the simple :rewrite rule 
NFIX-UNDER-NAT-EQUIV we reduce the conjecture to

Subgoal *1.1/6'
(IMPLIES
 (AND (NOT (ZP J))
      (FRAME-1->LOOP-BREAK (REP-1 (+ -1 (NFIX J))
                                  (ENVIR-1-FIX L)
                                  '((I . 1) (RESULT . 1) (LOOP-BREAK))))
      (NOT (EQUAL (ELEMENT-EQ 0 (+ -1 (NFIX J)) A)
                  1))
      (INTEGERP I)
      (< 0 I)
      L (TRUE-LISTP L)
      (INTEGERP J)
      (EQUAL (FRAME-1->RESULT (REP-1 J
                                     L '((I . 1) (RESULT . 1) (LOOP-BREAK))))
             1)
      (EQUAL (ELEMENT-EQ 0 J A) 1)
      (INTEGER-LISTP A)
      (INTEGERP N)
      (<= 0 N)
      (< 0 N)
      (<= N (LEN A))
      (NOT (EQUAL (NTH J A) (NTH I A))))
 (NOT (FRAME-1->LOOP-BREAK (REP-1 J L
                                  '((I . 1) (RESULT . 1) (LOOP-BREAK)))))).
#<\<0( DEFTHM VERIFICATION-CONDITION-1 ...)
c  0 Goal PUSH *1
++++++++++++++++++++++++++++++
c  2 *1 INDUCT
   1 |  Subgoal *1/2 preprocess
   2 |  |  Subgoal *1/2' simp
   7 |  |  |  Subgoal *1/2.2 simp
   1 |  |  |  |  Subgoal *1/2.2.5 simp
   1 |  |  |  |  |  Subgoal *1/2.2.5' simp
c  1 |  |  |  |  |  |  Subgoal *1/2.2.5'' GEN
   1 |  |  |  |  |  |  |  Subgoal *1/2.2.5''' simp
c  0 |  |  |  |  |  |  |  |  Subgoal *1/2.2.5'4' PUSH *1.1
++++++++++++++++++++++++++++++
c 22 *1.1 INDUCT
   1 |  Subgoal *1.1/6 preprocess
   1 |  |  Subgoal *1.1/6' simp
     |  |  |  <1 subgoal>
     |  <5 more subgoals>
#>\>
This simplifies, using the :executable-counterpart of EQUAL, linear
arithmetic and the :type-prescription rule ELEMENT-EQ, to

Subgoal *1.1/6''
(IMPLIES
 (AND (EQUAL (ELEMENT-EQ 0 (+ -1 (NFIX J)) A)
             0)
      (NOT (ZP J))
      (FRAME-1->LOOP-BREAK (REP-1 (+ -1 (NFIX J))
                                  (ENVIR-1-FIX L)
                                  '((I . 1) (RESULT . 1) (LOOP-BREAK))))
      (INTEGERP I)
      (< 0 I)
      L (TRUE-LISTP L)
      (INTEGERP J)
      (EQUAL (FRAME-1->RESULT (REP-1 J
                                     L '((I . 1) (RESULT . 1) (LOOP-BREAK))))
             1)
      (EQUAL (ELEMENT-EQ 0 J A) 1)
      (INTEGER-LISTP A)
      (INTEGERP N)
      (<= 0 N)
      (< 0 N)
      (<= N (LEN A))
      (NOT (EQUAL (NTH J A) (NTH I A))))
 (NOT (FRAME-1->LOOP-BREAK (REP-1 J L
                                  '((I . 1) (RESULT . 1) (LOOP-BREAK)))))).
#<\<0( DEFTHM VERIFICATION-CONDITION-1 ...)
c  0 Goal PUSH *1
++++++++++++++++++++++++++++++
c  2 *1 INDUCT
   1 |  Subgoal *1/2 preprocess
   2 |  |  Subgoal *1/2' simp
   7 |  |  |  Subgoal *1/2.2 simp
   1 |  |  |  |  Subgoal *1/2.2.5 simp
   1 |  |  |  |  |  Subgoal *1/2.2.5' simp
c  1 |  |  |  |  |  |  Subgoal *1/2.2.5'' GEN
   1 |  |  |  |  |  |  |  Subgoal *1/2.2.5''' simp
c  0 |  |  |  |  |  |  |  |  Subgoal *1/2.2.5'4' PUSH *1.1
++++++++++++++++++++++++++++++
c 22 *1.1 INDUCT
     |  <5 more subgoals>
#>\>
But simplification reduces this to T, using the :compound-recognizer
rules NATP-COMPOUND-RECOGNIZER and ZP-COMPOUND-RECOGNIZER, the :congruence
rule FRAME-1-INT-EQUIV-CONGRUENCE-ON-I, the :definitions ELEMENT-EQ,
NFIX, REP-1 and SYNP, the :executable-counterparts of BINARY-+, EQUAL,
FRAME-1-FIX$INLINE, IFIX and NATP, primitive type reasoning and the
:rewrite rules COMMUTATIVITY-2-OF-+, COMMUTATIVITY-OF-+, 
ENVIR-1->A$INLINE-OF-ENVIR-1-FIX-X, 
ENVIR-1->LOOP-COUNTER-SHIFT$INLINE-OF-ENVIR-1-FIX-X, FOLD-CONSTS-IN-+,
FRAME-1->I-OF-FRAME-1, FRAME-1->RESULT-OF-FRAME-1 and IFIX-UNDER-INT-EQUIV.

Subgoal *1.1/5
(IMPLIES
 (AND
   (NOT (ZP (NFIX J)))
   (FRAME-1->LOOP-BREAK
        (REP-1 (+ -1 (NFIX J))
               (ENVIR-1-FIX L)
               (FRAME-1-FIX '((I . 1) (RESULT . 1) (LOOP-BREAK)))))
   (NOT (EQUAL (FRAME-1->RESULT (REP-1 (+ -1 (NFIX J))
                                       (ENVIR-1-FIX L)
                                       '((I . 1) (RESULT . 1) (LOOP-BREAK))))
               1))
   (INTEGERP I)
   (< 0 I)
   L (TRUE-LISTP L)
   (INTEGERP J)
   (EQUAL (FRAME-1->RESULT (REP-1 J
                                  L '((I . 1) (RESULT . 1) (LOOP-BREAK))))
          1)
   (EQUAL (ELEMENT-EQ 0 J A) 1)
   (INTEGER-LISTP A)
   (INTEGERP N)
   (<= 0 N)
   (< 0 N)
   (<= N (LEN A))
   (NOT (EQUAL (NTH J A) (NTH I A))))
 (NOT (FRAME-1->LOOP-BREAK (REP-1 J L
                                  '((I . 1) (RESULT . 1) (LOOP-BREAK)))))).
#<\<0( DEFTHM VERIFICATION-CONDITION-1 ...)
c  0 Goal PUSH *1
++++++++++++++++++++++++++++++
c  2 *1 INDUCT
   1 |  Subgoal *1/2 preprocess
   2 |  |  Subgoal *1/2' simp
   7 |  |  |  Subgoal *1/2.2 simp
   1 |  |  |  |  Subgoal *1/2.2.5 simp
   1 |  |  |  |  |  Subgoal *1/2.2.5' simp
c  1 |  |  |  |  |  |  Subgoal *1/2.2.5'' GEN
   1 |  |  |  |  |  |  |  Subgoal *1/2.2.5''' simp
c  0 |  |  |  |  |  |  |  |  Subgoal *1/2.2.5'4' PUSH *1.1
++++++++++++++++++++++++++++++
c 22 *1.1 INDUCT
   1 |  Subgoal *1.1/5 preprocess
     |  |  <1 subgoal>
     |  <4 more subgoals>
#>\>
By the :congruence rule NAT-EQUIV-IMPLIES-EQUAL-ZP-1, the :executable-
counterpart of FRAME-1-FIX$INLINE and the simple :rewrite rule 
NFIX-UNDER-NAT-EQUIV we reduce the conjecture to

Subgoal *1.1/5'
(IMPLIES
 (AND
   (NOT (ZP J))
   (FRAME-1->LOOP-BREAK (REP-1 (+ -1 (NFIX J))
                               (ENVIR-1-FIX L)
                               '((I . 1) (RESULT . 1) (LOOP-BREAK))))
   (NOT (EQUAL (FRAME-1->RESULT (REP-1 (+ -1 (NFIX J))
                                       (ENVIR-1-FIX L)
                                       '((I . 1) (RESULT . 1) (LOOP-BREAK))))
               1))
   (INTEGERP I)
   (< 0 I)
   L (TRUE-LISTP L)
   (INTEGERP J)
   (EQUAL (FRAME-1->RESULT (REP-1 J
                                  L '((I . 1) (RESULT . 1) (LOOP-BREAK))))
          1)
   (EQUAL (ELEMENT-EQ 0 J A) 1)
   (INTEGER-LISTP A)
   (INTEGERP N)
   (<= 0 N)
   (< 0 N)
   (<= N (LEN A))
   (NOT (EQUAL (NTH J A) (NTH I A))))
 (NOT (FRAME-1->LOOP-BREAK (REP-1 J L
                                  '((I . 1) (RESULT . 1) (LOOP-BREAK)))))).
#<\<0( DEFTHM VERIFICATION-CONDITION-1 ...)
c  0 Goal PUSH *1
++++++++++++++++++++++++++++++
c  2 *1 INDUCT
   1 |  Subgoal *1/2 preprocess
   2 |  |  Subgoal *1/2' simp
   7 |  |  |  Subgoal *1/2.2 simp
   1 |  |  |  |  Subgoal *1/2.2.5 simp
   1 |  |  |  |  |  Subgoal *1/2.2.5' simp
c  1 |  |  |  |  |  |  Subgoal *1/2.2.5'' GEN
   1 |  |  |  |  |  |  |  Subgoal *1/2.2.5''' simp
c  0 |  |  |  |  |  |  |  |  Subgoal *1/2.2.5'4' PUSH *1.1
++++++++++++++++++++++++++++++
c 22 *1.1 INDUCT
   1 |  Subgoal *1.1/5 preprocess
   2 |  |  Subgoal *1.1/5' simp
     |  |  |  <2 subgoals>
     |  <4 more subgoals>
#>\>
This simplifies, using the :compound-recognizer rule ZP-COMPOUND-RECOGNIZER,
the :congruence rules FRAME-1-INT-EQUIV-CONGRUENCE-ON-I and 
IFF-IMPLIES-EQUAL-BOOL-FIX-1, the :definitions NFIX, REP-1 (if-intro)
and SYNP, the :executable-counterparts of BINARY-+, BOOL-FIX$INLINE,
FRAME-1-FIX$INLINE and IFIX, primitive type reasoning, the :rewrite
rules COMMUTATIVITY-2-OF-+, COMMUTATIVITY-OF-+, 
ENVIR-1->A$INLINE-OF-ENVIR-1-FIX-X, 
ENVIR-1->LOOP-COUNTER-SHIFT$INLINE-OF-ENVIR-1-FIX-X, FOLD-CONSTS-IN-+,
FRAME-1->I-OF-FRAME-1, FRAME-1->LOOP-BREAK-OF-FRAME-1, 
FRAME-1->RESULT-OF-FRAME-1 and IFIX-UNDER-INT-EQUIV and the :type-
prescription rule FRAME-1->LOOP-BREAK$INLINE, to the following two
conjectures.

Subgoal *1.1/5.2
(IMPLIES
 (AND
   (NOT (ZP J))
   (FRAME-1->LOOP-BREAK (REP-1 (+ -1 (NFIX J))
                               (ENVIR-1-FIX L)
                               '((I . 1) (RESULT . 1) (LOOP-BREAK))))
   (NOT (EQUAL (FRAME-1->RESULT (REP-1 (+ -1 (NFIX J))
                                       (ENVIR-1-FIX L)
                                       '((I . 1) (RESULT . 1) (LOOP-BREAK))))
               1))
   (INTEGERP I)
   (< 0 I)
   L (TRUE-LISTP L)
   (FRAME-1->LOOP-BREAK (REP-1 (+ -1 J)
                               (ENVIR-1-FIX L)
                               '((I . 1) (RESULT . 1) (LOOP-BREAK))))
   (EQUAL (FRAME-1->RESULT (REP-1 (+ -1 J)
                                  (ENVIR-1-FIX L)
                                  '((I . 1) (RESULT . 1) (LOOP-BREAK))))
          1)
   (EQUAL (ELEMENT-EQ 0 J A) 1)
   (INTEGER-LISTP A)
   (INTEGERP N)
   (<= 0 N)
   (< 0 N)
   (<= N (LEN A)))
 (EQUAL (NTH J A) (NTH I A))).
#<\<0( DEFTHM VERIFICATION-CONDITION-1 ...)
c  0 Goal PUSH *1
++++++++++++++++++++++++++++++
c  2 *1 INDUCT
   1 |  Subgoal *1/2 preprocess
   2 |  |  Subgoal *1/2' simp
   7 |  |  |  Subgoal *1/2.2 simp
   1 |  |  |  |  Subgoal *1/2.2.5 simp
   1 |  |  |  |  |  Subgoal *1/2.2.5' simp
c  1 |  |  |  |  |  |  Subgoal *1/2.2.5'' GEN
   1 |  |  |  |  |  |  |  Subgoal *1/2.2.5''' simp
c  0 |  |  |  |  |  |  |  |  Subgoal *1/2.2.5'4' PUSH *1.1
++++++++++++++++++++++++++++++
c 22 *1.1 INDUCT
   1 |  Subgoal *1.1/5 preprocess
   2 |  |  Subgoal *1.1/5' simp
     |  |  |  <1 more subgoal>
     |  <4 more subgoals>
#>\>
But simplification reduces this to T, using the :compound-recognizer
rule ZP-COMPOUND-RECOGNIZER, the :definition NFIX, the :executable-
counterpart of EQUAL, primitive type reasoning and the :type-prescription
rule FRAME-1->LOOP-BREAK$INLINE.

Subgoal *1.1/5.1
(IMPLIES
 (AND
  (NOT (ZP J))
  (FRAME-1->LOOP-BREAK (REP-1 (+ -1 (NFIX J))
                              (ENVIR-1-FIX L)
                              '((I . 1) (RESULT . 1) (LOOP-BREAK))))
  (NOT (EQUAL (FRAME-1->RESULT (REP-1 (+ -1 (NFIX J))
                                      (ENVIR-1-FIX L)
                                      '((I . 1) (RESULT . 1) (LOOP-BREAK))))
              1))
  (INTEGERP I)
  (< 0 I)
  L (TRUE-LISTP L)
  (NOT (FRAME-1->LOOP-BREAK (REP-1 (+ -1 J)
                                   (ENVIR-1-FIX L)
                                   '((I . 1) (RESULT . 1) (LOOP-BREAK)))))
  (NOT (EQUAL (NTH (+ -2 J (ENVIR-1->LOOP-COUNTER-SHIFT L))
                   (ENVIR-1->A L))
              (NTH (+ -1 J (ENVIR-1->LOOP-COUNTER-SHIFT L))
                   (ENVIR-1->A L))))
  (EQUAL
   (FRAME-1->RESULT
    (LET
     ((FR-1
           (FRAME-1 (FRAME-1->I (REP-1 (+ -1 J)
                                       (ENVIR-1-FIX L)
                                       '((I . 1) (RESULT . 1) (LOOP-BREAK))))
                    0 T)))
     (IF (FRAME-1->LOOP-BREAK FR-1)
         FR-1
         (LET ((FR-1 (LET ((CHANGE-FRAME-1 FR-1)
                           (FRAME-1->I (+ (FRAME-1->I FR-1) 1)))
                          (FRAME-1 FRAME-1->I
                                   (FRAME-1->RESULT CHANGE-FRAME-1)
                                   (FRAME-1->LOOP-BREAK CHANGE-FRAME-1)))))
              FR-1))))
   1)
  (EQUAL (ELEMENT-EQ 0 J A) 1)
  (INTEGER-LISTP A)
  (INTEGERP N)
  (<= 0 N)
  (< 0 N)
  (<= N (LEN A)))
 (EQUAL (NTH J A) (NTH I A))).
#<\<0( DEFTHM VERIFICATION-CONDITION-1 ...)
c  0 Goal PUSH *1
++++++++++++++++++++++++++++++
c  2 *1 INDUCT
   1 |  Subgoal *1/2 preprocess
   2 |  |  Subgoal *1/2' simp
   7 |  |  |  Subgoal *1/2.2 simp
   1 |  |  |  |  Subgoal *1/2.2.5 simp
   1 |  |  |  |  |  Subgoal *1/2.2.5' simp
c  1 |  |  |  |  |  |  Subgoal *1/2.2.5'' GEN
   1 |  |  |  |  |  |  |  Subgoal *1/2.2.5''' simp
c  0 |  |  |  |  |  |  |  |  Subgoal *1/2.2.5'4' PUSH *1.1
++++++++++++++++++++++++++++++
c 22 *1.1 INDUCT
   1 |  Subgoal *1.1/5 preprocess
   2 |  |  Subgoal *1.1/5' simp
   1 |  |  |  Subgoal *1.1/5.1 preprocess
     |  |  |  |  <1 subgoal>
     |  <4 more subgoals>
#>\>
By case analysis we reduce the conjecture to

Subgoal *1.1/5.1'
(IMPLIES
 (AND
  (NOT (ZP J))
  (FRAME-1->LOOP-BREAK (REP-1 (+ -1 (NFIX J))
                              (ENVIR-1-FIX L)
                              '((I . 1) (RESULT . 1) (LOOP-BREAK))))
  (NOT (EQUAL (FRAME-1->RESULT (REP-1 (+ -1 (NFIX J))
                                      (ENVIR-1-FIX L)
                                      '((I . 1) (RESULT . 1) (LOOP-BREAK))))
              1))
  (INTEGERP I)
  (< 0 I)
  L (TRUE-LISTP L)
  (NOT (FRAME-1->LOOP-BREAK (REP-1 (+ -1 J)
                                   (ENVIR-1-FIX L)
                                   '((I . 1) (RESULT . 1) (LOOP-BREAK)))))
  (NOT (EQUAL (NTH (+ -2 J (ENVIR-1->LOOP-COUNTER-SHIFT L))
                   (ENVIR-1->A L))
              (NTH (+ -1 J (ENVIR-1->LOOP-COUNTER-SHIFT L))
                   (ENVIR-1->A L))))
  (EQUAL
   (FRAME-1->RESULT
    (LET
     ((FR-1
           (FRAME-1 (FRAME-1->I (REP-1 (+ -1 J)
                                       (ENVIR-1-FIX L)
                                       '((I . 1) (RESULT . 1) (LOOP-BREAK))))
                    0 T)))
     (IF (FRAME-1->LOOP-BREAK FR-1)
         FR-1
         (LET ((CHANGE-FRAME-1 FR-1)
               (FRAME-1->I (+ (FRAME-1->I FR-1) 1)))
              (FRAME-1 FRAME-1->I
                       (FRAME-1->RESULT CHANGE-FRAME-1)
                       (FRAME-1->LOOP-BREAK CHANGE-FRAME-1))))))
   1)
  (EQUAL (ELEMENT-EQ 0 J A) 1)
  (INTEGER-LISTP A)
  (INTEGERP N)
  (<= 0 N)
  (< 0 N)
  (<= N (LEN A)))
 (EQUAL (NTH J A) (NTH I A))).
#<\<0( DEFTHM VERIFICATION-CONDITION-1 ...)
c  0 Goal PUSH *1
++++++++++++++++++++++++++++++
c  2 *1 INDUCT
   1 |  Subgoal *1/2 preprocess
   2 |  |  Subgoal *1/2' simp
   7 |  |  |  Subgoal *1/2.2 simp
   1 |  |  |  |  Subgoal *1/2.2.5 simp
   1 |  |  |  |  |  Subgoal *1/2.2.5' simp
c  1 |  |  |  |  |  |  Subgoal *1/2.2.5'' GEN
   1 |  |  |  |  |  |  |  Subgoal *1/2.2.5''' simp
c  0 |  |  |  |  |  |  |  |  Subgoal *1/2.2.5'4' PUSH *1.1
++++++++++++++++++++++++++++++
c 22 *1.1 INDUCT
     |  <4 more subgoals>
#>\>
But simplification reduces this to T, using the :compound-recognizer
rule ZP-COMPOUND-RECOGNIZER, the :definition NFIX and primitive type
reasoning.

Subgoal *1.1/4
(IMPLIES
 (AND (NOT (ZP (NFIX J)))
      (FRAME-1->LOOP-BREAK
           (REP-1 (+ -1 (NFIX J))
                  (ENVIR-1-FIX L)
                  (FRAME-1-FIX '((I . 1) (RESULT . 1) (LOOP-BREAK)))))
      (NOT (INTEGERP (+ -1 (NFIX J))))
      (INTEGERP I)
      (< 0 I)
      L (TRUE-LISTP L)
      (INTEGERP J)
      (EQUAL (FRAME-1->RESULT (REP-1 J
                                     L '((I . 1) (RESULT . 1) (LOOP-BREAK))))
             1)
      (EQUAL (ELEMENT-EQ 0 J A) 1)
      (INTEGER-LISTP A)
      (INTEGERP N)
      (<= 0 N)
      (< 0 N)
      (<= N (LEN A))
      (NOT (EQUAL (NTH J A) (NTH I A))))
 (NOT (FRAME-1->LOOP-BREAK (REP-1 J L
                                  '((I . 1) (RESULT . 1) (LOOP-BREAK)))))).
#<\<0( DEFTHM VERIFICATION-CONDITION-1 ...)
c  0 Goal PUSH *1
++++++++++++++++++++++++++++++
c  2 *1 INDUCT
   1 |  Subgoal *1/2 preprocess
   2 |  |  Subgoal *1/2' simp
   7 |  |  |  Subgoal *1/2.2 simp
   1 |  |  |  |  Subgoal *1/2.2.5 simp
   1 |  |  |  |  |  Subgoal *1/2.2.5' simp
c  1 |  |  |  |  |  |  Subgoal *1/2.2.5'' GEN
   1 |  |  |  |  |  |  |  Subgoal *1/2.2.5''' simp
c  0 |  |  |  |  |  |  |  |  Subgoal *1/2.2.5'4' PUSH *1.1
++++++++++++++++++++++++++++++
c 22 *1.1 INDUCT
     |  <3 more subgoals>
#>\>
But we reduce the conjecture to T, by the :compound-recognizer rule
ZP-COMPOUND-RECOGNIZER and the :type-prescription rule NFIX.

Subgoal *1.1/3
(IMPLIES
 (AND (NOT (ZP (NFIX J)))
      (FRAME-1->LOOP-BREAK
           (REP-1 (+ -1 (NFIX J))
                  (ENVIR-1-FIX L)
                  (FRAME-1-FIX '((I . 1) (RESULT . 1) (LOOP-BREAK)))))
      (NOT (TRUE-LISTP (ENVIR-1-FIX L)))
      (INTEGERP I)
      (< 0 I)
      L (TRUE-LISTP L)
      (INTEGERP J)
      (EQUAL (FRAME-1->RESULT (REP-1 J
                                     L '((I . 1) (RESULT . 1) (LOOP-BREAK))))
             1)
      (EQUAL (ELEMENT-EQ 0 J A) 1)
      (INTEGER-LISTP A)
      (INTEGERP N)
      (<= 0 N)
      (< 0 N)
      (<= N (LEN A))
      (NOT (EQUAL (NTH J A) (NTH I A))))
 (NOT (FRAME-1->LOOP-BREAK (REP-1 J L
                                  '((I . 1) (RESULT . 1) (LOOP-BREAK)))))).
#<\<0( DEFTHM VERIFICATION-CONDITION-1 ...)
c  0 Goal PUSH *1
++++++++++++++++++++++++++++++
c  2 *1 INDUCT
   1 |  Subgoal *1/2 preprocess
   2 |  |  Subgoal *1/2' simp
   7 |  |  |  Subgoal *1/2.2 simp
   1 |  |  |  |  Subgoal *1/2.2.5 simp
   1 |  |  |  |  |  Subgoal *1/2.2.5' simp
c  1 |  |  |  |  |  |  Subgoal *1/2.2.5'' GEN
   1 |  |  |  |  |  |  |  Subgoal *1/2.2.5''' simp
c  0 |  |  |  |  |  |  |  |  Subgoal *1/2.2.5'4' PUSH *1.1
++++++++++++++++++++++++++++++
c 22 *1.1 INDUCT
     |  <2 more subgoals>
#>\>
But we reduce the conjecture to T, by the :type-prescription rule 
ENVIR-1-FIX$INLINE.

Subgoal *1.1/2
(IMPLIES
 (AND (NOT (ZP (NFIX J)))
      (FRAME-1->LOOP-BREAK
           (REP-1 (+ -1 (NFIX J))
                  (ENVIR-1-FIX L)
                  (FRAME-1-FIX '((I . 1) (RESULT . 1) (LOOP-BREAK)))))
      (NOT (ENVIR-1-FIX L))
      (INTEGERP I)
      (< 0 I)
      L (TRUE-LISTP L)
      (INTEGERP J)
      (EQUAL (FRAME-1->RESULT (REP-1 J
                                     L '((I . 1) (RESULT . 1) (LOOP-BREAK))))
             1)
      (EQUAL (ELEMENT-EQ 0 J A) 1)
      (INTEGER-LISTP A)
      (INTEGERP N)
      (<= 0 N)
      (< 0 N)
      (<= N (LEN A))
      (NOT (EQUAL (NTH J A) (NTH I A))))
 (NOT (FRAME-1->LOOP-BREAK (REP-1 J L
                                  '((I . 1) (RESULT . 1) (LOOP-BREAK)))))).
#<\<0( DEFTHM VERIFICATION-CONDITION-1 ...)
c  0 Goal PUSH *1
++++++++++++++++++++++++++++++
c  2 *1 INDUCT
   1 |  Subgoal *1/2 preprocess
   2 |  |  Subgoal *1/2' simp
   7 |  |  |  Subgoal *1/2.2 simp
   1 |  |  |  |  Subgoal *1/2.2.5 simp
   1 |  |  |  |  |  Subgoal *1/2.2.5' simp
c  1 |  |  |  |  |  |  Subgoal *1/2.2.5'' GEN
   1 |  |  |  |  |  |  |  Subgoal *1/2.2.5''' simp
c  0 |  |  |  |  |  |  |  |  Subgoal *1/2.2.5'4' PUSH *1.1
++++++++++++++++++++++++++++++
c 22 *1.1 INDUCT
     |  <1 more subgoal>
#>\>
But we reduce the conjecture to T, by the :type-prescription rule 
ENVIR-1-FIX$INLINE.

Subgoal *1.1/1
(IMPLIES
 (AND (ZP (NFIX J))
      (INTEGERP I)
      (< 0 I)
      L (TRUE-LISTP L)
      (INTEGERP J)
      (EQUAL (FRAME-1->RESULT (REP-1 J
                                     L '((I . 1) (RESULT . 1) (LOOP-BREAK))))
             1)
      (EQUAL (ELEMENT-EQ 0 J A) 1)
      (INTEGER-LISTP A)
      (INTEGERP N)
      (<= 0 N)
      (< 0 N)
      (<= N (LEN A))
      (NOT (EQUAL (NTH J A) (NTH I A))))
 (NOT (FRAME-1->LOOP-BREAK (REP-1 J L
                                  '((I . 1) (RESULT . 1) (LOOP-BREAK)))))).
#<\<0( DEFTHM VERIFICATION-CONDITION-1 ...)
c  0 Goal PUSH *1
++++++++++++++++++++++++++++++
c  2 *1 INDUCT
   1 |  Subgoal *1/2 preprocess
   2 |  |  Subgoal *1/2' simp
   7 |  |  |  Subgoal *1/2.2 simp
   1 |  |  |  |  Subgoal *1/2.2.5 simp
   1 |  |  |  |  |  Subgoal *1/2.2.5' simp
c  1 |  |  |  |  |  |  Subgoal *1/2.2.5'' GEN
   1 |  |  |  |  |  |  |  Subgoal *1/2.2.5''' simp
c  0 |  |  |  |  |  |  |  |  Subgoal *1/2.2.5'4' PUSH *1.1
++++++++++++++++++++++++++++++
c 22 *1.1 INDUCT
   1 |  Subgoal *1.1/1 preprocess
     |  |  <1 subgoal>
#>\>
By the :congruence rule NAT-EQUIV-IMPLIES-EQUAL-ZP-1 and the simple
:rewrite rule NFIX-UNDER-NAT-EQUIV we reduce the conjecture to

Subgoal *1.1/1'
(IMPLIES
 (AND (ZP J)
      (INTEGERP I)
      (< 0 I)
      L (TRUE-LISTP L)
      (INTEGERP J)
      (EQUAL (FRAME-1->RESULT (REP-1 J
                                     L '((I . 1) (RESULT . 1) (LOOP-BREAK))))
             1)
      (EQUAL (ELEMENT-EQ 0 J A) 1)
      (INTEGER-LISTP A)
      (INTEGERP N)
      (<= 0 N)
      (< 0 N)
      (<= N (LEN A))
      (NOT (EQUAL (NTH J A) (NTH I A))))
 (NOT (FRAME-1->LOOP-BREAK (REP-1 J L
                                  '((I . 1) (RESULT . 1) (LOOP-BREAK)))))).
#<\<0( DEFTHM VERIFICATION-CONDITION-1 ...)
Q.E.D.#>\>
But simplification reduces this to T, using the :compound-recognizer
rule ZP-COMPOUND-RECOGNIZER, the :definitions ELEMENT-EQ, NATP, NFIX
and REP-1, the :executable-counterparts of <, EQUAL, 
FRAME-1->LOOP-BREAK$INLINE, FRAME-1->RESULT$INLINE, FRAME-1-FIX$INLINE,
NATP, NFIX and ZP and the :rewrite rule NTH-WHEN-ZP.

That completes the proofs of *1.1 and *1.

Q.E.D.

Summary
Form:  ( DEFTHM VERIFICATION-CONDITION-1 ...)
Rules: ((:COMPOUND-RECOGNIZER NATP-COMPOUND-RECOGNIZER)
        (:COMPOUND-RECOGNIZER TRUE-LISTP-WHEN-ACL2-NUMBER-LISTP)
        (:COMPOUND-RECOGNIZER TRUE-LISTP-WHEN-INTEGER-LISTP)
        (:COMPOUND-RECOGNIZER TRUE-LISTP-WHEN-RATIONAL-LISTP)
        (:COMPOUND-RECOGNIZER ZP-COMPOUND-RECOGNIZER)
        (:CONGRUENCE ENVIR-1->A$INLINE-ENVIR-1-EQUIV-CONGRUENCE-ON-X)
        (:CONGRUENCE
            ENVIR-1->LOOP-COUNTER-SHIFT$INLINE-ENVIR-1-EQUIV-CONGRUENCE-ON-X)
        (:CONGRUENCE FRAME-1-IFF-CONGRUENCE-ON-LOOP-BREAK)
        (:CONGRUENCE FRAME-1-INT-EQUIV-CONGRUENCE-ON-I)
        (:CONGRUENCE IFF-IMPLIES-EQUAL-BOOL-FIX-1)
        (:CONGRUENCE NAT-EQUIV-IMPLIES-EQUAL-ZP-1)
        (:DEFINITION =)
        (:DEFINITION ELEMENT-EQ)
        (:DEFINITION ENVIR-1-INIT)
        (:DEFINITION IFIX)
        (:DEFINITION LENGTH)
        (:DEFINITION NATP)
        (:DEFINITION NFIX)
        (:DEFINITION NOT)
        (:DEFINITION REP-1)
        (:DEFINITION SYNP)
        (:EXECUTABLE-COUNTERPART <)
        (:EXECUTABLE-COUNTERPART BINARY-+)
        (:EXECUTABLE-COUNTERPART BOOL-FIX$INLINE)
        (:EXECUTABLE-COUNTERPART EQUAL)
        (:EXECUTABLE-COUNTERPART FRAME-1->LOOP-BREAK$INLINE)
        (:EXECUTABLE-COUNTERPART FRAME-1->RESULT$INLINE)
        (:EXECUTABLE-COUNTERPART FRAME-1-FIX$INLINE)
        (:EXECUTABLE-COUNTERPART FRAME-1-INIT)
        (:EXECUTABLE-COUNTERPART IF)
        (:EXECUTABLE-COUNTERPART IFIX)
        (:EXECUTABLE-COUNTERPART NATP)
        (:EXECUTABLE-COUNTERPART NFIX)
        (:EXECUTABLE-COUNTERPART NOT)
        (:EXECUTABLE-COUNTERPART TAU-SYSTEM)
        (:EXECUTABLE-COUNTERPART ZP)
        (:FAKE-RUNE-FOR-LINEAR NIL)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:FORWARD-CHAINING INTEGER-LISTP-FORWARD-TO-RATIONAL-LISTP)
        (:FORWARD-CHAINING RATIONAL-LISTP-FORWARD-TO-ACL2-NUMBER-LISTP)
        (:INDUCTION DEC-INDUCT)
        (:INDUCTION REP-1)
        (:REWRITE ASSOCIATIVITY-OF-+)
        (:REWRITE COMMUTATIVITY-2-OF-+)
        (:REWRITE COMMUTATIVITY-OF-+)
        (:REWRITE CONSP-UNDER-IFF-WHEN-TRUE-LISTP)
        (:REWRITE ENVIR-1->A$INLINE-OF-ENVIR-1-FIX-X)
        (:REWRITE ENVIR-1->A-OF-ENVIR-1)
        (:REWRITE ENVIR-1->LOOP-COUNTER-SHIFT$INLINE-OF-ENVIR-1-FIX-X)
        (:REWRITE ENVIR-1->LOOP-COUNTER-SHIFT-OF-ENVIR-1)
        (:REWRITE ENVIR-1-FIX-UNDER-ENVIR-1-EQUIV)
        (:REWRITE ENVIR-1-FIX-WHEN-ENVIR-1-P)
        (:REWRITE ENVIR-1-P-OF-ENVIR-1)
        (:REWRITE FOLD-CONSTS-IN-+)
        (:REWRITE FRAME-1->I-OF-FRAME-1)
        (:REWRITE FRAME-1->LOOP-BREAK-OF-FRAME-1)
        (:REWRITE FRAME-1->RESULT-OF-FRAME-1)
        (:REWRITE IFIX-UNDER-INT-EQUIV)
        (:REWRITE INTEGER-LIST-FIX-WHEN-INTEGER-LISTP)
        (:REWRITE INTEGER-LISTP-WHEN-SUBSETP-EQUAL)
        (:REWRITE NFIX-UNDER-NAT-EQUIV)
        (:REWRITE NTH-WHEN-ZP)
        (:REWRITE SUBSETP-REFL)
        (:REWRITE ZP-OPEN)
        (:TYPE-PRESCRIPTION ELEMENT-EQ)
        (:TYPE-PRESCRIPTION ENVIR-1)
        (:TYPE-PRESCRIPTION ENVIR-1-FIX$INLINE)
        (:TYPE-PRESCRIPTION FRAME-1->LOOP-BREAK$INLINE)
        (:TYPE-PRESCRIPTION FRAME-1->RESULT$INLINE)
        (:TYPE-PRESCRIPTION NFIX))
Splitter rules (see :DOC splitter):
  if-intro: ((:DEFINITION ELEMENT-EQ)
             (:DEFINITION NOT)
             (:DEFINITION REP-1)
             (:REWRITE ZP-OPEN))
Time:  0.36 seconds (prove: 0.34, print: 0.02, proof tree: 0.00, other: 0.00)
Prover steps counted:  70795
T

* Step 3:  That completes the admissibility check.  Each form read
was an embedded event form and was admissible.  We now retract back
to the world created by the first eight events after the initial IN-
PACKAGE form and try to include the remainder of the book.  This may
expose local incompatibilities.

Summary
Form:  ( INCLUDE-BOOK "element_equality-verification-condition-1" ...)
Rules: NIL
Time:  0.00 seconds (prove: 0.00, print: 0.00, proof tree: 0.00, other: 0.00)

ACL2 Warning [Guards] in (CERTIFY-BOOK 
"element_equality-verification-condition-1" ...):  For the book 
"C:/Users/whitebot/Desktop/C-lightVer2/element_equality-verification-condition-1.lisp",
its included sub-books and/or its certification world define functions
CDR-CDR-INDUCT, CDR-DEC-INDUCT, CDR-INDUCT, DEC-DEC-INDUCT, DEC-INDUCT,
DEFSORT-FUNCTIONAL-INST-SUBST, FLAG::DO-BOTH, ELEMENT-EQ, ELEMENT-EQUIV,
ELEMENT-LIST-EQUIV, ELEMENT-LIST-FIX, ELEMENT-LIST-NONEMPTY-P, 
ELEMENT-LIST-P, ELEMENTLIST-MAPAPPEND, ELEMENTLIST-PROJECTION, 
FIX-COMPARABLEP, FLAG-IS, IFF-LIST, INTERSECTP-WITNESS, KEYVAL-ALIST-P,
STD::MAKE-DEFINE-CONFIG-FN, XDOC::MAKE-XDOC-FRAGMENTS, NATS-EQUIV,
OUTELEMENT-LIST-P, REP-1, RULETABLE-DELETE-TAGS, RULETABLE-KEEP-TAGS,
SAVED-OBLIGS-HINTS-TO-COMPUTED, SAVED-OBLIGS-PROOFLST-COLLECT-HINTS,
SET-UNEQUAL-WITNESS, SUBSETP-WITNESS, UNIVERSAL-EQUIV-EQUIVTERMS, 
UNIVERSAL-EQUIV-MULTI-QVAR-BINDINGS and UNIVERSAL-EQUIV-QVAR-BINDINGS,
which have not had their guards verified.  See :DOC guards.


* Step 4:  Write the certificate for 
"C:/Users/whitebot/Desktop/C-lightVer2/element_equality-verification-condition-1.lisp"
in 
"C:/Users/whitebot/Desktop/C-lightVer2/element_equality-verification-condition-1.cert".


* Step 5:  Compile the functions defined in 
"C:/Users/whitebot/Desktop/C-lightVer2/element_equality-verification-condition-1.lisp".


Writing book expansion file, C:/Users/whitebot/Desktop/C-lightVer2/element_-
equality-verification-condition-1@expansion.lsp.


Note: Deleting expansion file for the book,
C:/Users/whitebot/Desktop/C-lightVer2/element_equality-verification-
condition-1.lisp.

Summary
Form:  (CERTIFY-BOOK "element_equality-verification-condition-1" ...)
Rules: NIL
Warnings:  Guards
Time:  1.11 seconds (prove: 0.34, print: 0.02, proof tree: 0.00, other: 0.75)
Prover steps counted:  70795
 "C:/Users/whitebot/Desktop/C-lightVer2/element_equality-verification-condition-1.lisp"
ACL2 !>Bye.
